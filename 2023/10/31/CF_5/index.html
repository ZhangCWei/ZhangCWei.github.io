<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","Sidebar Display (only for Muse | Mist), available values":["hide    expand only when click on the sidebar toggle icon."],"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="中间代码生成是指在编程语言的编译过程中，将高级语言（如C++、Java等）的源代码转换成一种中间形式的代码。这个中间形式通常是低级语言或者称为中间语言，它是一种介于人类可读的高级语言和计算机能直接执行的机器码之间的中间产物。中间代码的主要目的是为了便于进一步的编译优化和代码生成...">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理5：中间代码生成">
<meta property="og:url" content="http://example.com/2023/10/31/CF_5/index.html">
<meta property="og:site_name" content="Methods for DIP">
<meta property="og:description" content="中间代码生成是指在编程语言的编译过程中，将高级语言（如C++、Java等）的源代码转换成一种中间形式的代码。这个中间形式通常是低级语言或者称为中间语言，它是一种介于人类可读的高级语言和计算机能直接执行的机器码之间的中间产物。中间代码的主要目的是为了便于进一步的编译优化和代码生成...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/img1698118448890.jpg">
<meta property="og:image" content="http://example.com/images/imgimage-20231024114412407.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231024114450617.png">
<meta property="og:image" content="http://example.com/images/img1698119294168.jpg">
<meta property="og:image" content="http://example.com/images/imgimage-20231026133803037.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231026133902137.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231026103352438.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231026103431973.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231026103638666.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231026103723533.png">
<meta property="og:image" content="http://example.com/images/image-20231117163223936.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231026114442257.png">
<meta property="og:image" content="http://example.com/images/52316425686ba4a36d2b7c49af211f4.png">
<meta property="og:image" content="http://example.com/images/image-20231117163138758.png">
<meta property="og:image" content="http://example.com/images/v2-91a9846cd13d3fccfbb43d66fe1f0cb2_1440w.webp">
<meta property="og:image" content="http://example.com/images/image-20231117164127274.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231102101322488.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231102101613447.png">
<meta property="og:image" content="http://example.com/images/v2-f8e2ff6744ba2902bf14b08980ef7838_1440w.webp">
<meta property="og:image" content="http://example.com/images/imgimage-20231102102107043.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231102102246895.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231102102515450.png">
<meta property="og:image" content="http://example.com/images/img4666271f88c9c45d1299558fb30b8fd.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231102102739288.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231102102920661.png">
<meta property="og:image" content="http://example.com/images/v2-1d3c0f312dcb9ab26f49cb43b8f58a1f_1440w.webp">
<meta property="og:image" content="http://example.com/images/imgimage-20231102103659246.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231102104630823.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231102104803633.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231102105351656.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231102112038642.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231102110554380.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231102113023312.png">
<meta property="og:image" content="http://example.com/images/image-20231117125517097.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231102114031311.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231102114529801.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231102114553474.png">
<meta property="og:image" content="http://example.com/images/imgimage-20231102114648139.png">
<meta property="og:image" content="http://example.com/images/image-20231109103806288.png">
<meta property="og:image" content="http://example.com/images/image-20231109103821048.png">
<meta property="og:image" content="http://example.com/images/v2-e99f7b17132b0d8210f3eea62ea0933d_1440w.png">
<meta property="og:image" content="http://example.com/images/image-20231117144832194.png">
<meta property="og:image" content="http://example.com/images/v2-11759adc1cf77db5300c1f6d8463935e_1440w.png">
<meta property="og:image" content="http://example.com/images/v2-1e4c4818cfe96e94d24e08ba195ab9cd_1440w.webp">
<meta property="og:image" content="http://example.com/images/v2-f0dbd8de88509d7a308f68dfcf269883_1440w.webp">
<meta property="og:image" content="http://example.com/images/image-20231109111233285.png">
<meta property="og:image" content="http://example.com/images/image-20231109112709810.png">
<meta property="og:image" content="http://example.com/images/image-20231116095817703.png">
<meta property="og:image" content="http://example.com/images/image-20231117154138574.png">
<meta property="og:image" content="http://example.com/images/image-20231117155028410.png">
<meta property="og:image" content="http://example.com/images/image-20231116100537125.png">
<meta property="article:published_time" content="2023-10-31T09:03:07.000Z">
<meta property="article:modified_time" content="2024-02-12T14:39:09.285Z">
<meta property="article:author" content="ZhangChengWei">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/img1698118448890.jpg">


<link rel="canonical" href="http://example.com/2023/10/31/CF_5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/10/31/CF_5/","path":"2023/10/31/CF_5/","title":"编译原理5：中间代码生成"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>编译原理5：中间代码生成 | Methods for DIP</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Methods for DIP</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">By ZhangCW & WeiGP & JiangT</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">中间代码生成</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E6%A6%82%E8%BF%B0"><span class="nav-text">中间代码生成概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E5%9C%B0%E5%9D%80%E4%BB%A3%E7%A0%81"><span class="nav-text">三地址代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A3%B0%E6%98%8E"><span class="nav-text">类型和声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BF%BB%E8%AF%91"><span class="nav-text">表达式的翻译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="nav-text">类型检查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-text">控制流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E5%A1%AB"><span class="nav-text">回填</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZhangChengWei</p>
  <div class="site-description" itemprop="description">paper analysis</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/31/CF_5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhangChengWei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Methods for DIP">
      <meta itemprop="description" content="paper analysis">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="编译原理5：中间代码生成 | Methods for DIP">
      <meta itemprop="description" content="中间代码生成是指在编程语言的编译过程中，将高级语言（如C++、Java等）的源代码转换成一种中间形式的代码。这个中间形式通常是低级语言或者称为中间语言，它是一种介于人类可读的高级语言和计算机能直接执行的机器码之间的中间产物。中间代码的主要目的是为了便于进一步的编译优化和代码生成...">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          编译原理5：中间代码生成
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-31 17:03:07" itemprop="dateCreated datePublished" datetime="2023-10-31T17:03:07+08:00">2023-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-12 22:39:09" itemprop="dateModified" datetime="2024-02-12T22:39:09+08:00">2024-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CF/" itemprop="url" rel="index"><span itemprop="name">CF</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">中间代码生成是指在编程语言的编译过程中，将高级语言（如C++、Java等）的源代码转换成一种中间形式的代码。这个中间形式通常是低级语言或者称为中间语言，它是一种介于人类可读的高级语言和计算机能直接执行的机器码之间的中间产物。中间代码的主要目的是为了便于进一步的编译优化和代码生成...</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1>中间代码生成</h1>
<h2 id="中间代码生成概述">中间代码生成概述</h2>
<p>**编译器前端的逻辑结构  **</p>
<p><img src="/images/img1698118448890.jpg" alt="1698118448890"></p>
<ul>
<li>前端是<strong>对源语言进行分析</strong>并产生中间表示，处理与源语言相关的细节，与目标机器无关</li>
</ul>
<p><strong>常用的中间表示形式</strong></p>
<ul>
<li>
<p>三地址代码</p>
</li>
<li>
<p>语法(结构)树</p>
</li>
</ul>
<p><strong>重定位(可复用)</strong></p>
<ul>
<li>为新的机器建编译器，只需要做<strong>从中间代码到新的目标代码</strong>的翻译器 (<strong>前端独立</strong>)</li>
</ul>
<p><strong>高层次的优化</strong></p>
<ul>
<li><strong>优化</strong>与源语言和目标机器都无关</li>
</ul>
<h2 id="三地址代码">三地址代码</h2>
<p><strong>目标</strong></p>
<ul>
<li>
<p>接近大多数目标机器的<strong>执行模型</strong> (机器码)</p>
</li>
<li>
<p>支持大多数目标机器提供的<strong>数据类型和操作</strong></p>
</li>
<li>
<p>提供有限度的、高于机器码的<strong>抽象表达能力</strong>，更容易表达出大多数 (命令式) 高级语言的特性</p>
</li>
</ul>
<p><strong>特征</strong></p>
<ul>
<li>
<p>以<strong>指令</strong>为单位</p>
</li>
<li>
<p>每条指令只有<strong>有限数量的运算分量</strong> (通常≤3)</p>
</li>
<li>
<p>支持<strong>基本数据类型</strong>及其运算</p>
</li>
<li>
<p>支持<strong>复合数据类型</strong> (如数组、结构体) 及其操作</p>
</li>
<li>
<p>支持<strong>函数</strong></p>
</li>
</ul>
<p><strong>三地址代码由类似于汇编语言的指令序列组成</strong>，<strong>每个指令最多有三个操作数</strong></p>
<ul>
<li>
<p>每条指令<strong>右侧</strong>最多有<strong>一个运算符</strong></p>
<ul>
<li>
<p>接近机器码 (易于从机器角度优化)</p>
</li>
<li>
<p>大大减少组合情况的数量 (易于处理)</p>
</li>
</ul>
</li>
<li>
<p>允许的<strong>运算分量</strong></p>
<ul>
<li>
<p>变量：源程序中的<strong>名字</strong>作为三地址代码的<strong>地址</strong></p>
</li>
<li>
<p>常量：源程序中出现或生成的常量</p>
</li>
<li>
<p>编译器生成的临时变量 (与源程序变量等同视之)</p>
</li>
</ul>
<p>==<strong>常用三地址指令</strong>(记)==</p>
</li>
</ul>
<img src="/images/imgimage-20231024114412407.png" alt="image-20231024114412407" style="zoom: 50%;" />
<img src="/images/imgimage-20231024114450617.png" alt="image-20231024114450617" style="zoom: 50%;" />
<ul>
<li>示例</li>
</ul>
<img src="/images/img1698119294168.jpg" alt="1698119294168" style="zoom: 33%;" />
<p><strong>三地址指令的表示</strong></p>
<ul>
<li>
<p>四元式</p>
<ul>
<li>
<p>(op,arg1,arg2,result)</p>
<ul>
<li>
<p>op是操作符， 是运算符的内部编码</p>
</li>
<li>
<p>arg1和arg2是源操作数，是地址</p>
<ul>
<li>
<p><strong>单目运算符</strong>不使用arg2</p>
</li>
<li>
<p><strong>param运算</strong>不使用arg2和result</p>
</li>
</ul>
</li>
<li>
<p>result是目标操作数，是<strong>地址</strong></p>
<ul>
<li>(非)条件转移将目标标号放在result</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/imgimage-20231026133803037.png" alt="image-20231026133803037" style="zoom:50%;" />
<ul>
<li>数组的四元式表示</li>
</ul>
<img src="/images/imgimage-20231026133902137.png" alt="image-20231026133902137" style="zoom:50%;" />
<ul>
<li>
<p>三元式</p>
</li>
<li>
<p>间接三元式</p>
</li>
<li>
<p><strong>静态单赋值(SSA)</strong></p>
<ul>
<li>
<p>SSA是一种特殊的三地址代码，其所有变量在代码中<strong>只被赋值一次</strong></p>
<ul>
<li>
<p>通常只针对函数内的变量 (即<strong>局部变量</strong>) 计算SSA</p>
</li>
<li>
<p>全局变量的SSA在实际当中难以计算</p>
</li>
</ul>
</li>
<li>
<p>基本构造思路</p>
<ul>
<li>
<p>为每个变量维护一个计数器</p>
</li>
<li>
<p>从函数入口开始遍历函数体</p>
</li>
<li>
<p>遇到<strong>变量赋值</strong>时，为其生成<strong>新名字</strong>，并<strong>替换</strong></p>
</li>
<li>
<p>将新变量名传播到<strong>后续相应的使用处</strong>，并替换</p>
</li>
</ul>
</li>
<li>
<p><strong>SSA对分支的处理</strong></p>
<ul>
<li>在分支汇合处插入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">φ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span></span></span></span>语句</li>
<li>对于同一个变量x在不同路径中被赋值的情况， 使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mi>φ</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>k</mi></msub><mo separator="true">,</mo><mo>…</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x_i=φ(x_j, x_k, … )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mclose">)</span></span></span></span> 来<strong>合并</strong>不同的赋值</li>
<li>
<img src="/images/imgimage-20231026103352438.png" alt="image-20231026103352438" style="zoom: 50%;" />
</li>
</ul>
</li>
<li>
<p><strong>SSA对循环的处理</strong></p>
<ul>
<li>循环被翻译成分支与跳转语句的组合</li>
<li>
<img src="/images/imgimage-20231026103431973.png" alt="image-20231026103431973" style="zoom: 50%;" />
</li>
</ul>
</li>
<li>
<p>SSA的作用</p>
<ul>
<li>
<p>每个变量只被赋值一次，相当于都变成const变量</p>
</li>
<li>
<p>简化了<strong>数据流分析</strong>和某些优化</p>
</li>
<li>
<p>使得**定义-使用链 (def-use chain)**易于计算</p>
<ul>
<li>
<p>关联每个变量的定义 (赋值) 及其相应的使用</p>
</li>
<li>
<p>许多分析和优化所需的关键信息</p>
</li>
<li>
<p>SSA形式中，<strong>定义-使用关系非常清晰</strong>，且可以<strong>线性复杂度</strong>进行计算</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/imgimage-20231026103638666.png" alt="image-20231026103638666" style="zoom: 50%;" />
<img src="/images/imgimage-20231026103723533.png" alt="image-20231026103723533" style="zoom: 50%;" />
<h2 id="类型和声明">类型和声明</h2>
<p><strong>任务与用途</strong></p>
<p>​		确定名字的<strong>类型</strong>,变量的存储空间<strong>布局</strong>(相对地址)</p>
<p>​		具体而言，包括：查错、<u>确定名字 (对应的数据) 所需的内存空间</u>、<u>计算数组元素的地址</u>、类型转换、选择正确的运算符</p>
<p><strong>类型检查</strong></p>
<ul>
<li>利用一组规则来检查<strong>运算分量</strong>的类型和<strong>运算符的预期</strong>类型是否匹配</li>
</ul>
<p><strong>类型</strong></p>
<ul>
<li>
<p>基本类型</p>
<ul>
<li>
<p>程序设计语言中的<strong>原子类型</strong></p>
</li>
<li>
<p>都有<strong>对应的机器指令</strong></p>
</li>
<li>
<p>如boolean、char、integer…</p>
</li>
</ul>
</li>
<li>
<p>复合类型</p>
<ul>
<li>
<p>由基本类型或其它复合组合而成，为程序设计语言提供<strong>更强的抽象和表达能力</strong></p>
</li>
<li>
<p>如数组、结构体、函数等</p>
</li>
<li>
<p><strong>类型表达式</strong></p>
<ul>
<li>表示类型的表达式
<ul>
<li>基本类型：类型名字</li>
<li>复合类型：通过<strong>类型构造算子</strong>作用于类型表达式得到</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数组类型</p>
<ul>
<li>
<p>表示<strong>同类型</strong>数据的聚合</p>
</li>
<li>
<p>类型构造算子array， 有两个参数</p>
<ul>
<li>
<p>数字：表示数组的长度</p>
</li>
<li>
<p>类型：表示数组元素的类型</p>
</li>
</ul>
</li>
<li>
<p>如：int [2][3]  =&gt;  array(2, array(3, integer))</p>
</li>
<li>
<p>为什么需要类型表达式？更加<strong>灵活</strong>，可以表达构造过程，可含变量</p>
</li>
</ul>
</li>
<li>
<p>记录类型</p>
<ul>
<li>
<p>表示<strong>不同类型</strong>数据的聚合 (结构体、类)</p>
</li>
<li>
<p>类型构造算子<strong>record</strong>， 有多组字段</p>
<ul>
<li>
<p>字段名：可用于在记录中引用该字段</p>
</li>
<li>
<p>类型：字段对应数据的类型</p>
</li>
</ul>
</li>
<li>
<p>记录的基本构造算子是<strong>笛卡尔积×</strong></p>
<ul>
<li>
<p>若s, t是类型表达式，则s×t也是类型表达式</p>
</li>
<li>
<p>在记录类型的构造中起<strong>组合</strong>作用</p>
<ul>
<li>
<p>组合<strong>字段名</strong>与<strong>相应类型</strong></p>
</li>
<li>
<p>组合<strong>多组字段</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>例：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;<span class="type">int</span> a[<span class="number">10</span>];<span class="type">float</span> f;&#125;st; =&gt; <span class="built_in">record</span>((a × <span class="built_in">array</span>(<span class="number">10</span>,<span class="type">int</span>))×(f × <span class="type">float</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>函数类型</p>
<ul>
<li>
<p>表示程序中函数的类型</p>
</li>
<li>
<p>类型构造算子<strong>→</strong>，接收<strong>参数类型</strong>与<strong>返回值类型</strong>，并构造出<strong>函数类型</strong></p>
</li>
<li>
<p>例：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">float</span> x, <span class="type">long</span>[<span class="number">5</span>] y )</span> </span>&#123; … &#125;  =&gt;  (<span class="type">float</span> × <span class="built_in">array</span>(<span class="number">5</span>, <span class="type">long</span>)) → <span class="type">int</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>==类型等价性==</p>
<ul>
<li>
<p>判断两个类型是否等价</p>
<ul>
<li>
<p>类型检查的基础</p>
</li>
<li>
<p>不同的语言有不同的类型等价的定义</p>
</li>
<li>
<p>当语言允许为自定义类型命名时，主要有两类等价性判定方式：</p>
<ul>
<li>
<p>名等价</p>
<ul>
<li>类型表达式t与u等价当且仅当它们<strong>对应的类型名字相同</strong></li>
</ul>
</li>
<li>
<p>结构等价</p>
<ul>
<li>
<p>对于<strong>基本</strong>类型，比较它们<strong>名字</strong>是否相同</p>
</li>
<li>
<p>对于<strong>复合</strong>类型，比较<strong>类型构造算子</strong>：</p>
<p>若相同， 则(递归)比较构造算子的各<strong>参数分量</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>类型声明</strong></p>
<ul>
<li>处理数组类型或记录类型的文法</li>
</ul>
<img src="/images/image-20231117163223936.png" alt="image-20231117163223936" style="zoom: 67%;" />
<ul>
<li>
<p>应用该文法及其对应的语法制导定义，除了得到<strong>类型表达式</strong>之外，</p>
<p>还得进行各种类型的<strong>存储布局</strong></p>
<ul>
<li>
<p>局部变量的存储布局</p>
<ul>
<li>
<p>变量的类型可以确定变量需要的内存</p>
<ul>
<li>即类型的<strong>宽度</strong>(该类型一个对象所需的存储单元的数量)</li>
</ul>
</li>
<li>
<p>可变大小的数据结构只需要考虑指针</p>
</li>
</ul>
</li>
<li>
<p>函数的<strong>局部变量</strong>总是分配在<strong>连续的区间</strong></p>
</li>
<li>
<p>因此给每个变量分配一个相对于这个区间开始处的<strong>相对地址</strong> (偏移量)</p>
</li>
<li>
<p>变量的类型信息保存在<strong>符号表</strong>中</p>
</li>
</ul>
</li>
</ul>
<p><strong>计算T的类型和宽度的SDT</strong></p>
<p>​		对于综合属性：type, width：</p>
<ul>
<li>
<p>类型的宽度（width）是指该类型的一个对象所需的存储单元的数量。一个基本类型，比如字符型、整型和浮点型，需要多个字节，在编译的时候就需要分配空间。为了方便访问，为数组和类这样的组合类型数据分配的内存是一个连续的存储字节块。同时，变量的类型和相对地址保存在相应的<strong>符号表</strong>记录中</p>
</li>
<li>
<p>全局变量<em>t</em>和<em>w</em>用于<strong>将类型和宽度信息从<em>B</em>传递到对应产生式<em>C</em> -&gt; ε的节点</strong>；</p>
</li>
<li>
<p>在语法制导定义中，它们相当于<em>C</em>的继承属性 (也可以把<em>t</em>和<em>w</em>替换为<em>C.t</em>和<em>C.w</em>)</p>
</li>
</ul>
<img src="/images/imgimage-20231026114442257.png" alt="image-20231026114442257" style="zoom:50%;" />
<p><strong>SDT运行的示例</strong></p>
<p>​		输入：int [2][3]</p>
<img src="/images/52316425686ba4a36d2b7c49af211f4.png" alt="52316425686ba4a36d2b7c49af211f4" style="zoom:50%;" />
<p><strong>变量声明</strong></p>
<p>​		如果只声明一个变量，一次声明包括一个变量类型和一个变量名并以一个 ”;” 结尾，如：int x;。这种声明方式可以扩展成<strong>序列</strong>的形式，如int x; float y; char z;，这种形式通常用于声明记录中的字段。基本类型变量的声明可以用下面的文法表示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D → T id; D | ε</span><br></pre></td></tr></table></figure>
<p>​		结合之前的文法，可以得到</p>
<img src="/images/image-20231117163138758.png" alt="image-20231117163138758" style="zoom:50%;" />
<p>​		在这个文法中：</p>
<ul>
<li>符号T表示<u>基本</u>类型、<u>数组</u>类型和<u>记录(结构体)</u>类型；</li>
<li>符号D表示<strong>声明序列</strong>，这个序列中至少声明了一个变量；</li>
<li>符号id表示<strong>变量名</strong>，严格地说，在声明序列中的任何两个变量的名字都不相同。</li>
</ul>
<p><strong>变量存储</strong></p>
<p>​		变量的类型告诉我们它在运行时刻需要多大的内存空间，在编译时刻，我们可以使用变量的内存大小信息为每个变量分配一个相对地址。</p>
<p>​		一个变量的<strong>相对地址</strong>需要用该变量的<strong>起始地址</strong>和该变量的<strong>类型宽度</strong>来刻画。其中，起始地址是用于存储变量的字节块的第一个字节的地址，类型宽度是用于存储变量的字节块包含的字节数。</p>
<p>​		例如，假设x是一个整型变量并且它的起始地址为100，那么x的相对地址是从100开始，到103结束的4字节的字节块。</p>
<p>​		假设<strong>存储变量的方式是连续的</strong>（即对变量x和y，x的相对地址是从d~1~到d~i~的字节块，那么y的起始地址是d~i+1~），则存储变量的关键问题变成了确定每个变量需要多大的存储空间（说白了就是确定每个类型的宽度）。下面我们对计算基本类型、数组类型和记录类型的宽度分别进行说明：</p>
<ul>
<li><strong>基本类型</strong>。基本类型的宽度是由语言事先定义的，如Java的int类型的宽度是4个字节；</li>
<li><strong>数组类型</strong>。数组类型的宽度是由元素的类型宽度和元素的数量共同决定的，比如数组类型int[3]的宽度是4*3=12个字节；</li>
<li><strong>记录类型</strong>。记录类型的宽度是由该记录中所有字段的类型宽度共同决定的，比如记录类型record{ int x; int y; }的宽度是4+4=8个字节。</li>
</ul>
<p>​		包括基本类型、数组类型和记录类型在内的声明语句的一个可行的SDT如下：</p>
<p>​		这里，可以增加一条规则P-&gt;D {offset=0}；也即在第一个声明之前，offset被设置为0。在进行产生式D-&gt;T id; D的处理时，每增加一个变量 x 时， x 被加入符号表，它的相对地址被设置为Offset的当前值。然后， x 的类型宽度被加到offset上。</p>
<p>​		产生式D-&gt;T id; D的语义动作首先执行top.push(id.lexeme，T.type,offset)，表示创建了一个符号表条目。这里的top指向当前的符号表，方法top.push为id.lexeme创建一个符号表条目，条目的数据区存放了类型T.type以及相对地址。</p>
<p>​		对记录类型的宽度进行计算是一个比较复杂的过程，这种情况下，需要把记录中的字段保存到一个新的符号表中（相近的概念是<strong>变量的作用域</strong>）：</p>
<img src="/images/v2-91a9846cd13d3fccfbb43d66fe1f0cb2_1440w.webp" alt="img" style="zoom:50%;" />
<ul>
<li>首先，在产生式T→record’{‘P’}'中，第一个动作对当前的上下文环境进行保存，该动作把指向当前符号表的指针top和记录字段偏移量的变量offset保存到Stack中，并把top指向一个新符号表，把offset重置为0；【这里的stack是用于保存上下文的辅助结构；主要是用于记录每个scope中当前的offset】</li>
<li>然后，在产生式D→T id;D1中，动作把名为id.lexeme的变量加入到符号表中，并将offset加上该变量的类型宽度；</li>
<li>接着，重复第2步直到没有新的变量被声明，即到达产生式D→ε；</li>
<li>最后，在产生式T→record’{‘P’}'中，第二个动作计算记录类型的宽度并对之前的上下文环境进行还原，该动作把记录的类型设为record(top)，把记录的宽度设为offset，并把top指向第1步保存在Stack中的符号表，把offset设为第1步保存在Stack中的值</li>
</ul>
<img src="/images/image-20231117164127274.png" alt="image-20231117164127274" style="zoom:50%;" />
<h2 id="表达式的翻译">表达式的翻译</h2>
<p><strong>表达式代码的SDD</strong></p>
<ul>
<li>
<p>将<strong>表达式</strong>翻译成<strong>三地址代码的SDD</strong></p>
<ul>
<li>
<p>为每一次计算引入一个临时变量存储计算结果</p>
</li>
<li>
<p>例：</p>
<ul>
<li>
<p>code表示代码</p>
</li>
<li>
<p>addr表示存放表达式结果的地址</p>
</li>
<li>
<p>new Temp()生成临时变量</p>
</li>
<li>
<p>gen()生成指令</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/imgimage-20231102101322488.png" alt="image-20231102101322488" style="zoom: 50%;" />
<p><strong>增量式翻译方案</strong></p>
<ul>
<li>类似于上一章中所述的<strong>边扫描边生成</strong></li>
<li>gen不仅构造新的三地址指令，还要<strong>将它添加到至今为止已生成的指令序列之后</strong></li>
<li>不需要code指令保存已有的代码，而<strong>是对gen的连续调用</strong>生成一个<strong>指令序列</strong></li>
</ul>
<img src="/images/imgimage-20231102101613447.png" alt="image-20231102101613447" style="zoom:50%;" />
<ul>
<li>
<p>示例解释</p>
<ul>
<li>
<p>非终结符号S是一个表达式</p>
</li>
<li>
<p>非终结符号E是一个子表达式，addr属性表示对应变量的变量名/临时变量名/代数值</p>
</li>
<li>
<p>终结符号id表示一个运算分量，它的lexeme属性是由<strong>词法分析器返回</strong>的值</p>
</li>
<li>
<p>top是一个指向当前符号表的指针，top.get(x)表示<strong>从符号表中取得标号为x的记录</strong></p>
</li>
<li>
<p>gen是一个负责生成三地址代码的函数，传递给它的参数就是需要生成的三地址代码。参数中包括<strong>变量</strong>和<strong>字面常量</strong>，字面常量需要在左右加上<strong>单引号</strong></p>
</li>
<li>
<p>Temp函数负责<strong>生成临时地址</strong>，这个临时地址通常用于编译器产生的临时变量</p>
</li>
</ul>
</li>
<li>
<p>以表达式 x = a + (-b)为例，注释语法分析树和三地址代码如下：</p>
</li>
<li>
<p>由于每个语义动作都在产生式的最右端，因此这个SDT可以在<strong>自底向上</strong>的语法分析过程中实现。详细的翻译过程如下：</p>
<ul>
<li>第一次归约发生在图a中的标记1处，这里使用了产生式E→-E，相应的语义动作生成了图b中的第1条指令</li>
<li>第二次归约发生在图a中的标记2处，这里使用了产生式E→E+E，相应的语义动作生成了图b中的第2条指令</li>
<li>第三次归约发生在图a中的标记3处，这里使用了产生式S→id=E，相应的语义动作生成了图b中的第3条指令</li>
</ul>
</li>
</ul>
<img src="/images/v2-f8e2ff6744ba2902bf14b08980ef7838_1440w.webp" alt="img" style="zoom: 67%;" />
<p><strong>数组寻址</strong></p>
<ul>
<li>
<p>一维数组 (A[i]) 寻址</p>
</li>
<li>
<p>假设数组元素被存放在<strong>连续的存储空间</strong>中，元素<strong>从0到n−1编号</strong>，第i个元素的地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo>+</mo><mi>i</mi><mo>∗</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">base + i *w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ba</span><span class="mord mathnormal">se</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>维数组 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><msub><mi>i</mi><mn>1</mn></msub><mo stretchy="false">]</mo><mo stretchy="false">[</mo><msub><mi>i</mi><mn>2</mn></msub><mo stretchy="false">]</mo><mo>…</mo><mo stretchy="false">[</mo><msub><mi>i</mi><mi>k</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[i_1][i_2]…[i_k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>)寻址</p>
</li>
<li>
<p>假设数组<strong>按行存放</strong>，首先存放<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><msub><mi>i</mi><mn>2</mn></msub><mo stretchy="false">]</mo><mo>…</mo><mo stretchy="false">[</mo><msub><mi>i</mi><mi>k</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[0][i_2]…[i_k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>， 然后存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><msub><mi>i</mi><mn>2</mn></msub><mo stretchy="false">]</mo><mo>…</mo><mo stretchy="false">[</mo><msub><mi>i</mi><mi>k</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[1][i_2]…[i_k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>， …， 那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><msub><mi>i</mi><mn>1</mn></msub><mo stretchy="false">]</mo><mo stretchy="false">[</mo><msub><mi>i</mi><mn>2</mn></msub><mo stretchy="false">]</mo><mo>…</mo><mo stretchy="false">[</mo><msub><mi>i</mi><mi>k</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[i_1][i_2]…[i_k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>的地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo>+</mo><msub><mi>i</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>w</mi><mn>1</mn></msub><mo>+</mo><msub><mi>i</mi><mn>2</mn></msub><mo>∗</mo><msub><mi>w</mi><mn>2</mn></msub><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>i</mi><mi>k</mi></msub><mo>∗</mo><msub><mi>w</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">base+i_1*w_1+i_2*w_2+…+i_k*w_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ba</span><span class="mord mathnormal">se</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>base, w的值可以从符号表中找到</li>
</ul>
</li>
</ul>
<img src="/images/imgimage-20231102102107043.png" alt="image-20231102102107043" style="zoom:67%;" />
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设type(a) = array(2, array(3, array(4, array(5, int)))</span><br><span class="line">(1) 计算a[1][2][3][4]的地址。</span><br><span class="line">(2) 计算a[i1][i2][i3][i4]的地址。</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>数组引用的翻译</strong></p>
<ul>
<li>
<p>为数组引用生成代码要解决的主要问题</p>
<ul>
<li><strong>数组引用的文法</strong>和<strong>地址计算</strong>相关联</li>
</ul>
</li>
<li>
<p>若数组编号从<strong>0</strong>开始，基于宽度来计算相对地址</p>
</li>
<li>
<p>数组引用相关文法</p>
<ul>
<li>非终结符号L生成数组名，加上一个<strong>下标表达式序列</strong></li>
</ul>
</li>
</ul>
<img src="/images/imgimage-20231102102246895.png" alt="image-20231102102246895" style="zoom: 50%;" />
<ul>
<li>
<p>数组引用生成代码的翻译方案</p>
<ul>
<li>
<p>非终结符号L的三个综合属性</p>
<ul>
<li>
<p>L.array是一个指向<strong>数组名字</strong>对应的<strong>符号表条目</strong>的<strong>指针</strong><br>
(<strong>L.array.base</strong>为该数组的<strong>基地址</strong>)</p>
</li>
<li>
<p>L.addr指示一个<strong>临时变量</strong>，计算数组引用的<strong>偏移量</strong><br>
base + i~1~ * w~1~ + i~2~ * w~2~ + … + i~k~ * w~k~</p>
</li>
<li>
<p>L.type是L生成的<strong>子数组的类型</strong></p>
<ul>
<li>
<p>对于任何 (子) 数组类型L.type， 其宽度由L.type.width给出</p>
</li>
<li>
<p>L.type.elem给出其<strong>数组元素的类型</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<img src="/images/imgimage-20231102102515450.png" alt="image-20231102102515450" style="zoom: 67%;" />
- 核心：**确定数组引用的地址**
- L的代码只计算了**偏移量**：数组元素的存放地址应该根据偏移量进一步计算， 即L的数组基址加上偏移量
- 使用三地址指令$x = a[i]$
</li>
<li>
<p>在下表中，每个符号的含义是：</p>
<ul>
<li>非终结符号S和E、终结符号id、变量top、函数gen和Temp的含义与之前表中的相同，非终结符号L表示一个<strong>数组变量</strong></li>
<li>L.array是指向数组名字对应的<strong>符号表条目</strong>的<strong>指针</strong>，假设L.array指向条目a，a.base是数组的<u>基地址</u>，a.type是数组的<u>类型</u>，a.type.elem是数组中<u>元素的类型</u>。例如，对类型为int[2]的数组a，有L.array=a，L.array.base=a[0]，L.array.type=int[2]，L.array.type.elem=int；</li>
<li>L.addr是<strong>相对数组基地址偏移的字节数</strong>，对距离数组基地址L.addr个字节的元素的引用是L.array.base[L.addr]；</li>
<li>L.type是<strong>数组中元素的类型</strong>，等同于L.array.type.elem，L.type.width表示数组中元素的类型宽度。例如，对类型为int[2]的数组a，有L.type=int，L.type.width=4；对类型为int[3][4]的数组b，有L.type=int[4]，L.type.width=16。</li>
</ul>
</li>
</ul>
<img src="/images/img4666271f88c9c45d1299558fb30b8fd.png" alt="4666271f88c9c45d1299558fb30b8fd" style="zoom: 50%;" />
<img src="/images/imgimage-20231102102739288.png" alt="image-20231102102739288" style="zoom:50%;" />
<p><strong>示例1</strong></p>
<p>​		表达式：c + a[i][j]</p>
<img src="/images/imgimage-20231102102920661.png" alt="image-20231102102920661" style="zoom:50%;" />
<p><strong>示例2</strong></p>
<p>​		表达式：a[k] = b[i][j]</p>
<ul>
<li>
<p>详细的翻译过程如下：</p>
<ul>
<li>
<p>第一次归约发生在图a中的标记1处，这里使用了产生式L→id[E]，相应的语义动作生成了图b中的第1条指令；此时需要注意的是，这里使用了top.get来获得数组 a 的相关信息，这里包括判断是否声明、进行类型检查、数组有无越界等各种操作；</p>
</li>
<li>
<p>第二次归约发生在图a中的标记2处，这里使用了产生式L→id[E]，相应的语义动作生成了图b中的第2条指令；此时通过在符号表中进行查找，获得了关于数组 b 的各种信息，包括它的type是int[3][4]；同时计算第一维的偏移；</p>
</li>
<li>
<p>第三次归约发生在图a中的标记3处，这里使用了产生式L→L[E]，相应的语义动作生成了图b中的第3和第4条指令；</p>
</li>
<li>
<p>第四次归约发生在图a中的标记4处，这里使用了产生式E→L，相应的语义动作生成了图b中的第5条指令；</p>
</li>
<li>
<p>第五次归约发生在图a中的标记5处，这里使用了产生式S→L=E，相应的语义动作生成了图b中的第6条指令。</p>
</li>
</ul>
</li>
</ul>
<img src="/images/v2-1d3c0f312dcb9ab26f49cb43b8f58a1f_1440w.webp" alt="img" style="zoom:50%;" />
<h2 id="类型检查">类型检查</h2>
<p><strong>类型系统</strong></p>
<ul>
<li>
<p>规则</p>
<ul>
<li>
<p>给每一个组成部分赋予一个<strong>类型表达式</strong></p>
</li>
<li>
<p>通过一组逻辑规则表达类型表达式<strong>必须满足的条件</strong></p>
</li>
<li>
<p>发现错误、提高代码效率、确定临时变量的大小</p>
</li>
</ul>
</li>
<li>
<p>强类型/弱类型</p>
<ul>
<li>
<p>根据<strong>类型互操作性</strong>/<strong>类型系统严格性</strong>区分</p>
<ul>
<li>
<p>强类型：不允许无关类型数据间的操作</p>
</li>
<li>
<p>弱类型：通过<strong>隐式类型</strong>转换， 允许无关类型间的操作</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>静态类型/动态类型</p>
<ul>
<li>
<p>根据<strong>类型检查时机</strong>区分</p>
<ul>
<li>
<p>静态类型：静态 (编译期) 进行类型检查</p>
</li>
<li>
<p>动态类型：动态 (运行时) 进行类型检查</p>
</li>
<li>
<p>Gradual Typing: 混合，部分静态，部分动态</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/imgimage-20231102103659246.png" alt="image-20231102103659246" style="zoom: 67%;" />
<p><strong>类型规则</strong></p>
<ul>
<li>
<p>记法</p>
<ul>
<li>
<p>用<strong>分式记法</strong>表达推导规则</p>
</li>
<li>
<p><strong>类型判决式</strong></p>
</li>
<li>
<p><strong>无条件成立</strong>的规则</p>
</li>
</ul>
</li>
</ul>
<img src="/images/imgimage-20231102104630823.png" alt="image-20231102104630823" style="zoom:50%;" />
<ul>
<li><strong>标识符的类型规则</strong>
<ul>
<li>为了推导标识符相关的类型，需要在类型规则中引入<strong>上下文</strong>，通常<strong>用Γ表示</strong> (也称作类型环境)</li>
</ul>
</li>
</ul>
<img src="/images/imgimage-20231102104803633.png" alt="image-20231102104803633" style="zoom:50%;" />
<p><strong>示例：</strong></p>
<img src="/images/imgimage-20231102105351656.png" style="zoom:50%;" />
<p><strong>函数/运算符的重载</strong></p>
<ul>
<li>通过<strong>查看参数</strong>来解决函数重载问题</li>
</ul>
<img src="/images/imgimage-20231102112038642.png" alt="image-20231102112038642" style="zoom: 33%;" />
<p><strong>类型转换</strong></p>
<ul>
<li>
<p>假设在表达式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∗</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">x*i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 中，x为浮点数，i为整数，则结果应该是浮点数</p>
<ul>
<li>
<p>x和i使用不同的<strong>二进制表示方式</strong></p>
</li>
<li>
<p>浮点和整数使用<strong>不同的指令</strong></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>a</mi><mi>t</mi><mo stretchy="false">)</mo><mi>i</mi><mtext>   </mtext><msub><mi>t</mi><mn>2</mn></msub><mo>=</mo><mi>x</mi><mtext>  </mtext><mi>f</mi><mi>m</mi><mi>u</mi><mi>l</mi><mtext>  </mtext><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1=(float)i\ \ \ t_2=x\ \ fmul\ \ t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord mathnormal">i</span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">m</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>类型转换比较简单时的SDT</p>
</li>
</ul>
</li>
</ul>
<img src="/images/imgimage-20231102110554380.png" alt="image-20231102110554380" style="zoom: 50%;" />
<p><strong>类型拓宽widening和窄化narrowing</strong></p>
<ul>
<li>
<p>转换</p>
<ul>
<li>
<p><strong>编译器自动完成</strong>的转换为隐式转换</p>
</li>
<li>
<p>用<strong>代码指定</strong>的转换为显式转换</p>
</li>
</ul>
</li>
<li>
<p>拓宽类型转换</p>
<ul>
<li>通常<strong>不丢失</strong>信息</li>
</ul>
</li>
<li>
<p>窄化类型转换</p>
<ul>
<li><strong>有可能丢失</strong>信息</li>
</ul>
</li>
</ul>
<p><strong>处理类型转换的SDT</strong></p>
<ul>
<li>函数max求两个参数在<strong>拓宽层次结构</strong>中的<strong>最小公共祖先</strong></li>
<li>函数widen生成必要的类型转换代码</li>
</ul>
<img src="/images/imgimage-20231102113023312.png" alt="image-20231102113023312" style="zoom: 67%;" />
<h2 id="控制流">控制流</h2>
<p><strong>布尔表达式的控制流翻译</strong></p>
<ul>
<li>
<p>生成的代码执行时<strong>跳转</strong>到两个标号之一</p>
<ul>
<li>
<p>表达式的值为真时，跳转到B.true</p>
</li>
<li>
<p>表达式的值为假时，跳转到B.false</p>
</li>
</ul>
</li>
<li>
<p>B.true和B.false是两个<strong>继承属性</strong>，根据B所在的<strong>上下文</strong>指向不同的位置</p>
<ul>
<li>如果B是<strong>if语句</strong>条件表达式，分别<strong>指向then和else 分支</strong>；如果没有else分支，则B.false指向<strong>if语句的下一条指令</strong></li>
</ul>
</li>
<li>
<p>如果B是<strong>while语句</strong>的条件表达式，分别指向<strong>循环体的开头和循环出口处</strong></p>
</li>
</ul>
<p><strong>控制流语句的翻译</strong></p>
<img src="/images/image-20231117125517097.png" alt="image-20231117125517097" style="zoom: 33%;" />
<ul>
<li>
<p>控制流语句</p>
<ul>
<li>
<p>S → <strong>if</strong> (B) S~1~</p>
</li>
<li>
<p>S → <strong>if</strong> (B) S~1~ <strong>else</strong> S~2~</p>
</li>
<li>
<p>S → <strong>while</strong> (B) S~1~</p>
</li>
</ul>
</li>
<li>
<p>继承属性</p>
<ul>
<li>B.true： B为真时的跳转目标</li>
<li>B.false：B为假时的跳转目标</li>
<li>S.next： S执行完毕时的跳转目标(紧跟在S代码之后的指令的标号)</li>
</ul>
</li>
</ul>
<img src="/images/imgimage-20231102114031311.png" alt="image-20231102114031311" style="zoom: 50%;" />
<ul>
<li><strong>控制流语句的语法制导定义SDT</strong>
<ul>
<li>label(L)：将标号L附加到<strong>即将生成的下一条三地址指令</strong>上</li>
</ul>
</li>
</ul>
<img src="/images/imgimage-20231102114529801.png" alt="image-20231102114529801" style="zoom: 50%;" />
<img src="/images/imgimage-20231102114553474.png" alt="image-20231102114553474" style="zoom: 47%;" />
<ul>
<li><strong>增量式生成代码</strong></li>
</ul>
<img src="/images/imgimage-20231102114648139.png" alt="image-20231102114648139" style="zoom:50%;" />
<p><strong>布尔表达式的翻译</strong></p>
<ul>
<li>
<p>布尔表达式可以用于改变控制流/计算逻辑值</p>
</li>
<li>
<p>文法<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>B</mi><mtext>‖</mtext><mi>B</mi><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mi>B</mi><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mi>B</mi><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mo stretchy="false">!</mo><mi>B</mi><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mi>E</mi><mtext> </mtext><mi><mrow><mi mathvariant="bold-italic">r</mi><mi mathvariant="bold-italic">e</mi><mi mathvariant="bold-italic">l</mi></mrow></mi><mtext> </mtext><mi>E</mi><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mi><mrow><mi mathvariant="bold-italic">t</mi><mi mathvariant="bold-italic">r</mi><mi mathvariant="bold-italic">u</mi><mi mathvariant="bold-italic">e</mi></mrow></mi><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mi><mrow><mi mathvariant="bold-italic">f</mi><mi mathvariant="bold-italic">a</mi><mi mathvariant="bold-italic">l</mi><mi mathvariant="bold-italic">s</mi><mi mathvariant="bold-italic">e</mi></mrow></mi></mrow><annotation encoding="application/x-tex">B→B‖B\ |\ B\&amp;\&amp;B\ |\ !B\ |\ (B)\ |\ E\ \boldsymbol{rel}\ E\ |\ \boldsymbol{true}\ |\ \boldsymbol{false}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">‖</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">&amp;&amp;</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mclose">!</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace"> </span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.0088em;">rel</span></span></span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord"><span class="mord"><span class="mord boldsymbol">true</span></span></span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord"><span class="mord"><span class="mord boldsymbol">false</span></span></span></span></span></span></p>
</li>
<li>
<p>语义</p>
<ul>
<li>
<p>B~1~   ‖   B~2~  中B~1~为真或B~2~为真时，整个表达式为真</p>
</li>
<li>
<p>B~1~ &amp;&amp; B~2~  中B~1~为真且B~2~为真时，整个表达式为真</p>
</li>
</ul>
</li>
<li>
<p><strong>短路求值</strong></p>
<ul>
<li>
<p>通过<strong>跳转指令</strong>实现控制流，<strong>逻辑运算符不出现</strong>在代码中</p>
<ul>
<li>
<p>B~1~   ‖   B~2~  中：B~1~为真时，无需计算B~2~</p>
</li>
<li>
<p>B~1~ &amp;&amp; B~2~  中：B~1~为假时，无需计算B~2~</p>
</li>
</ul>
</li>
<li>
<p>例：</p>
<ul>
<li>语句：if (x &lt; 100 ‖ (x &gt; 200 &amp;&amp; x != y ))  x = 0;</li>
<li>代码，其中L~2~: x = 0；L~1~: 接下去的代码</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码：</span></span><br><span class="line">	<span class="keyword">if</span> x &lt; <span class="number">100</span> <span class="keyword">goto</span> L2</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> x &gt; <span class="number">200</span> <span class="keyword">goto</span> L1</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> x != y <span class="keyword">goto</span> L1</span><br><span class="line">L2: x = <span class="number">0</span></span><br><span class="line">L1: <span class="comment">// 接下来的代码</span></span><br></pre></td></tr></table></figure>
<p><strong>布尔表达式的语义规则SDD</strong></p>
<img src="/images/image-20231109103806288.png" alt="image-20231109103806288" style="zoom:50%;" />
<img src="/images/image-20231109103821048.png" alt="image-20231109103821048" style="zoom:50%;" />
<hr>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">100</span> ‖ x &gt; <span class="number">200</span> &amp;&amp; x != y ) </span><br><span class="line">    x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>Step1</strong>  使用产生式和规则如下：</p>
<img src="/images/v2-e99f7b17132b0d8210f3eea62ea0933d_1440w.png" alt="img" style="zoom: 80%;" />
<p>​		<strong>Step1.1</strong>  在 S~1~ 的代码（x=0）之前生成了标号 L~2~</p>
<p>​		<strong>Step1.2</strong>  L~2~ 对应于 B.true，而 L~1~ 对应于 B.false</p>
<hr>
<p><strong>Step2</strong>  使用<strong>布尔表达式的翻译规则</strong>，对x &lt; 100 || x &gt; 200 &amp;&amp; x != y 进行翻译：</p>
<img src="/images/image-20231117144832194.png" alt="image-20231117144832194" style="zoom: 50%;" />
<p>​		<strong>Step2.1</strong>  因为 &amp;&amp; 的优先级高于 ||，所以先对 x &lt; 100 进行处理：作为 || 运算符的左边部分，(x &lt; 100).true此时就是整个 || 布尔表达式的B.true, 也即L2；B.false要生成L~3~，L~3~就是接下来下一条指令的位置；应用的规则和此时生成的代码如下：</p>
<img src="/images/v2-11759adc1cf77db5300c1f6d8463935e_1440w.png" alt="img" style="zoom:67%;" />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">100</span> <span class="keyword">goto</span> B.<span class="literal">true</span> ; </span><br><span class="line"><span class="keyword">goto</span> B.<span class="literal">false</span>；</span><br></pre></td></tr></table></figure>
<p>​		<strong>Step2.2</strong>  开始处理（x &gt; 200 &amp;&amp; x != y ），L~3~的位置也就是（x &gt; 200 &amp;&amp; x != y ）代码的起始位置；接下来，使用上面的relop的规则，处理 x &gt; 200 和 x != y，目前代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">100</span> <span class="keyword">goto</span> L2 ; </span><br><span class="line"><span class="keyword">goto</span> L3；</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 此时的B.true是下面规则中的B1.true；也即开始处理x != y的起始代码</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">200</span> <span class="keyword">goto</span> B.<span class="literal">true</span> ; </span><br><span class="line"><span class="comment">// 此时的B.false就是B1.false，也就是 || 中右部的false；</span></span><br><span class="line"><span class="comment">// 可以查 || 的翻译方案，知道也就是整个逻辑表达式的.false，也即L1</span></span><br><span class="line"><span class="keyword">goto</span> B.<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x != y <span class="keyword">goto</span> B.<span class="literal">true</span> ; </span><br><span class="line"><span class="keyword">goto</span> B.<span class="literal">false</span>；</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>Step3</strong>  此时使用如下规则处理 &amp;&amp; 表达式，生成了标号B1.true L4；也即接下来要计算B2</p>
<img src="/images/v2-1e4c4818cfe96e94d24e08ba195ab9cd_1440w.webp" alt="img" style="zoom:80%;" />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> x &lt; <span class="number">100</span> <span class="keyword">goto</span> L2 ; </span><br><span class="line">	<span class="keyword">goto</span> L3；</span><br><span class="line">	<span class="keyword">if</span> x &gt; <span class="number">200</span> <span class="keyword">goto</span> L4 ; </span><br><span class="line">	<span class="keyword">goto</span> B.<span class="literal">false</span></span><br><span class="line">L4:	<span class="keyword">if</span> x != y <span class="keyword">goto</span> B.<span class="literal">true</span> ; </span><br><span class="line">	<span class="keyword">goto</span> B.<span class="literal">false</span>；</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>Step4</strong>  最后，B~1~.false、B~2~.true以及 B~2~.false 取决于 B 的整体的 true 和 false 属性，结合||的语义，我们知道 B.false = L~1~；B.true = L~2~</p>
<p>​		所以代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成的中间代码</span></span><br><span class="line">	<span class="keyword">if</span> x &lt; <span class="number">100</span> <span class="keyword">goto</span> L2</span><br><span class="line">    <span class="keyword">goto</span> L3</span><br><span class="line">L3: <span class="keyword">if</span> x &gt; <span class="number">200</span> <span class="keyword">goto</span> L4</span><br><span class="line">    <span class="keyword">goto</span> L1</span><br><span class="line">L4: <span class="keyword">if</span> x != y  <span class="keyword">goto</span> L2</span><br><span class="line">    <span class="keyword">goto</span> L1</span><br><span class="line">L2: x = <span class="number">0</span></span><br><span class="line">L1: <span class="comment">//接下去的代码</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>代码优化</strong></p>
<p>​		<code>if not</code>指令利用了<strong>控制流在指令序列中会从一个指令自然流动到下一个指令</strong>的性质，因此当 x &gt; 200 时，控制流直接“穿越“到标号 L4 ，从而减少了一个跳转指令</p>
<p>​		通过使用<strong>特殊标记 “fall”</strong> (即，不生成任何跳转指令)，我们可以修改上面的语义规则，支持控制流从B的代码直接穿越到 S~1~ 的代码，譬如：</p>
<p>​		对于 S → if (B) S~1~ ，新语义规则是：</p>
<img src="/images/v2-f0dbd8de88509d7a308f68dfcf269883_1440w.webp" alt="img" style="zoom:67%;" />
<p>​		对于语句 “if (true)  S;” ，原本生成的代码是 goto B.true; ，也就是如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   	<span class="keyword">goto</span> L1;</span><br><span class="line">L1: S.code</span><br></pre></td></tr></table></figure>
<pre><code>	现在不再继续生成 B.true 的标号，那么 goto 语句也节省了，代码就只剩下：
</code></pre>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S.code</span><br></pre></td></tr></table></figure>
<p>​		其余优化同理，这里进行省略，得到的中间代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化过的中间代码</span></span><br><span class="line">	<span class="keyword">if</span> x &lt; <span class="number">100</span> <span class="keyword">goto</span> L2</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> x &gt; <span class="number">200</span> <span class="keyword">goto</span> L1</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> x != y <span class="keyword">goto</span> L1</span><br><span class="line">L2: x = <span class="number">0</span></span><br><span class="line">L1: <span class="comment">//接下来的代码</span></span><br></pre></td></tr></table></figure>
<p><strong>布尔值和跳转代码</strong></p>
<ul>
<li>
<p>程序中出现布尔表达式也可能是<strong>求值</strong>：x = a &lt; b</p>
</li>
<li>
<p>处理方法</p>
<ul>
<li>建立<strong>表达式的语法树</strong>，根据表达式的不同角色来处理</li>
</ul>
</li>
<li>
<p>文法</p>
<ul>
<li>
<p>S → id = B ; | if (B) S | while (B) S | S S</p>
</li>
<li>
<p>B → B || B | B &amp;&amp; B | !B | E rel E | …</p>
</li>
</ul>
</li>
<li>
<p>根据<strong>B的语法树结点所在的位置</strong></p>
<ul>
<li>
<p>S -&gt; while(B) S~1~ 中的B，生成<strong>跳转代码</strong></p>
</li>
<li>
<p>对于S -&gt; id = B，生成<strong>计算右值的代码</strong></p>
</li>
</ul>
</li>
</ul>
<h2 id="回填">回填</h2>
<p><strong>标号形式与索引形式</strong></p>
<p>​		各有优缺点：</p>
<ul>
<li>标号形式：可<strong>提前生成</strong>，合适时插入到相应位置；并<strong>不能直接定位</strong>跳转目标指令</li>
<li>索引形式：可<strong>直接定位</strong>跳转目标指令；但<strong>无法提前生成</strong></li>
</ul>
<img src="/images/image-20231109111233285.png" alt="image-20231109111233285" style="zoom:50%;" />
<p>生成<strong>索引形式</strong>代码：</p>
<ul>
<li>方法一：遍历两趟
<ul>
<li>Step 1: 先⽣成基于标号的三地址代码</li>
<li>Step 2: 再遍历三地址码将标号替换为对应索引</li>
</ul>
</li>
<li>方法二：一趟完成（回填）
<ul>
<li>把由跳转指令组成的列表以<strong>综合属性</strong>的形式<strong>自底向上</strong>进行传递</li>
<li>生成跳转指令时<strong>暂不指定目标</strong>，这样的指令都被放入到一个<strong>列表</strong>中</li>
<li><strong>经过 (生成) 跳转目标时，记录其索引</strong></li>
<li>将跳转目标索引<strong>填入到相应跳转语句</strong>中</li>
</ul>
</li>
</ul>
<img src="/images/image-20231109112709810.png" alt="image-20231109112709810" style="zoom: 67%;" />
<p>==<strong>回填</strong>==</p>
<ul>
<li>
<p>为<strong>布尔表达式</strong>和<strong>控制流语句</strong>生成目标代码</p>
<ul>
<li>关键问题：某些跳转指令应该跳转到哪里？</li>
</ul>
</li>
<li>
<p>基本思想</p>
<ul>
<li>
<p>翻译过程中，若遇到跳转目标未知的情况，则先生成<strong>跳转指令坯</strong>，备用</p>
<ul>
<li>goto _____ / if … goto _____</li>
</ul>
</li>
<li>
<p>将<strong>指令坯</strong>并向<strong>父结点</strong>传递 (综合属性)</p>
</li>
<li>
<p>翻译过程中，若遇到某条指令是<strong>跳转目标</strong>，则<strong>记录</strong>其索引，备用S → if (B) ~▲~ S~1~</p>
</li>
<li>
<p>当父结点<strong>收集齐</strong>跳转指令坯及其跳转目标时，<strong>将索引填入指令坯</strong></p>
</li>
</ul>
</li>
<li>
<p>属性（<strong>同一列表</strong>中的跳转指令的<strong>目标都相同</strong>）</p>
</li>
</ul>
<img src="/images/image-20231116095817703.png" alt="image-20231116095817703" style="zoom:50%;" />
<ul>
<li>辅助函数
<ul>
<li>backpatch(p, i)：将 <strong>i 作为跳转目标</strong>插入 p 的所有指令中</li>
</ul>
</li>
<li>在文法中引入非终结符号SDT
<ul>
<li>==M==: 在适当的时候获取<strong>将要生成指令的索引</strong>（记录当前位置）
<ul>
<li>用 M.instr 记录跳转目标指令的索引</li>
</ul>
</li>
<li>==N==: 在适当的位置生成<strong>跳转指令坯</strong>
<ul>
<li>生成 goto指令坯，N.nextlist包含该指令索引</li>
</ul>
</li>
</ul>
</li>
<li><strong>布尔表达式的回填翻译</strong>
<ul>
<li>非终结符号 B 表示一个布尔表达式，它的 truelist 属性是一个<strong>包含指令地址的列表</strong>，这些地址是当 B 为真时控制流应该跳转到的指令地址，它的 falselist 属性也是一个包含指令地址的列表，这些地址是当 B 为假时控制流应该跳转到的指令地址；</li>
<li>非终结符号E表示一个<strong>表达式</strong>，它的addr属性表示<strong>对应变量的代数值</strong>；</li>
<li>符号M是一个标记非终结符号，它的instr属性负责<strong>记录下一条指令的地址</strong>；</li>
<li>变量 nextinstr 表示<strong>下一条指令的地址</strong>，即下一次生成的三地址代码会被放在 nextinstr 所指向的地址上</li>
<li>函数makelist(i)创建<strong>只包含指令地址i的列表</strong>，并返回一个指向新创建列表的指针</li>
<li>函数 merge(p, q) 将 p 和 q 指向的列表合并，并返回一个指向合并的列表的指针</li>
<li>函数 backpatch(p, i) 的功能比较复杂：首先，p 是一个指向列表的指针，对 p 指向的列表中的<strong>每个指令地址 j</strong> ，地址 j 上的指令是一个未填写目标跳转地址的转移指令（如goto _）；其次，i 是一个地址，这个地址是一个<strong>目标跳转地址</strong>；最后，函数==<strong>backpatch用 i 填写每个 j 上的转移指令的目标跳转地址</strong>==</li>
</ul>
</li>
</ul>
<img src="/images/image-20231117154138574.png" alt="image-20231117154138574" style="zoom:67%;" />
<ul>
<li>**示例：**表达式 x &lt; 100 || x &gt; 200 &amp;&amp; x != y
<ul>
<li>为了美观，truelist、falselist和instr都用它们的首字母表示，nextinstr用ni表示。假设初始时指令地址从100开始，即nextinstr指向地址100，如图b(1)所示；</li>
<li><strong>第一次归约</strong>发生在图a中的标记1处，此时nextinstr指向地址100。这里使用了产生式B→E rel E，相应的语义动作把地址100放入B.truelist中，把地址101放入B.falselist中，并生成了图 b(2) 中的两条转移指令，这两条转移指令的目标跳转地址都未被填写；</li>
<li><strong>第二次归约</strong>发生在图a中的标记2处，此时nextinstr指向地址102。这里使用了产生式M→ε，相应的语义动作把M.instr设为102；</li>
<li><strong>第三次归约</strong>发生在图a中的标记3处，此时nextinstr指向地址102。这里使用了产生式B→E rel E，相应的语义动作把地址102放入B.truelist中，把地址103放入B.falselist中，并生成了图b(3)中的两条转移指令，这两条转移指令的目标跳转地址都未被填写；</li>
<li><strong>第四次归约</strong>发生在图a中的标记4处，此时nextinstr指向地址104。这里使用了产生式M→ε，相应的语义动作把M.instr设为104；</li>
<li><strong>第五次归约</strong>发生在图a中的标记5处，此时nextinstr指向地址104。这里使用了产生式B→E rel E，相应的语义动作把地址104放入B.truelist中，把地址105放入B.falselist中，并生成了图3(b)(4)中的两条转移指令，这两条转移指令的目标跳转地址都未被填写；</li>
<li><strong>第六次归约</strong>发生在图a中的标记6处，此时nextinstr指向地址106。这里使用了产生式B→B1 &amp;&amp; MB2，相应的语义动作设置了B.truelist和B.falselist，并用地址104填充地址102上的转移指令的目标跳转地址，如图b(5)所示；</li>
<li><strong>第七次归约</strong>发生在图a中的标记7处，此时nextinstr指向地址106。这里使用了产生式B→B1 || MB2，相应的语义动作设置了B.truelist和B.falselist，并用地址102填充地址101上的转移指令的目标跳转地址，如图3(b)(6)所示；</li>
<li>最终的三地址代码如图b(7)所示，在第六和第七次归约中填充转移指令的目标跳转地址的技术称为回填，回填技术用来在一趟扫描中完成对布尔表达式或控制流语句的目标代码生成。</li>
<li>理解一下，在 B1||B2 中，可以立刻判断出B1.false的位置，也即B2之前，所以在B2 前添加一个 M 就可以算出来 B2 的第一条指令的地址，从而可以使用backpatch(B1.falselist, M.instr)； B1 &amp;&amp; B2 也类似，能很快确定下来 B1.true 的位置，从而可以使用 backpatch(B1.truelist, M.instr)。</li>
<li>在布尔表达式 B1 || B2 本身的处理中不能确定的是 B.true，也即，B1.true 和B2.true 所指向的位置。此时要等到处理控制流语句，如 if 的时候才能确定。也不能确定 B2.false，也即 B.false 的位置，此时要等到控制流语句本身处理完成，找到S.next 才能确定。</li>
</ul>
</li>
</ul>
<img src="/images/image-20231117155028410.png" alt="image-20231117155028410" style="zoom:50%;" />
<ul>
<li>
<p>控制转移语句的回填</p>
<ul>
<li>
<p><strong>示例</strong></p>
<ul>
<li>
<p>S → <strong>if</strong> ( B ) S | <strong>if</strong> ( B ) S <strong>else</strong> S | <strong>while</strong> ( B ) S | { L } | A</p>
</li>
<li>
<p>L → L S | S</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/image-20231116100537125.png" alt="image-20231116100537125" style="zoom:50%;" />
<ul>
<li>
<p>回填和非回填方法比较( if 和 while )</p>
</li>
<li>
<p>break 和 continue 处理</p>
<ul>
<li>虽然 break、continue 在语法上是一个独立的句子，但是它的代码和外围语句相关</li>
<li>方法：(break语句)
<ul>
<li>跟踪外围循环语句 S</li>
<li>生成一个跳转指令坯</li>
<li>将这个指令坯的索引加入到 S 的 nextlist 中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li><strong>中间代码表示</strong>
<ul>
<li>中间代码表示的作用</li>
<li>三地址代码</li>
</ul>
</li>
<li><strong>数据流语句的翻译</strong>
<ul>
<li>变量声明</li>
<li>基本数据类型的运算与数组访问</li>
<li>类型转换</li>
</ul>
</li>
<li><strong>==控制流语句的翻译==</strong>
<ul>
<li>控制流语句</li>
<li>布尔表达式</li>
<li>回填</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/10/20/CF_4/" rel="prev" title="编译原理4：语法制导">
                  <i class="fa fa-angle-left"></i> 编译原理4：语法制导
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/11/05/DIP_3/" rel="next" title="运动模糊处理">
                  运动模糊处理 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZhangChengWei</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous">



</body>
</html>
