<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","Sidebar Display (only for Muse | Mist), available values":["hide    expand only when click on the sidebar toggle icon."],"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="运行时刻环境是编译程序执行过程中的基础设施,为编译程序提供了内存管理、错误处理、I&#x2F;O操作、硬件支持和并发支持等功能。它在编译程序执行过程中起到了至关重要的作用...">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理6：运行时刻环境">
<meta property="og:url" content="http://example.com/2023/11/10/CF_6/index.html">
<meta property="og:site_name" content="Blog of ZhangCW">
<meta property="og:description" content="运行时刻环境是编译程序执行过程中的基础设施,为编译程序提供了内存管理、错误处理、I&#x2F;O操作、硬件支持和并发支持等功能。它在编译程序执行过程中起到了至关重要的作用...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231116102857716.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231116103057183.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231116104243069.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231116105452726.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231116111117043.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231116105404443.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231116111624981.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231116112125598.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231116114109989.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231116114641982.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231123101458794.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231123103031878.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231123103541290.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231123105242167.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231123112701236.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231123112844938.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231123113852883.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231130102553520.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231204112024404.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231130102743011.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231130103004161.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231130103235740.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231130103853271.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231130104308582.png">
<meta property="og:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231130104749277.png">
<meta property="article:published_time" content="2023-11-10T09:03:07.000Z">
<meta property="article:modified_time" content="2024-02-13T06:31:28.201Z">
<meta property="article:author" content="ZhangChengWei">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/6_%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83/image-20231116102857716.png">


<link rel="canonical" href="http://example.com/2023/11/10/CF_6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/11/10/CF_6/","path":"2023/11/10/CF_6/","title":"编译原理6：运行时刻环境"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>编译原理6：运行时刻环境 | Blog of ZhangCW</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Blog of ZhangCW</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">By ZhangCW</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">运行时刻环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87"><span class="nav-text">存储组织</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%BC%8F%E5%88%86%E9%85%8D"><span class="nav-text">栈式分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BB%E5%8A%A8%E6%A0%91"><span class="nav-text">活动树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95"><span class="nav-text">活动记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E4%BB%A3%E7%A0%81%E5%BA%8F%E5%88%97"><span class="nav-text">调用代码序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E4%B8%AD%E7%9A%84%E5%8F%98%E9%95%BF%E6%95%B0%E6%8D%AE"><span class="nav-text">栈中的变长数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E4%B8%AD%E9%9D%9E%E5%B1%80%E9%83%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-text">栈中非局部数据的访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%B1%80%E9%83%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-text">非局部数据的访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ML%EF%BC%9A%E6%94%AF%E6%8C%81%E5%B5%8C%E5%A5%97%E8%BF%87%E7%A8%8B%E5%A3%B0%E6%98%8E%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="nav-text">ML：支持嵌套过程声明的语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6"><span class="nav-text">嵌套深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E9%93%BE"><span class="nav-text">访问链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E8%A1%A8"><span class="nav-text">显示表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E7%AE%A1%E7%90%86"><span class="nav-text">堆管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4"><span class="nav-text">堆空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-text">存储管理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-text">计算机的存储层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7"><span class="nav-text">程序中的局部性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98"><span class="nav-text">堆空间的碎片问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95"><span class="nav-text">堆空间分配方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-text">使用容器的堆管理方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E5%92%8C%E6%8E%A5%E5%90%88%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4"><span class="nav-text">管理和接合空闲空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%89%8B%E5%B7%A5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-text">处理手工存储管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">垃圾与垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="nav-text">垃圾回收器的设计目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7"><span class="nav-text">可达性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E5%8F%AF%E8%BE%BE%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%88%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">改变可达对象集合的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95"><span class="nav-text">垃圾回收方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text">基于引用计数的垃圾回收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E7%BC%BA%E9%99%B7%E2%80%93%E5%BE%AA%E7%8E%AF%E5%9E%83%E5%9C%BE"><span class="nav-text">基于引用计数的缺陷–循环垃圾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%B7%9F%E8%B8%AA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">基于跟踪的垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E6%89%AB%E5%BC%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">标记-清扫式垃圾回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%8B%B7%E8%B4%9D%E5%BC%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">标记-拷贝式垃圾回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E5%BC%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">标记-整理式垃圾回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="nav-text">垃圾回收算法对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E5%BC%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">分代式垃圾回收</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZhangChengWei</p>
  <div class="site-description" itemprop="description">paper analysis</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/10/CF_6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhangChengWei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of ZhangCW">
      <meta itemprop="description" content="paper analysis">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="编译原理6：运行时刻环境 | Blog of ZhangCW">
      <meta itemprop="description" content="运行时刻环境是编译程序执行过程中的基础设施,为编译程序提供了内存管理、错误处理、I/O操作、硬件支持和并发支持等功能。它在编译程序执行过程中起到了至关重要的作用...">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          编译原理6：运行时刻环境
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-10 17:03:07" itemprop="dateCreated datePublished" datetime="2023-11-10T17:03:07+08:00">2023-11-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-13 14:31:28" itemprop="dateModified" datetime="2024-02-13T14:31:28+08:00">2024-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CF/" itemprop="url" rel="index"><span itemprop="name">CF</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">运行时刻环境是编译程序执行过程中的基础设施,为编译程序提供了内存管理、错误处理、I/O操作、硬件支持和并发支持等功能。它在编译程序执行过程中起到了至关重要的作用...</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1>运行时刻环境</h1>
<h2 id="存储组织">存储组织</h2>
<p><strong>运行时刻环境</strong></p>
<ul>
<li>
<p>为数据分配<strong>安排存储位置</strong></p>
</li>
<li>
<p>确定访问变量时使用的机制</p>
</li>
<li>
<p>过程之间的<strong>连接、参数传递</strong></p>
</li>
<li>
<p>(略)和操作系统、输入输出设备相关的其它接口</p>
</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231116102857716.png" alt="image-20231116102857716" style="zoom: 67%;" />
<ul>
<li>目标程序的代码放置在<strong>代码区</strong></li>
<li>静态区、堆区、栈区分别放置不同类型生命期的<strong>数据</strong>值</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231116103057183.png" alt="image-20231116103057183" style="zoom:50%;" />
<p><strong>章节主题</strong></p>
<ul>
<li>
<p>存储管理：<strong>栈分配、堆管理、垃圾回收</strong></p>
</li>
<li>
<p>对变量、数据的访问</p>
</li>
</ul>
<p><strong>活动记录</strong></p>
<ul>
<li>为了管理过程在<u>一次执行</u>中所需要的信息，使用一个<strong>连续</strong>的存储块，称为活动记录</li>
</ul>
<p><strong>静态分配</strong></p>
<ul>
<li>编译器在<u>编译时刻</u>就可以做出<u>存储分配决定</u>，不需要考虑程序运行时刻的情形</li>
<li>名字在程序被编译时<strong>绑定</strong>到存储单元，不需要运行时的支持</li>
<li>绑定的生存期是程序的整个运行期间</li>
<li><strong>全局常量、全局变量</strong></li>
</ul>
<img src="/images/6_运行时刻环境/image-20231116104243069.png" alt="image-20231116104243069" style="zoom:50%;" />
<p><strong>动态分配</strong></p>
<ul>
<li>
<p><u>栈式存储</u>：和过程的调用/返回同步进行分配和回收，值的生命期与过程生命期相同</p>
</li>
<li>
<p><u>堆存储</u>：数据对象可比创建它的过程调用更长寿</p>
</li>
<li>
<p>手工进行回收</p>
</li>
<li>
<p><strong>垃圾回收机制</strong></p>
</li>
</ul>
<h2 id="栈式分配">栈式分配</h2>
<h3 id="活动树">活动树</h3>
<ul>
<li>
<p>如果过程p调用q，那么q的该次活动必定在p的活动结束之前结束：</p>
<ul>
<li><strong>q正常结束</strong>，p继续</li>
<li><strong>q中止</strong>，p和q同时结束</li>
<li><strong>q因异常结束</strong>，p可能会处理这个异常，此时q结束，p继续(不一定从调用q的点开始)</li>
</ul>
</li>
<li>
<p>过程调用(过程活动)在<strong>时间</strong>上总是<strong>嵌套</strong>的</p>
<ul>
<li>后调用的先返回</li>
<li>用<strong>栈</strong>来分配过程活动所需内存空间</li>
</ul>
</li>
<li>
<p>程序运行的所有过程活动可以用<strong>树</strong>表示</p>
<ul>
<li>
<p>每个<strong>结点</strong>对应于一个<strong>过程活动</strong>(一次函数调用)</p>
</li>
<li>
<p><strong>根结点</strong>对应于<strong>main</strong>过程的活动</p>
</li>
<li>
<p>过程p的某次活动对应的结点的所有子结点</p>
<ul>
<li>
<p>表示此次活动所调用的各个过程活动</p>
</li>
<li>
<p><strong>从左向右</strong>，表示调用的<strong>先后顺序</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>例：快速排序程序</p>
<ul>
<li>过程调用(返回)序列和活动树的前序(后序)遍历对应</li>
<li>假定当前活动对应结点N，那么所有尚未结束的活动对应于N及其祖先结点</li>
<li>同层次，先左后右；不同层次，先上后下，嵌套</li>
</ul>
</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231116105452726.png" alt="image-20231116105452726" style="zoom:50%;" />
<img src="/images/6_运行时刻环境/image-20231116111117043.png" alt="image-20231116111117043" style="zoom: 67%;" />
<img src="/images/6_运行时刻环境/image-20231116105404443.png" alt="image-20231116105404443" style="zoom:50%;" />
<h3 id="活动记录">活动记录</h3>
<ul>
<li>过程调用和返回由<strong>控制栈</strong>进行管理</li>
<li>每个<strong>活跃的</strong>活动对应于栈中的一个活动记录</li>
<li>活动记录按活动的开始时间，<strong>从栈底到栈顶排列</strong></li>
</ul>
<img src="/images/6_运行时刻环境/image-20231116111624981.png" alt="image-20231116111624981" style="zoom:50%;" />
<ul>
<li>运行时刻栈的例子
<ul>
<li>a[11] 为全局变量</li>
<li>main 无局部变量</li>
<li>r 有局部变量 i</li>
<li>q 有局部变量 i，和参数 m, n</li>
</ul>
</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231116112125598.png" alt="image-20231116112125598" style="zoom:50%;" />
<ul>
<li>
<p>布局原则</p>
<ul>
<li>
<p>调用者和被调用者之间传递的值放在被调用者活动记录的开始位置</p>
</li>
<li>
<p>固定长度的项(控制链、访问链和机器状态字段)放在中间位置</p>
</li>
<li>
<p>早期不知道大小的项在活动记录尾部</p>
</li>
<li>
<p><strong>栈顶指针(top_sp)<strong>通常指向</strong>固定长度字段的末端</strong>(指向数据部分，即局部数据之上)</p>
</li>
</ul>
</li>
</ul>
<h3 id="调用代码序列">调用代码序列</h3>
<ul>
<li>
<p><strong>调用代码序列</strong></p>
<ul>
<li>
<p>为活动记录<strong>分配空间</strong>，填写记录中的信息</p>
<ul>
<li>调用代码序列会<strong>分割</strong>到调用者和被调用者中</li>
<li>根据源语言、目标机器和操作系统的限制，可以有不同的分割方案</li>
<li>把代码尽可能放在<strong>被调用者</strong>中（面对可能的多次调用）</li>
</ul>
</li>
<li>
<p>==具体过程==</p>
<ul>
<li><strong>调用者</strong>计算实在参数的值</li>
<li><strong>调用者</strong>将<u>返回地址和原top_sp存放到被调用者的活动记录</u>中；调用者<u>增加top_sp的值</u>（越过了调用者的局部数据和临时变量、以及被调用者的参数和机器状态字段）</li>
<li><strong>被调用者</strong>保存寄存器值和其他状态字段（刚进入被调用者时，寄存器值不变）</li>
<li><strong>被调用者</strong>初始化局部数据并开始执行</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>返回代码序列</strong></p>
</li>
<li>
<p>恢复调用者状态，使调用者继续运行</p>
<ul>
<li>==具体过程==
<ul>
<li>
<p><strong>被调用者</strong>将返回值放到与参数相邻的位置</p>
</li>
<li>
<p><strong>被调用者</strong>恢复top_sp和寄存器，跳转到返回地址</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231116114109989.png" alt="image-20231116114109989" style="zoom:50%;" />
<ul>
<li>要求
<ul>
<li>
<p>数据方面</p>
<ul>
<li>
<p>能够把<strong>参数</strong>正确地传递给被调用者</p>
</li>
<li>
<p>能够把<strong>返回值</strong>传递给调用者</p>
</li>
</ul>
</li>
<li>
<p>控制方面</p>
<ul>
<li>
<p>能够正确转到<strong>被调用</strong>过程的代码<strong>开始位置</strong></p>
</li>
<li>
<p>能够正确转回<strong>调用者</strong>的<strong>调用位置</strong>(的下一条指令)</p>
</li>
</ul>
</li>
<li>
<p>调用代码序列与<strong>活动记录的布局</strong>相关</p>
</li>
</ul>
</li>
</ul>
<h3 id="栈中的变长数据">栈中的变长数据</h3>
<ul>
<li>
<p>如果<strong>数据对象的生命期</strong>局限于<strong>过程活动的生命期(</strong> 变长数组也可以)，就可以分配在<strong>运行时刻栈</strong>中</p>
<ul>
<li>
<p>top指向<strong>实际栈顶</strong></p>
</li>
<li>
<p>top_sp用于寻找顶层记录的<strong>定长</strong>字段</p>
</li>
</ul>
</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231116114641982.png" alt="image-20231116114641982" style="zoom:50%;" />
<h2 id="栈中非局部数据的访问">栈中非局部数据的访问</h2>
<h3 id="非局部数据的访问">非局部数据的访问</h3>
<ul>
<li>
<p><strong>无嵌套过程</strong></p>
<ul>
<li>C语言中，每个函数能访问的变量
<ul>
<li><strong>函数的局部变量</strong>：相对地址已知，且存放在当前活动记录内，top_sp指针加上相对地址即可访问</li>
<li><strong>全局变量</strong>：在静态区，地址在编译时刻可知</li>
</ul>
</li>
<li>很容易将C语言的函数作为参数进行传递
<ul>
<li>参数中只需包括函数代码的开始地址</li>
<li>在函数中访问非局部变量的模式很简单，不需要考虑过程是如何激活的</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>有嵌套过程</strong></p>
<ul>
<li>
<p>PASCAL中，若过程A的声明中包含过程B的声明，那么B可以使用在A中声明的变量</p>
</li>
<li>
<p>当B的代码运行时，如果它使用的是A中的变量，必须通过<strong>访问链</strong>访问</p>
<ul>
<li>可以通过top_sp指针直接访问吗？
<ul>
<li>不可以。A函数调用B函数，B的活动记录中可以拿到上一层A的top_sp指针，因此可以通过top_sp指针直接访问；但若A调用C且C调又用B，那么B的活动记录中只能拿到C的top_sp指针，而拿不到A的，就会出错。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231123101458794.png" alt="image-20231123101458794" style="zoom:50%;" />
<h3 id="ML：支持嵌套过程声明的语言">ML：支持嵌套过程声明的语言</h3>
<ul>
<li>定义变量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val &lt;name&gt; = &lt;expression&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;name&gt; (&lt;arguments&gt;) = &lt;body&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用下列形式的let语句来定义函数体：
<ul>
<li><strong>每个definition的作用域</strong>：该定义之后直到in为止的所有定义，以及直到end为止的所有语句</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &lt;list of definitions&gt; in &lt;statements&gt; end</span><br></pre></td></tr></table></figure>
<ul>
<li>函数可以嵌套定义
<ul>
<li>let语句里可以包含另一个函数的定义</li>
</ul>
</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231123103031878.png" alt="image-20231123103031878" style="zoom: 50%;" />
<h3 id="嵌套深度">嵌套深度</h3>
<ul>
<li>嵌套深度可根据源程序<strong>静态</strong>确定
<ul>
<li>不内嵌于任何其它过程的过程，深度为1</li>
<li>嵌套于深度为 i 的过程的过程深度为 i + 1</li>
</ul>
</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231123103541290.png" alt="image-20231123103541290" style="zoom: 50%;" />
<h3 id="访问链">访问链</h3>
<ul>
<li>
<p>访问链被用于访问<strong>非局部</strong>的数据</p>
<ul>
<li>如果过程 p 在声明时(直接)嵌套在过程 q 中，那么 p 活动记录中的<strong>访问链</strong>指向<strong>上层最近</strong>的 q 的活动记录</li>
</ul>
</li>
<li>
<p>从栈顶活动记录开始，访问链形成了一个链路，<strong>嵌套深度</strong>沿着链路<strong>逐一递减</strong></p>
</li>
<li>
<p>设深度为 n~p~ 的过程 p 访问变量 x，而变量 x 在深度为 n~q~ 的过程 q 中声明</p>
<ul>
<li>n~p~ – n~q~ 在编译时刻已知；</li>
<li>从当前活动记录出发，沿访问链<strong>前进 n~p~ – n~q~ 次</strong>找到活动记录</li>
<li>x 相对于这个活动记录的<strong>偏移量</strong>在编译时刻已知</li>
</ul>
</li>
<li>
<p>访问链的维护</p>
<ul>
<li>当<strong>过程 q 调用过程 p</strong> 时
<ul>
<li><strong>p 的深度大于 q</strong> ：根据作用域规则，p 必然在 q 中直接定义；那么 p 的访问链指向当前活动记录(即 q )。
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo>=</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p.access = q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ccess</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span></li>
<li>例如：sort 调用 quicksort(1,9)</li>
</ul>
</li>
<li><strong>递归调用 p = q</strong>：新活动记录的访问链等于当前记录的访问链(即和前一个q指向同一目标)。
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo>=</mo><mi>q</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">p.access = q.access</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ccess</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ccess</span></span></span></span></li>
<li>例如：quicksort(1, 9) 调用 quicksort(1, 3)</li>
</ul>
</li>
<li><strong>p 的深度小于 q</strong>：必然有过程 r，p 直接在 r 中定义， q 也嵌套在 r 中；p 的访问链指向栈中 r 的活动记录。
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo>=</mo><mi>p</mi><mi mathvariant="normal">.</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">p.access =p.outer</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ccess</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">.</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span></span></span></span></li>
<li>例如：partition 调用 exchange</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231123105242167.png" alt="image-20231123105242167" style="zoom: 67%;" />
<ul>
<li>访问链的维护(过程指针型参数)
<ul>
<li>在传递过程指针参数时，过程型参数中不仅包含过程的代码指针(<strong>开始地址</strong>)，还包括正确的<strong>访问链</strong></li>
</ul>
</li>
</ul>
<h3 id="显示表">显示表</h3>
<ul>
<li>用访问链访问数据，访问开销和<strong>嵌套深度差</strong>有关
<ul>
<li>使用显示表可以提高效率，<strong>访问开销为常量</strong></li>
</ul>
</li>
<li><strong>显示表</strong>：数组 d 为<u>每个嵌套深度保留一个指针</u>
<ul>
<li>指针 d[i] 指向栈中<strong>最近的、嵌套深度为 i 的活动记录</strong></li>
<li>如果过程 p 访问嵌套深度为 i 的过程 q 中声明的变量 x ，那么 d[i] 直接指向相应的活动记录( i 在编译时刻已知 )</li>
</ul>
</li>
<li>显示表的维护
<ul>
<li>调用过程 p 时，在 p 的活动记录中保存 d[n~p~] 的值</li>
<li>将 d[n~p~] 设置为当前活动记录( 即 p )</li>
<li>从 p 返回时，恢复 d[n~p~] 的值</li>
</ul>
</li>
</ul>
<h2 id="堆管理">堆管理</h2>
<h3 id="堆空间">堆空间</h3>
<ul>
<li>用于存放<strong>生命周期不确定</strong>、或<strong>生存到被明确删除为止</strong>的数据对象</li>
<li>例如：new生成的对象可以生存到被delete为止，malloc申请的空间生存到被free为止</li>
</ul>
<h3 id="存储管理器">存储管理器</h3>
<ul>
<li>
<p>分配/回收堆区空间的子系统</p>
</li>
<li>
<p>根据语言而定</p>
<ul>
<li>C/C++需要<strong>手动</strong>回收空间</li>
<li>Java可以<strong>自动</strong>回收空间(垃圾收集)</li>
</ul>
</li>
<li>
<p>基本功能</p>
<ul>
<li><strong>分配</strong>：为内存请求分配一段连续、适当大小的堆空间
<ul>
<li>首先从<strong>空闲的堆空间</strong>分配</li>
<li>如果不行则<strong>从操作系统中获取</strong>内存、增加堆空间</li>
</ul>
</li>
<li><strong>回收</strong>：把被回收的空间<strong>返回空闲空间缓冲池</strong>，以满足其它内存需求</li>
</ul>
</li>
<li>
<p>评价存储管理器的特性</p>
<ul>
<li>空间效率：使程序需要的堆空间最小，即<strong>减小碎片</strong></li>
<li>程序效率：运用内存系统的层次，使程序运行更快</li>
<li>低开销：使分配/收回内存的操作尽可能高效</li>
</ul>
</li>
</ul>
<h3 id="计算机的存储层次结构">计算机的存储层次结构</h3>
<img src="/images/6_运行时刻环境/image-20231123112701236.png" alt="image-20231123112701236" style="zoom: 67%;" />
<h3 id="程序中的局部性">程序中的局部性</h3>
<ul>
<li>程序具有<strong>高度的局部性</strong>(Locality)
<ul>
<li><strong>时间</strong>局部性：一个程序访问的存储位置很可能将在一个很短的时间段内被再次访问</li>
<li><strong>空间</strong>局部性：被访问过的存储位置的临近位置很可能在一个很短的时间段内被访问</li>
</ul>
</li>
<li>90%的时间用来执行10%的代码</li>
<li>局部性这一特性恰好可以充分利用计算机的<strong>层次存储结构</strong></li>
</ul>
<h3 id="堆空间的碎片问题">堆空间的碎片问题</h3>
<ul>
<li>随着程序分配/回收内存，堆区逐渐被割裂成若干空闲存储块(窗口)和已用存储块的交错</li>
<li>分配一块内存时，通常是把一个窗口的一部分分配出去，其余部分成为更小的块</li>
<li>回收时，被释放的存储块被放回缓冲池；通常要把连续的窗口接合成为更大的窗口</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231123112844938.png" alt="image-20231123112844938" style="zoom:50%;" />
<h3 id="堆空间分配方法">堆空间分配方法</h3>
<ul>
<li>Best-fit
<ul>
<li>总是将请求的内存分配在满足请求的<strong>最小的窗口</strong>中<br>
(从空闲分区表的第一个表目起查找该表，将最先能够满足要求的空闲区进行分配)</li>
<li>好处：可以将大的窗口保留下来，应对更大的请求</li>
</ul>
</li>
<li>First-fit
<ul>
<li>总是将对象放置在<strong>第一个</strong>能够容纳请求的窗口中<br>
(从全部空闲区中找出能满足作业要求的、且<strong>大小最小</strong>的空闲分区)</li>
<li>放置对象时花费时间较少，但是总体性能比best-fit策略差</li>
<li>通常具有<strong>较好的数据局部性</strong>：同一时间段内生成的对象经常被分配在<strong>连续</strong>的空间内</li>
</ul>
</li>
</ul>
<h3 id="使用容器的堆管理方法">使用容器的堆管理方法</h3>
<ul>
<li>设定不同大小的块规格，<strong>相同的块放入同一容器</strong></li>
<li>较小的(较常用的)尺寸设置较多的容器</li>
<li>如GNU的C编译器将所有存储块对齐到8字节边界
<ul>
<li>空闲块的大小：
<ul>
<li>16, 24, 32, 40 … , 512</li>
<li>大于512的按对数划分：每个容器的尺寸是前一容器的两倍</li>
<li><strong>荒野块</strong>：可以扩展的内存块</li>
</ul>
</li>
</ul>
</li>
<li>分配方法
<ul>
<li>小尺寸的请求，直接在<strong>相应容器</strong>中找</li>
<li>大尺寸的请求，在<strong>适当的容器</strong>中寻找适当的空闲块</li>
<li>可能需要<strong>分割内存块</strong>，可能需要从荒野块中分割</li>
</ul>
</li>
</ul>
<h3 id="管理和接合空闲空间">管理和接合空闲空间</h3>
<ul>
<li>
<p>当回收一个块时，可以把这个块和相邻的块<strong>接合</strong>起来，构成更大的块</p>
<ul>
<li>有些管理方法不需要进行接合</li>
</ul>
</li>
<li>
<p>支持相邻块接合的数据结构</p>
<ul>
<li><strong>边界标记</strong>：在每个存储块的两端，分别设置一个free/used位，并在相邻的位置上存放字节总数</li>
<li><strong>双重链接</strong>的空闲块列表：列表的指针存放在空闲块中、用双向指针的方式记录了有哪些空闲块</li>
</ul>
</li>
<li>
<p>例：</p>
<ul>
<li>相邻的存储块A、B、C
<ul>
<li>当回收B时，通过对free/used位的查询，可知B左边的A是空闲的，而C不空闲</li>
<li>同时还可以知道A、B合并为长度为300的块</li>
<li>修改双重链表，把A替换为A、B接合后的空闲块</li>
</ul>
</li>
<li>注意：双重链表中<strong>一个结点的前驱</strong>并<strong>不一定</strong>是它邻近的块</li>
</ul>
</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231123113852883.png" alt="image-20231123113852883" style="zoom:50%;" />
<h3 id="处理手工存储管理">处理手工存储管理</h3>
<ul>
<li>两大问题
<ul>
<li><strong>内存泄露</strong>(Memory leak)：未能删除不可能再被引用的数据</li>
<li><strong>悬空指针引用</strong>(Dangling pointer)：引用已被删除的数据</li>
</ul>
</li>
<li>其他问题
<ul>
<li>空指针访问/数组越界访问</li>
</ul>
</li>
</ul>
<h2 id="垃圾回收">垃圾回收</h2>
<h3 id="垃圾与垃圾回收">垃圾与垃圾回收</h3>
<ul>
<li>垃圾
<ul>
<li>广义：<strong>不需要</strong>再被引用的数据</li>
<li>狭义：<strong>不能</strong>被引用(不可达)的数据</li>
</ul>
</li>
<li>垃圾回收：自动回收不可达数据的机制，解除了程序员的负担
<ul>
<li>使用的语言：Java、Perl、ML、Modula-3、Prolog、Smalltalk</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收器的设计目标">垃圾回收器的设计目标</h3>
<ul>
<li>基本要求
<ul>
<li>语言必须是<strong>类型安全</strong>的：保证<strong>回收器能够知道</strong>数据元素是否为一个指向某内存块的指针（静态类型ML、动态类型Java）</li>
<li>类型不安全的语言：C/C++ (实践上也有垃圾回收器)</li>
</ul>
</li>
<li>性能目标
<ul>
<li>总体运行时间：不显著增加应用程序的总运行时间</li>
<li>空间使用：最大限度地利用可用内存</li>
<li>停顿时间：当垃圾回收机制启动时，可能引起<strong>应用程序的停顿</strong>，这个停顿应该<strong>比较短</strong>（很少在实时应用中使用）</li>
<li>程序局部性：改善空间局部性和时间局部性</li>
</ul>
</li>
</ul>
<h3 id="可达性">可达性</h3>
<ul>
<li>可达性就是指一个存储块<strong>可以被程序访问到</strong></li>
<li>根集：<strong>不需要指针解引用</strong>就可以<strong>直接访问</strong>的数据
<ul>
<li>Java：静态成员、栈中变量</li>
</ul>
</li>
<li>可达性
<ul>
<li>根集的成员都是可达的</li>
<li>对于任意一个对象，如果指向它的一个指针被保存在<strong>可达对象的某字段或数组元素</strong>中，那么这个对象也是可达的</li>
</ul>
</li>
<li>性质
<ul>
<li>==一旦一个对象变得不可达，它就不会再变成可达的==</li>
</ul>
</li>
</ul>
<h3 id="改变可达对象集合的操作">改变可达对象集合的操作</h3>
<ul>
<li>对象分配
<ul>
<li>返回一个指向新存储块的引用</li>
</ul>
</li>
<li>参数传递和返回值</li>
<li>引用赋值：u = v （u: x / o.f / a[i]）
<ul>
<li>v 的引用被复制到 u 中，<strong>u 中原有引用丢失</strong>；</li>
<li>这 (可能) 使 u 原来指向的对象变得不可达，并递归使更多对象变得不可达</li>
</ul>
</li>
<li>过程返回
<ul>
<li>活动记录出栈，局部变量消失，根集变小，使一些对象变得不可达</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收方法">垃圾回收方法</h3>
<ul>
<li>关注不可达
<ul>
<li>跟踪相关操作，捕获对象<strong>变得不可达的时刻</strong>，<strong>回收</strong>对象占用的空间</li>
</ul>
</li>
<li>关注可达
<ul>
<li>在需要时，标记出所有可达对象，回收其它对象</li>
</ul>
</li>
</ul>
<h3 id="基于引用计数的垃圾回收器">基于引用计数的垃圾回收器</h3>
<ul>
<li>每个<strong>对象</strong>有一个用于存放引用计数的字段，并按如下方式维护：
<ul>
<li>对象分配：引用计数<strong>设</strong>为1</li>
<li>参数传递：引用计数<strong>加</strong>1</li>
<li>引用赋值：u = v，u 指向的对象引用<strong>减</strong>1，v 指向的对象引用<strong>加</strong>1</li>
<li>过程返回：<strong>局部变量</strong>指向对象的<strong>引用计数减1</strong></li>
</ul>
</li>
<li>如果一个对象的引用计数为0，需要==此对象中各个指针<strong>所指对象的引用计数减1</strong>，然后删除该对象==</li>
<li>特点：开销较大，但不会引起停顿</li>
<li>考虑如下操作，则如下左图所示
<ul>
<li>Y = X</li>
<li>Y 是当前函数 f 的局部变量，且 f 返回</li>
</ul>
</li>
</ul>
<p><img src="/images/6_运行时刻环境/image-20231130102553520.png" alt="image-20231130102553520" style="zoom:58%;" /><img src="/images/6_运行时刻环境/image-20231204112024404.png" alt="image-20231204112024404" style="zoom: 58%;" /></p>
<ul>
<li>修改计数后总是考虑是否释放</li>
<li>释放一个对象之前总是先处理对象内部的指针</li>
</ul>
<h3 id="基于引用计数的缺陷–循环垃圾">基于引用计数的缺陷–循环垃圾</h3>
<ul>
<li>三个对象相互引用，没有来自外部的指针，又不是根集成员，都是垃圾，但是引用计数都大于 0</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231130102743011.png" alt="image-20231130102743011" style="zoom:50%;" />
<h3 id="基于跟踪的垃圾回收">基于跟踪的垃圾回收</h3>
<h4 id="标记-清扫式垃圾回收">标记-清扫式垃圾回收</h4>
<ul>
<li>一种直接的、全面停顿的算法</li>
<li>分成两个阶段
<ul>
<li>标记：从<strong>根集</strong>开始，跟踪并标记出所有的<strong>可达</strong>对象</li>
<li>清扫：遍历整个<strong>堆区</strong>，释放<strong>不可达</strong>对象</li>
</ul>
</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231130103004161.png" alt="image-20231130103004161" style="zoom:50%;" />
<ul>
<li>若把<strong>数据对象</strong>看作<strong>结点</strong>、<strong>引用</strong>看作有向<strong>边</strong>，则标记的过程就是<u>从根集开始的<strong>图遍历</strong></u>过程</li>
<li>示例
<ul>
<li>假设X是全局变量，Y是当前函数的局部变量</li>
<li>函数返回后进行标记清扫
<ul>
<li>A, D, E, F, G, H, I可达</li>
<li>B, C不可达</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231130103235740.png" alt="image-20231130103235740" style="zoom: 50%;" />
<ul>
<li>优点
<ul>
<li>实现简单，无需移动对象(修改引用地址)</li>
</ul>
</li>
<li>缺点
<ul>
<li><strong>效率</strong>堪忧，清扫阶段总是需要遍历所有内存</li>
<li>易产生<strong>内存碎片</strong></li>
</ul>
</li>
</ul>
<h4 id="标记-拷贝式垃圾回收">标记-拷贝式垃圾回收</h4>
<ul>
<li>目标
<ul>
<li>只处理<strong>可达对象</strong>(减少回收时间)</li>
<li>将可达对象<strong>安排到一起</strong>(减少内存碎片)</li>
</ul>
</li>
<li>堆空间被分为两个半区
<ul>
<li>应用程序在某个半区内分配存储，当充满这个半区时，开始垃圾回收</li>
<li>回收时，复制可达对象到另一个半区(需修改引用地址)</li>
<li>回收完成后，两个半区角色对调</li>
</ul>
</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231130103853271.png" alt="image-20231130103853271" style="zoom: 50%;" />
<ul>
<li>优点
<ul>
<li>只处理可达对象(减少回收时间)</li>
<li>将可达对象安排到一起(减少内存碎片)</li>
</ul>
</li>
<li>缺点
<ul>
<li>一半预留区域的内存无法使用</li>
</ul>
</li>
</ul>
<h4 id="标记-整理式垃圾回收">标记-整理式垃圾回收</h4>
<ul>
<li>对可达对象进行<strong>重定位</strong>可以消除存储碎片
<ul>
<li>与标记-复制法将对象移动到预留另一半区不同，标记-整理法<strong>把可达对象移动到堆区的一端</strong>，另一端则是空闲空间</li>
<li>空闲空间合并成单一块，提高分配内存时的效率</li>
</ul>
</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231130104308582.png" alt="image-20231130104308582" style="zoom:50%;" />
<ul>
<li>算法的整个过程分成三个步骤：
<ul>
<li>标记(与前述算法相同)</li>
<li>计算新位置</li>
<li>移动并设置新的引用</li>
</ul>
</li>
</ul>
<h4 id="垃圾回收算法对比">垃圾回收算法对比</h4>
<ul>
<li>标记-清扫式垃圾回收
<ul>
<li>回收效率不高，易造成碎片</li>
</ul>
</li>
<li>标记-复制式垃圾回收
<ul>
<li>将可达对象复制到预留半区，只需遍历可达对象</li>
<li>管理区域内<strong>大部分对象为垃圾对象</strong>时效率高(只需移动少量可达对象)，反之则效率低</li>
</ul>
</li>
<li>标记-整理式垃圾回收
<ul>
<li>将可达对象移动到堆区的一端，需遍历整个区域</li>
<li>管理区域内<strong>大部分对象为可达对象</strong>时效率高(经过之前的整理、大部分对象已经到位)，反之则效率低</li>
</ul>
</li>
</ul>
<h3 id="分代式垃圾回收">分代式垃圾回收</h3>
<ul>
<li>对象生存<strong>周期特征</strong>
<ul>
<li>大多数对象刚创建不久后就不再使用(短命)</li>
<li>存在时间越长的对象，通常被回收的几率越小(命硬)</li>
</ul>
</li>
<li>根据生存周期，对对象<strong>分代管理</strong>
<ul>
<li>新创建的对象均放入年轻代区域(从幼年期开始)</li>
<li>年轻代空间不足时，对该区域执行回收(<strong>标记-复制</strong>)</li>
<li>熬过回收的对象<strong>移入下一区域</strong>(进化)</li>
<li>老年代空间不足时，对该区域执行回收(<strong>标记-整理</strong>)</li>
</ul>
</li>
</ul>
<img src="/images/6_运行时刻环境/image-20231130104749277.png" alt="image-20231130104749277" style="zoom: 67%;" />
<h2 id="总结">总结</h2>
<ul>
<li>内存空间布局
<ul>
<li>代码区、静态区、栈区、堆区</li>
</ul>
</li>
<li>栈区内存管理
<ul>
<li>活动记录：函数调用的核心数据结构</li>
<li>进入/返回函数的操作</li>
</ul>
</li>
<li>堆区内存管理
<ul>
<li>手动管理</li>
<li>自动管理(垃圾回收)</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/11/05/DIP_3/" rel="prev" title="数字图像处理3：运动模糊处理">
                  <i class="fa fa-angle-left"></i> 数字图像处理3：运动模糊处理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/11/12/BC_6/" rel="next" title="区块链原理6：挖矿&脚本">
                  区块链原理6：挖矿&脚本 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZhangChengWei</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous">



</body>
</html>
