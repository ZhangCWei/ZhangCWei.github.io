<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhangcwei.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","Sidebar Display (only for Muse | Mist), available values":["hide    expand only when click on the sidebar toggle icon."],"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="目标代码生成是编译的最后一个阶段。目标代码生成器把语法分析后或优化后的中间代码变换成目标代码。目标代码（object code）指计算机科学中编译器或汇编器处理源代码后所生成的代码，它一般由机器代码或接近于机器语言的代码组成。...">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理7：目标代码生成">
<meta property="og:url" content="https://zhangcwei.github.io/2023/12/08/CF_7/index.html">
<meta property="og:site_name" content="Blog of ZhangCW">
<meta property="og:description" content="目标代码生成是编译的最后一个阶段。目标代码生成器把语法分析后或优化后的中间代码变换成目标代码。目标代码（object code）指计算机科学中编译器或汇编器处理源代码后所生成的代码，它一般由机器代码或接近于机器语言的代码组成。...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231130111153837.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231130113029753.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231130113047944.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231130113138835.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231205103155723.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231205103545991.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231205103629411.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231205111727767.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231205112905208.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231205113041503.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231206195417112.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231206200208741.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231206201014728.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231206201241005.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231214101651448.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231214102916870.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231214103157287.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231214104744289.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231214111130736.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231214111648156.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231214111717906.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231214111959149.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231214112009289.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231214112659615.png">
<meta property="og:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231214112855552.png">
<meta property="article:published_time" content="2023-12-08T09:03:07.000Z">
<meta property="article:modified_time" content="2024-10-26T14:35:02.761Z">
<meta property="article:author" content="Chengwei Zhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangcwei.github.io/images/7_%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20231130111153837.png">


<link rel="canonical" href="https://zhangcwei.github.io/2023/12/08/CF_7/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zhangcwei.github.io/2023/12/08/CF_7/","path":"2023/12/08/CF_7/","title":"编译原理7：目标代码生成"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>编译原理7：目标代码生成 | Blog of ZhangCW</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Blog of ZhangCW</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">目标代码生成</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text">代码生成器的位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-text">代码生成器的设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="nav-text">设计目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E6%9C%BA%E6%A8%A1%E5%9E%8B"><span class="nav-text">目标机模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95%E7%9A%84%E6%A0%88%E5%BC%8F%E5%88%86%E9%85%8D"><span class="nav-text">活动记录的栈式分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8D%E5%AD%97%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E5%9C%B0%E5%9D%80"><span class="nav-text">名字的运行时刻地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">算法的基本思想和数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95"><span class="nav-text">代码生成算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%9D%97%E5%92%8C%E6%B5%81%E5%9B%BE"><span class="nav-text">基本块和流图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%9D%97%E4%BC%98%E5%8C%96"><span class="nav-text">基本块优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-text">代码生成器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D%E5%92%8C%E6%8C%87%E6%B4%BE"><span class="nav-text">寄存器分配和指派</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chengwei Zhang"
      src="/images/Chengwei-Zhang.png">
  <p class="site-author-name" itemprop="name">Chengwei Zhang</p>
  <div class="site-description" itemprop="description">An undergraduate student from Sun Yat-sen University, majoring in Software Engineering.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ZhangCWei" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ZhangCWei" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangcwei.github.io/2023/12/08/CF_7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Chengwei-Zhang.png">
      <meta itemprop="name" content="Chengwei Zhang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of ZhangCW">
      <meta itemprop="description" content="An undergraduate student from Sun Yat-sen University, majoring in Software Engineering.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="编译原理7：目标代码生成 | Blog of ZhangCW">
      <meta itemprop="description" content="目标代码生成是编译的最后一个阶段。目标代码生成器把语法分析后或优化后的中间代码变换成目标代码。目标代码（object code）指计算机科学中编译器或汇编器处理源代码后所生成的代码，它一般由机器代码或接近于机器语言的代码组成。...">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          编译原理7：目标代码生成
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-08 17:03:07" itemprop="dateCreated datePublished" datetime="2023-12-08T17:03:07+08:00">2023-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-26 22:35:02" itemprop="dateModified" datetime="2024-10-26T22:35:02+08:00">2024-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CF/" itemprop="url" rel="index"><span itemprop="name">CF</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">目标代码生成是编译的最后一个阶段。目标代码生成器把语法分析后或优化后的中间代码变换成目标代码。目标代码（object code）指计算机科学中编译器或汇编器处理源代码后所生成的代码，它一般由机器代码或接近于机器语言的代码组成。...</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1>目标代码生成</h1>
<h2 id="代码生成器的位置">代码生成器的位置</h2>
<ul>
<li>代码生成器的输入：<strong>中间表示</strong>和<strong>符号表</strong></li>
<li>根据中间表示(IR) 生成代码</li>
<li>代码生成器之前可能有一个<u>优化组件</u></li>
<li>代码生成器的三个任务
<ul>
<li><strong>指令选择</strong>：选择适当的指令实现IR语句</li>
<li><strong>寄存器分配和指派</strong>：把哪个值放在哪个寄存器中</li>
<li>指令排序：按照什么顺序安排指令执行</li>
</ul>
</li>
</ul>
<img src="/images/7_代码生成/image-20231130111153837.png" alt="image-20231130111153837" style="zoom:50%;" />
<h2 id="代码生成器的设计">代码生成器的设计</h2>
<h3 id="设计目标">设计目标</h3>
<ul>
<li>正确性：正确的机器指令</li>
<li>易于实现、测试和维护</li>
<li>输入IR的选择
<ul>
<li>四元式、三元式、字节代码、堆栈机代码、后缀表示、抽象语法树、DAG图、…</li>
</ul>
</li>
<li>输出
<ul>
<li><strong>RISC</strong>、CISC</li>
<li>可重定向代码、<strong>汇编语言</strong></li>
</ul>
</li>
</ul>
<h3 id="目标机模型">目标机模型</h3>
<ul>
<li>
<p>使用三地址机器的模型</p>
</li>
<li>
<p>与三地址码的关键区别：<strong>寄存器</strong></p>
<ul>
<li>位于 CPU 内部，用于存放数据的小型高速存储区域</li>
<li>几乎所有 CPU 计算都需要寄存器参与(存放参数/结果)</li>
<li>几乎所有参与计算的程序数据都位于内存中(使用外存数据也须先读入内存)</li>
<li>机器码需要频繁地<strong>在寄存器与内存之间搬运数据</strong></li>
</ul>
</li>
<li>
<p><strong>指令</strong></p>
<ul>
<li><strong>加载</strong>：LD <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">dst, addr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> (把地址 addr 中的内容加载到 dst 所指的寄存器)</li>
<li><strong>保存</strong>：ST <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">x, r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> (把寄存器 r 中的内容保存到 x 中)</li>
<li><strong>计算</strong>：&lt;OP&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi>s</mi><mi>r</mi><mi>c</mi><mn>1</mn><mo separator="true">,</mo><mi>s</mi><mi>r</mi><mi>c</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">dst, src1, src2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">src</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">src</span><span class="mord">2</span></span></span></span>  (把 src1和 src2中的值运算后将结果存放到 dst 中)</li>
<li><strong>无条件跳转</strong>：BR <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> (控制流转向标号 L 的指令)</li>
<li><strong>条件跳转</strong>：B&lt;cond&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo separator="true">,</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">r, L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span></span></span></span> (对 r 中的值进行测试，如果为真则转向 L；cond代表对寄存器r中的值做某个常见测试，如BLTZ r, L 表示当r &lt; 0时跳转到L )</li>
</ul>
</li>
<li>
<p><strong>寻址模式</strong></p>
<ul>
<li>变量 x：指向分配 x 的内存位置</li>
<li>a®：地址是 a 的左值<strong>加</strong>上寄存器 r 中的值</li>
<li>constant®：寄存器 r 中内容<strong>加</strong>上前面的常数即其地址</li>
<li>*r：寄存器 r 的内容所表示的位置上存放的<strong>内容</strong>位置</li>
<li>*constant®：寄存器中内容加上常量所代表的位置上的内容所表示的位置</li>
<li>常量 #constant</li>
</ul>
</li>
</ul>
<p><img src="/images/7_代码生成/image-20231130113029753.png" alt="image-20231130113029753" style="zoom: 33%;" /><img src="/images/7_代码生成/image-20231130113047944.png" alt="image-20231130113047944" style="zoom: 36%;" /></p>
<img src="/images/7_代码生成/image-20231130113138835.png" alt="image-20231130113138835" style="zoom: 33%;" />
<ul>
<li>
<p>程序及指令的代价</p>
<ul>
<li>不同的目的有不同的度量
<ul>
<li>最短编译时间、运行时间、目标程序大小、能耗</li>
</ul>
</li>
<li>不可判定一个目标程序是否最优</li>
<li>假设每个指令有<strong>固定的代价</strong>，设定为1加上<strong>运算分量寻址模式的代价</strong>
<ul>
<li>LD R0, R1：代价为1</li>
<li>LD R0, M：代价是2</li>
<li>LD R1, *100(R2)：代价为2</li>
</ul>
</li>
</ul>
</li>
<li>
<p>目标代码中的地址</p>
<ul>
<li>如何为过程调用和返回生成代码？
<ul>
<li>静态分配 (活动记录)</li>
<li>栈式分配 (活动记录)</li>
</ul>
</li>
<li>如何将IR中的名字 (过程名或变量名) 转换成为目标代码中的地址？
<ul>
<li>不同区域中的名字采用不同的寻址方式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="活动记录的栈式分配">活动记录的栈式分配</h3>
<ul>
<li>寄存器SP指向栈顶活动记录起始处</li>
<li>第一个过程 (main) 初始化栈区</li>
<li>过程调用指令序列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD SP, SP, <span class="meta">#caller.recordSize 	<span class="comment">// 增大栈指针</span></span></span><br><span class="line">ST <span class="number">0</span>(SP), <span class="meta">#here + 16 			<span class="comment">// 保存返回地址</span></span></span><br><span class="line">BR callee.codeArea 				<span class="comment">// 转移到被调用者</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回指令序列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BR *<span class="number">0</span>(SP) 						<span class="comment">// 被调用者执行，返回调用者</span></span><br><span class="line">SUB SP, SP, <span class="meta">#caller.recordSize 	<span class="comment">// 调用者减小栈指针</span></span></span><br></pre></td></tr></table></figure>
<h3 id="名字的运行时刻地址">名字的运行时刻地址</h3>
<ul>
<li>在三地址语句中使用<strong>名字</strong> (实际上是指向<strong>符号表条目</strong>) 来引用变量</li>
<li>语句 x = 0
<ul>
<li>如果 x 分配在静态区域，且静态区开始位置为static
<ul>
<li>static[12] = 0 LD 112, #0 // static = 100</li>
</ul>
</li>
<li>如果 x 分配在栈区，且相对地址为12，则
<ul>
<li>LD 12(SP), #0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="算法的基本思想和数据结构">算法的基本思想和数据结构</h3>
<ul>
<li>依次考虑各三地址指令，<strong>尽可能把值保留在寄存器中</strong>，减少寄存器/内存之间的数据交换</li>
<li>为一个三地址指令生成机器指令时
<ul>
<li>只有当<strong>运算分量不在寄存器</strong>中时，才从内存载入</li>
<li>尽量保证只有当<strong>寄存器中值不被使用</strong>（称之为<strong>不活跃</strong>）时，才覆盖掉</li>
</ul>
</li>
<li>数据结构（编译期）
<ul>
<li><strong>寄存器描述符</strong>：跟踪各个寄存器都存放了<strong>哪些变量的当前值</strong></li>
<li><strong>地址描述符</strong>：各个<strong>变量的当前值存放在哪些位置</strong>（包括内存位置和寄存器）上</li>
</ul>
</li>
</ul>
<h3 id="代码生成算法">代码生成算法</h3>
<ul>
<li>重要子函数：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>e</mi><mi>t</mi><mi>R</mi><mi>e</mi><mi>g</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">getReg(I)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.00773em;">tR</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span>
<ul>
<li>根据<strong>寄存器描述符</strong>和<strong>地址描述符</strong>等数据流信息，<strong>为三地址指令 I 选择最佳的寄存器</strong></li>
<li>得到的机器指令的质量依赖于 <strong>getReg 函数选取寄存器的算法</strong></li>
</ul>
</li>
<li>代码生成算法逐个处理三地址指令</li>
<li>运算语句：x = y + z
<ul>
<li>getReg(x = y + z) 为 x, y, z 选择寄存器 R<sub>x</sub>, R<sub>y</sub>, R<sub>z</sub></li>
<li>检查 R<sub>y</sub> 的寄存器描述符，如果 y 不在 R<sub>y</sub>中则生成指令
<ul>
<li>LD R<sub>y</sub> , y’ // <strong>y’表示存放 y 值的当前位置</strong></li>
<li>类似地确定是否生成LD R<sub>z</sub> , z’</li>
</ul>
</li>
<li>生成指令 ADD R<sub>x</sub>, R<sub>y</sub> , R<sub>z</sub></li>
</ul>
</li>
<li>赋值语句：x = y
<ul>
<li>getReg(x = y)为 x 和 y 选择<strong>相同的寄存器</strong> (运行后值相同)</li>
<li>如果 y 不在 R<sub>y</sub>中，则生成指令 LD R<sub>y</sub> , y</li>
</ul>
</li>
<li>基本块的收尾
<ul>
<li>如果变量 x <strong>活跃</strong>，且不在内存中，则生成指令 ST x, R<sub>x</sub></li>
</ul>
</li>
<li>代码生成同时<strong>更新寄存器和地址描述符</strong>（记）
<ol>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>D</mi><mtext> </mtext><mi>R</mi><mo separator="true">,</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">LD\ R, x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span></span></span></span>
<ul>
<li>R 的寄存器描述符：<strong>只包含 x</strong></li>
<li>x 地址描述符：R 作为新位置<strong>加入</strong>到 x 的位置集合中</li>
<li>从任何不同于 x 的变量的地址描述符中<strong>删除</strong> R</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>T</mi><mtext> </mtext><mi>x</mi><mo separator="true">,</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">ST\ x, R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">ST</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>
<ul>
<li>x 的地址描述符：包含自己的内存位置 (<strong>新增</strong>)</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>D</mi><mi>D</mi><mtext> </mtext><msub><mi>R</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>R</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>R</mi><mi>z</mi></msub></mrow><annotation encoding="application/x-tex">ADD\ R_x, R_y, R_z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">DD</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
<ul>
<li>R<sub>x</sub> 的寄存器描述符：<strong>只</strong>包含 x</li>
<li>x 的地址描述符：<strong>只</strong>包含 R<sub>x</sub> (不包含 x 的内存位置)(R<sub>x</sub> 是 x 所在的<strong>唯一最新</strong>位置)</li>
<li>从任何不同于 x 的变量的地址描述符中<strong>删除</strong> Rx</li>
</ul>
</li>
<li>处理 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x = y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 时
<ul>
<li>如果生成LD R<sub>y</sub>, y，按照规则1处理</li>
<li>把 x 加入到 R<sub>y</sub> 的寄存器描述符中 (即 R<sub>y</sub> 同时存放了 x 和 y 的当前值)</li>
<li>x 的地址描述符：只包含 R<sub>y</sub> (不包含 x 的内存位置)</li>
</ul>
</li>
</ol>
</li>
<li>示例
<ul>
<li>a、b、c、d在 5) 后仍活跃</li>
<li>t、u、v是局部临时变量</li>
</ul>
</li>
</ul>
<img src="/images/7_代码生成/image-20231205103155723.png" alt="image-20231205103155723" style="zoom:50%;" />
<img src="/images/7_代码生成/image-20231205103545991.png" alt="image-20231205103545991" style="zoom:50%;" />
<img src="/images/7_代码生成/image-20231205103629411.png" alt="image-20231205103629411" style="zoom:50%;" />
<ul>
<li><strong>getReg函数</strong>
<ul>
<li>目标：<strong>减少 LD/ST 指令</strong></li>
<li>任务：为运算<strong>分量</strong>和<strong>结果</strong>分配寄存器</li>
<li>为 x = y op z 的运算分量 y 和 z 分配寄存器
<ul>
<li>如果 y <strong>已经在某个寄存器中</strong>，不需要进行处理，选择这个寄存器作为 R<sub>y</sub></li>
<li>如果 y 不在寄存器中，且<strong>有空闲寄存器</strong>，选择一个空闲寄存器作为 R<sub>y</sub></li>
<li>如果 y <strong>不在寄存器</strong>中，且<strong>没有空闲</strong>寄存器，则：
<ul>
<li>若选择寄存器 R，且已知其寄存器描述符表示某<strong>变量 v 的值在 R 中</strong>，则
<ol>
<li>如果 v 的地址描述符表明可在<strong>别的地方找到 v</strong>，选择 R</li>
<li>v 就是 x (即结果)，且 x 不是运算分量 z，选择 R</li>
<li>如果 v 在此<strong>之后</strong>不会被使用 (不活跃)，选择 R</li>
<li>生成<strong>保存指令</strong> ST v, R (溢出操作) (搬回内存)并<strong>修改 v 的地址描述符</strong>；如果 R 中存放了多个变量的值，那么需要生成多条 ST 指令</li>
</ol>
</li>
</ul>
</li>
<li>为结果 x 选择寄存器 R<sub>x</sub> 的方法，基本上和把 y 从内存 LD 时一样，但是：
<ul>
<li>只存放 x 值的寄存器<strong>总是可接受的</strong></li>
<li>如果 y 在指令之后不再使用，且 R<sub>y</sub> 仅仅保存了 y 的值， 那么 R<sub>y</sub> 同时也可以作为R<sub>x</sub> (对 z 也一样)</li>
</ul>
</li>
<li>处理 x = y 时
<ul>
<li>先选择 R<sub>y</sub></li>
<li>然后让 R<sub>x</sub> = R<sub>y</sub></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如何判断一个变量是否活跃？
<ul>
<li>需要沿着代码<strong>执行路径</strong>向 “前” 看</li>
<li>变量值的使用
<ul>
<li>三地址语句 i 向变量 x <strong>赋值</strong>，若另一个语句 j 的运算分量为 x，且<strong>从 i 开始有一条路径到达 j</strong>，且<strong>路径上没有对 x 赋值</strong>，那么 j 就使用了 i 处计算得到的 x 的值</li>
<li>我们说变量 x 在语句 i 后的程序点上<strong>活跃</strong>
<ul>
<li>程序执行完语句 i 时，x 中存放的值将被后面的语句使用</li>
<li><strong>不活跃</strong>是指变量的<strong>值</strong>不会被使用，而不是变量不会被使用</li>
</ul>
</li>
</ul>
</li>
<li>这些信息可以用于代码生成
<ul>
<li>若 x 在 i 处不活跃，且 x 占用了一个寄存器，我们可把这个寄存器用于其它目的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="基本块和流图">基本块和流图</h2>
<ul>
<li>
<p>基本块</p>
<ul>
<li>对每个过程内的<strong>指令</strong>进行<strong>划分</strong></li>
<li>必然连续执行的指令划入一组，称为基本块
<ul>
<li>控制流只能从基本块的<strong>第一条</strong>指令进入</li>
<li>除基本块的<strong>最后一条指令</strong>外，控制流不会跳转/停机</li>
</ul>
</li>
<li>每个基本块内只有一条执行路径
<ul>
<li>易于分析</li>
</ul>
</li>
</ul>
</li>
<li>
<p>基本块划分的方法</p>
<ul>
<li>输入：<strong>三地址指令</strong>序列</li>
<li>输出：<strong>基本块的列表</strong></li>
<li>方法（“<strong>跳转</strong>”会打断指令的连续执行）
<ul>
<li>确定<strong>首指令leader</strong> (基本块的第一个指令)
<ul>
<li>第一个三地址指令</li>
<li>任意一个(条件或无条件) <strong>转移指令</strong>的<strong>目标</strong>指令</li>
<li><strong>紧跟</strong>在一个(条件或无条件) <strong>转移指令之后</strong>的指令</li>
</ul>
</li>
<li>确定基本块
<ul>
<li>每个首指令对应于一个基本块：从首指令开始到下一个首指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>基本块划分的例子</p>
</li>
</ul>
<img src="/images/7_代码生成/image-20231205111727767.png" alt="image-20231205111727767" style="zoom:50%;" />
<ul>
<li><strong>确定基本块中的活跃性、后续使用</strong>
<ul>
<li>输入：基本块 B，开始时 B 中的所有<strong>非临时变量</strong>都是<strong>活跃</strong>的</li>
<li>输出：各个语句 i 上变量的活跃性、后续使用信息</li>
<li>方法
<ul>
<li>从 B 的最后一个语句开始<strong>反向扫描</strong></li>
<li>对于每个语句 i：x = y + z
<ul>
<li>令语句 i 和 x、y、z 的当前活跃性信息/使用信息关联</li>
<li>设置 <strong>x</strong> 为“<strong>不活跃</strong>”和“<strong>无后续使用</strong>”</li>
<li>设置 y 和 z 为“<strong>活跃</strong>”，并指明它们的<strong>下一次使用设置为语句 i</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>示例</li>
</ul>
<img src="/images/7_代码生成/image-20231205112905208.png" alt="image-20231205112905208" style="zoom:50%;" />
<img src="/images/7_代码生成/image-20231205113041503.png" alt="image-20231205113041503" style="zoom:50%;" />
<h2 id="基本块优化">基本块优化</h2>
<ul>
<li>
<p>针对基本块的优化可以有很好的效果 (局部优化)</p>
</li>
<li>
<p>许多局部优化技术需要先将基本块内的指令转化为<strong>有向无环图</strong> (DAG)</p>
</li>
<li>
<p>DAG可反映变量及其值对其他变量的依赖关系</p>
<ul>
<li>结点表示变量的值</li>
<li>边表示计算值形成的依赖关系</li>
</ul>
</li>
</ul>
<img src="/images/7_代码生成/image-20231206195417112.png" alt="image-20231206195417112" style="zoom:50%;" />
<ul>
<li>构造方法
<ul>
<li>每个变量都有一个对应的DAG结点表示其<strong>初始值</strong></li>
<li>每个语句 s 有一个相关的结点 N，代表此计算得到的值
<ul>
<li>N 的子结点对应于(得到其运算分量当前值的) 其它语句</li>
<li>N的<strong>标号</strong>是 s 中的<strong>运算符</strong>，同时还有一组变量被关联到 N，表示 s 是最新对这些变量进行定值的语句</li>
</ul>
</li>
<li>为基本块中出现的每个变量建立结点 (表示初始值)，各变量和相应结点关联</li>
<li>顺序扫描各三地址指令，进行如下处理
<ul>
<li>指令 x = y op z
<ul>
<li>为该指令建立结点 N，标号为 op，令 x 和 N 关联</li>
<li>N 的子结点为 y、z 当前关联的结点</li>
</ul>
</li>
<li>指令 x = y
<ul>
<li>假设 y 关联到 N，那么x现在也关联到 N</li>
</ul>
</li>
</ul>
</li>
<li>扫描结束后，对所有在<strong>出口处活跃</strong>的变量 x，将 x 所<strong>关联的结点</strong>设置为<strong>输出结点</strong></li>
</ul>
</li>
</ul>
<img src="/images/7_代码生成/image-20231206200208741.png" alt="image-20231206200208741" style="zoom: 40%;" />
<ul>
<li>
<p>DAG的作用</p>
<ul>
<li>DAG图描述了基本块运行时<strong>各变量的值</strong> (和初始值) 之间的关系</li>
<li>以DAG为基础，对代码进行转换
<ul>
<li>寻找<strong>局部公共子表达式</strong></li>
<li>消除死代码</li>
<li>代数恒等式的使用</li>
<li>数组引用的表示</li>
<li>指针赋值和过程调用</li>
</ul>
</li>
</ul>
</li>
<li>
<p>局部公共子表达式的发现</p>
<ul>
<li>建立某个结点 M 之前，检查是否存在一个结点 N，它和 M 具有<strong>相同的运算符</strong>和<strong>子结点</strong> (<strong>顺序也相同</strong>)</li>
<li>如果存在，则不需要生成新的结点，用 N 代表 M
<ul>
<li>如下图1，b = a - d 和 d = a - d 是公共子表达式</li>
<li>如下图2，没有公共子表达式</li>
<li>如下图3，没有公共子表达式（可能出现 i = j 的情况）</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/7_代码生成/image-20231206201014728.png" alt="image-20231206201014728" style="zoom:50%;" />
<img src="/images/7_代码生成/image-20231206201241005.png" alt="image-20231206201241005" style="zoom:45%;" />
<img src="/images/7_代码生成/image-20231214101651448.png" alt="image-20231214101651448" style="zoom: 50%;" />
<ul>
<li>消除死代码
<ul>
<li>在DAG图上消除<strong>没有附加活跃变量</strong>的<strong>根结点</strong>，即消除死代码</li>
<li><strong>如果</strong>上图2中 c、e 不是活跃变量 (但 a、b 是)，则可以先删除标号为 e 的结点，再删除标号为 c 的结点</li>
</ul>
</li>
<li>基于代数恒等式的优化
<ul>
<li>消除计算步骤
<ul>
<li>x + 0 = 0 + x = x</li>
<li>x – 0 = x</li>
<li>x * 1 = 1 * x = x</li>
<li>x / 1 = x</li>
</ul>
</li>
<li>强度消减
<ul>
<li>x^2^ = x * x</li>
<li>2*x = x + x</li>
<li>x/2 = x * 0.5</li>
</ul>
</li>
<li>常量合并
<ul>
<li>如：2 * 3.14可以用 6.28 替换</li>
<li>如何确保编译替换结果与运行结果一致？
<ul>
<li>进行编译，在目标机上执行目标代码，然后吧表达式替换为执行结果</li>
</ul>
</li>
</ul>
</li>
<li>实现这些优化，只需在DAG图上寻找特定的<strong>模式</strong></li>
</ul>
</li>
<li><strong>数组引用</strong>
<ul>
<li>a[j] 可能改变 a[i] 的值 (别名)，因此不能像普通运算符一样构造结点</li>
<li><strong>从数组取值</strong>的运算 x = a[i] 对应于 <strong>=[]</strong> 的结点
<ul>
<li>这个结点的<strong>左右子节点</strong>是<strong>数组初始值 a<sub>0</sub></strong> 和<strong>下标 i</strong></li>
<li>变量 x 是这个结点的标号之一</li>
</ul>
</li>
<li><strong>对数组赋值</strong>的运算 a[j] = y 对应于 <strong>[]=</strong> 的结点
<ul>
<li>这个结点的三个子节点分别表示 <strong>a<sub>0</sub>、j 和 y</strong></li>
<li>杀死所有<strong>依赖于 a<sub>0</sub></strong> 的结点</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/7_代码生成/image-20231214102916870.png" alt="image-20231214102916870" style="zoom:50%;" />
<ul>
<li>数组引用示例
<ul>
<li>设 a 是数组，b 是指针
<ul>
<li>b = 12 + a</li>
<li>x = b[i]</li>
<li>b[j] = y</li>
</ul>
</li>
<li>一个结点被杀死，意味着它不能被复用
<ul>
<li>考虑再有指令m = b[i]</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/7_代码生成/image-20231214103157287.png" alt="image-20231214103157287" style="zoom:50%;" />
<ul>
<li><strong>指针赋值/过程调用</strong>
<ul>
<li>通过指针进行取值/赋值：x = *p、*q = y
<ul>
<li>x 使用了任意变量( p 不知道指向何处 )，因此程序中<strong>所有的死代码都无法消除</strong></li>
<li>*q = y 对任意变量赋值，因此<strong>杀死了全部其他结点</strong></li>
</ul>
</li>
<li>可通过 <strong>(全局/局部) 指针分析</strong>部分地解决这个问题 (部分可解)
<ul>
<li>p = &amp;x</li>
<li>*p = y</li>
</ul>
</li>
<li>过程调用也类似，必须安全地假设它：
<ul>
<li><strong>使用</strong>了可访问范围内的所有变量</li>
<li><strong>修改</strong>了可访问范围内的所有变量</li>
</ul>
</li>
</ul>
</li>
<li>从DAG到基本块（基本块→ DAG → DAG优化 → 重构的基本块）
<ul>
<li><strong>重构</strong>的方法
<ul>
<li>每个结点构造一个三地址语句，计算对应的值</li>
<li>结果应该<strong>尽量赋给一个活跃的变量</strong></li>
<li>如果结点有多个关联的变量，则需要用<strong>赋值语句</strong>进行赋值</li>
</ul>
</li>
<li>根据DAG构造时结点产生的顺序
<ul>
<li>a = b + c</li>
<li>b = a – d</li>
<li>d = b</li>
<li>c = b + c</li>
</ul>
</li>
<li>如果<strong>b在出口处不活跃</strong>，更优的方法为：
<ul>
<li>a = b + c</li>
<li>d = a – d</li>
<li>c = d + c</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/7_代码生成/image-20231214104744289.png" alt="image-20231214104744289" style="zoom:50%;" />
<ul>
<li>
<p>重组的规则</p>
<ul>
<li>注意求值顺序
<ul>
<li>指令顺序必须遵守DAG中结点的顺序</li>
<li>对数组<strong>赋值</strong> (write) 要跟在原来之前的<strong>赋值/求值</strong>之后</li>
<li>对数组<strong>求值</strong> (read) 要跟在原来之前的<strong>赋值</strong>指令之后</li>
<li>对<strong>变量的使用</strong>必须跟在所有原来在它之前的<strong>过程调用</strong>和<strong>指针间接赋值</strong>之后</li>
<li>任何过程调用或指针间接赋值必须跟在原来在它之前的变量求值之后</li>
</ul>
</li>
<li>即保证：
<ul>
<li>如果两个指令之间相互影响，它们的顺序就不该改变</li>
</ul>
</li>
</ul>
</li>
<li>
<p>窥孔优化</p>
<ul>
<li>
<p>使用一个滑动窗口 (窥孔) 来检查目标指令，在窥孔内实现优化</p>
<ul>
<li>
<p><strong>冗余指令消除</strong></p>
<ul>
<li>
<p>多余的LD/ST指令</p>
<ul>
<li>LD R<sub>0</sub>, a</li>
<li>ST a, R<sub>0</sub></li>
<li>如果ST a, R<sub>0</sub> 是非跳转目标，可删除</li>
</ul>
</li>
<li>
<p>级联跳转代码</p>
<ul>
<li>
<p>if debug == 1 goto L1; goto L2; L1: …; L2: …;</p>
<p>• =&gt; if debug != 1 goto L2; L1: …; L2: …;</p>
</li>
<li>
<p>如果已知debug一定是0，那么可替换下面的写法</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>控制流优化</strong></p>
<ul>
<li>
<p>goto L1; … …; L1: goto L2</p>
<p>• =&gt; goto L2; … …; L1: goto L2</p>
</li>
<li>
<p>if <strong>a &lt; b</strong> goto L1; … … ; L1: goto L2</p>
<p>• =&gt; if <strong>a &lt; b</strong> goto <strong>L2</strong>; … … ; L1: goto L2</p>
</li>
</ul>
</li>
<li>
<p><strong>代数化简/强度消减</strong></p>
<ul>
<li>应用代数恒等式进行优化
<ul>
<li>消除 x = x + 0, x = x * 1, …</li>
<li>用 x * x 替换 x2</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>机器特有指令的使用</strong></p>
<ul>
<li><strong>INC</strong>, DEC, …</li>
</ul>
</li>
</ul>
</li>
<li>
<p>滑动窗口 (窥孔) 并无准确定义，可理解为只需关注<strong>少量相关指令</strong>即可完成的优化</p>
</li>
</ul>
</li>
<li>
<p>树重写实现指令选择</p>
<ul>
<li>在某些机器上，同一个三地址指令可以使用<strong>多种机器指令实现</strong>，有时<strong>多个三地址指令</strong>可以使用一个机器指令实现</li>
<li>指令选择
<ul>
<li>需求：为实现中间表示形式中出现的运算符选择适当的机器指令</li>
<li>思路：用<strong>树</strong>来表示<strong>中间代码</strong>，按照特定的规则不断<strong>覆盖</strong>这棵树并生成机器指令</li>
</ul>
</li>
<li>示例
<ul>
<li>a[i] = b + 1
<ul>
<li>ind：把参数作为内存地址</li>
<li>a, i：<strong>局部</strong>变量（C<sub>a</sub> 和 C<sub>i</sub> 存放的是<strong>偏移</strong>）</li>
<li>b：<strong>全局</strong>变量</li>
<li>SP：栈顶指针</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/7_代码生成/image-20231214111130736.png" alt="image-20231214111130736" style="zoom:50%;" />
<ul>
<li>目标指令选择
<ul>
<li>通过应用一个<strong>树重写规则</strong>序列来生成</li>
<li>重写规则形式（大树优先：6优于5）</li>
<li>
<img src="/images/7_代码生成/image-20231214111648156.png" alt="image-20231214111648156" style="zoom:50%; float:left" />
</li>
<li>一组树重写规则被称为一个树翻译方案</li>
<li>树重写规则示例</li>
</ul>
</li>
</ul>
<img src="/images/7_代码生成/image-20231214111717906.png" alt="image-20231214111717906" style="zoom:50%;" />
<img src="/images/7_代码生成/image-20231214111959149.png" alt="image-20231214111959149" style="zoom:50%;" />
<img src="/images/7_代码生成/image-20231214112009289.png" alt="image-20231214112009289" style="zoom:50%;" />
<ul>
<li>覆盖重写过程</li>
</ul>
<img src="/images/7_代码生成/image-20231214112659615.png" alt="image-20231214112659615" style="zoom:50%;" />
<ul>
<li>树翻译方案的工作模式
<ul>
<li>给定一颗输入树，树重写规则中的<strong>模板</strong>被用来匹配输入树的<strong>子树</strong></li>
<li>如果找到一个匹配的模板，那么输入树中匹配的子树将被替换为相应规则中的<strong>替换结点</strong>，并执行相应的<strong>动作</strong>，这可能是生成相应的机器指令序列</li>
<li>不断匹配，直到这颗树被规约成<strong>单个结点</strong>，或找不到匹配的模板为止</li>
<li>在此过程中生成的机器指令代码序列就是树翻译方案作用于给定输入树得到的输出</li>
</ul>
</li>
<li>树翻译方案生成目标指令示例
<ul>
<li>如何完成树匹配？
<ul>
<li>把树重写规则替换成相应的上下文无关文法的产生式</li>
<li>产生式的右部是其指令模板的<strong>前缀表示</strong></li>
</ul>
</li>
<li>如果在某个时刻有多个模板可以匹配
<ul>
<li>匹配到<strong>大树优先</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/7_代码生成/image-20231214112855552.png" alt="image-20231214112855552" style="zoom: 67%;" />
<h2 id="代码生成器">代码生成器</h2>
<ul>
<li>根据三地址指令序列生成机器指令
<ul>
<li>假设每个三地址指令只有一个对应的机器指令</li>
<li>有一组寄存器用于计算基本块内部的值</li>
</ul>
</li>
<li>主要的目标是<strong>减少加载 (LD) 和保存 (ST) 指令</strong>，即<strong>最大限度地利用寄存器</strong></li>
<li>寄存器的使用方法
<ul>
<li>执行运算时，运算分量必须放在寄存器中</li>
<li>存放临时变量</li>
<li>存放全局的值</li>
<li>进行运行时刻管理 (比如栈顶指针)</li>
</ul>
</li>
</ul>
<h2 id="寄存器分配和指派">寄存器分配和指派</h2>
<ul>
<li><strong>寄存器分配</strong>
<ul>
<li>确定在程序的每个点上，<strong>哪个值</strong>应该存放在寄存器中</li>
</ul>
</li>
<li><strong>寄存器指派</strong>
<ul>
<li>各个值应该存放在<strong>哪个寄存器</strong>中</li>
</ul>
</li>
<li>简单方法：把特定类型的值分配给特定的寄存器
<ul>
<li>数组基地址指派给一组寄存器，算术计算分配给一组寄存器，栈顶指针分配一个寄存器，循环，……</li>
<li>缺点：寄存器的使用<strong>效率较低</strong></li>
</ul>
</li>
<li>全局寄存器分配
<ul>
<li>在循环中频繁使用的值存放在固定寄存器
<ul>
<li>分配固定多个寄存器来存放<strong>内部循环</strong>中<strong>最活跃</strong>的值</li>
</ul>
</li>
<li>可以通过使用<strong>计数</strong>的方法来<strong>估算</strong>把一个变量放到寄存器中会带来多大好处，然后根据这个估算来分配寄存器</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/12/05/DIP_4/" rel="prev" title="数字图像处理4：文献研读">
                  <i class="fa fa-angle-left"></i> 数字图像处理4：文献研读
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/12/08/BC_9/" rel="next" title="区块链原理9：以太坊概述">
                  区块链原理9：以太坊概述 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Chengwei Zhang</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous">



</body>
</html>
