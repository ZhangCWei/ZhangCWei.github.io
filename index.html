<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","Sidebar Display (only for Muse | Mist), available values":["hide    expand only when click on the sidebar toggle icon."],"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="paper analysis">
<meta property="og:type" content="website">
<meta property="og:title" content="Methods for DIP">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Methods for DIP">
<meta property="og:description" content="paper analysis">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZhangChengWei">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Methods for DIP</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Methods for DIP</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">By ZhangCW & WeiGP & JiangT</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZhangChengWei</p>
  <div class="site-description" itemprop="description">paper analysis</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/12/CF_8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhangChengWei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Methods for DIP">
      <meta itemprop="description" content="paper analysis">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Methods for DIP">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/12/CF_8/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-12 17:28:06" itemprop="dateCreated datePublished" datetime="2024-02-12T17:28:06+08:00">2024-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-30 22:26:53" itemprop="dateModified" datetime="2023-12-30T22:26:53+08:00">2023-12-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>机器无关的优化</h1>
<p><strong>引言</strong></p>
<ul>
<li>代码优化或者代码改进
<ul>
<li>在目标代码中消除<strong>不必要</strong>的指令</li>
<li>把一个指令序列替换为一个完成相同功能的<strong>更快</strong>的指令序列</li>
</ul>
</li>
<li><strong>全局</strong>优化
<ul>
<li>具体的优化实现基于<strong>数据流分析技术</strong></li>
<li>用以收集程序相关信息的算法</li>
</ul>
</li>
</ul>
<h2 id="优化的来源">优化的来源</h2>
<ul>
<li>优化的主要来源
<ul>
<li>编译器只能通过一些相对低层的语义等价转换来优化代码</li>
<li>冗余运算的原因
<ul>
<li>源程序中的冗余</li>
<li>高级程序设计语言编程的副产品，如A[i][j].f = 0; A[i][j].k = 1;</li>
</ul>
</li>
<li>语义不变的优化
<ul>
<li>公共子表达式消除</li>
<li>复制传播</li>
<li>死代码消除</li>
<li>常量折叠</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\8_机器无关的优化\image-20231214113949719.png" alt="image-20231214113949719" style="zoom:50%;" />
<img src="D:\Typora_picture\8_机器无关的优化\image-20231214114001547.png" alt="image-20231214114001547" style="zoom:50%;" />
<ul>
<li>控制流图
<ul>
<li>表示程序控制流的有向图 (简称流图)</li>
<li>流图的结点是基本块</li>
<li>流图的边指明了哪些基本块可以跟在一个基本块之后运行
<ul>
<li>若<strong>基本块B~i~最后一条指令</strong>执行后紧跟着执行的指令可能为<strong>基本块B~j~</strong>，则图上有一条边<strong>B~i~→B~j~</strong></li>
</ul>
</li>
<li>图上的路径表示程序执行的路径，可作为优化与分析的基础
<ul>
<li>它给出了程序的<strong>控制流</strong></li>
<li>可以根据流图了解到一个值是否会被使用等信息</li>
</ul>
</li>
</ul>
</li>
<li>流图的构造
<ul>
<li>流图的结点是基本块</li>
<li>存在边 B → C 的情况
<ul>
<li>B的结尾指令是一条跳转到C的开头的条件/无条件语句</li>
<li>C紧跟在B之后，且B的结尾不是无条件跳转语句</li>
<li>我们称B是C的前驱，C是B的后继</li>
</ul>
</li>
<li>入口/出口结点
<ul>
<li>不和任何中间指令对应；<strong>入口</strong>到<strong>第一条指令</strong>有一条边；任何<strong>可能最后执行</strong>的基本块到<strong>出口</strong>有一条边</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\8_机器无关的优化\image-20231214114349059.png" alt="image-20231214114349059" style="zoom:50%;" />
<ul>
<li>
<p><strong>循环</strong></p>
<ul>
<li>程序的大部分运行时间花费在循环上，因此<strong>循环是识别的重点</strong> (优化的目标)</li>
<li>循环的定义
<ul>
<li>循环L是一个<strong>结点集合</strong></li>
<li>存在一个<strong>循环入口</strong> (Loop entry) 结点，是<strong>唯一</strong>的、前驱可以在循环L之外的结点，<strong>到达循环内其余结点的路径必然先经过这个入口结点</strong></li>
<li>循环内其余结点都存在到达<strong>入口结点</strong>的<strong>非空路径</strong>，且路径都在L中</li>
</ul>
</li>
<li>上图中的循环有：
<ul>
<li>{ B~3~ }</li>
<li>{ B~6~ }</li>
<li>{ B~2~, B~3~, B~4~ }</li>
</ul>
</li>
<li>对于{ B~2~, B~3~, B~4~ }  ：
<ul>
<li>B~2~为入口结点</li>
<li>B~1~, B~5~, B~6~不在循环内
<ul>
<li>到达B~1~可不经过B~2~</li>
<li>B~5~, B~6~没有到达B~2~的结点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>全局公共子表达式</strong></p>
<ul>
<li>若 E 在某次出现之前<strong>必然</strong>已被计算过，且 E 的运算<strong>分量</strong>在该次计算之后<strong>没有被改变</strong></li>
<li>那么，E 的本次出现就是一个<strong>公共子表达式</strong></li>
<li>如果上次E值赋给了 x，且 x 值没有被修改过，那么我们<strong>可使用 x</strong>，而无需计算 E</li>
</ul>
</li>
<li>
<p>示例</p>
</li>
</ul>
<img src="D:\Typora_picture\8_机器无关的优化\image-20231229152757580.png" alt="image-20231229152757580" style="zoom:50%;" />
<img src="D:\Typora_picture\8_机器无关的优化\image-20231214145055251.png" alt="image-20231214145055251" style="zoom:67%;" />
<ul>
<li><strong>复制传播</strong>
<ul>
<li>形如 u = v 的复制语句使得语句后面的程序点上，u 的值等于 v 的值
<ul>
<li>如果在某个位置上u一定等于v，那么可以把u替换为v</li>
<li>有时可以彻底消除对u的使用，从而消除对u的赋值语句</li>
</ul>
</li>
<li>右图所示，消除公共子表达式时引入了复制语句
<ul>
<li>d + e 冗余计算，且计算后没有修改过</li>
<li>如果后面尽可能用 t 来替换 c，可能就不需要 c = t 这个语句</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\8_机器无关的优化\image-20231219100926974.png" alt="image-20231219100926974" style="zoom:50%;" />
<ul>
<li>复制传播的示例
<ul>
<li>右图显示了对 B~5~ 进行复制传播处理的情况
<ul>
<li>可能消除所有对 x 的使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\8_机器无关的优化\image-20231219101230860.png" alt="image-20231219101230860" style="zoom:50%;" />
<ul>
<li><strong>死代码消除</strong>
<ul>
<li>如果一个变量在某个程序点上的值可能会在之后被使用，那么这个变量在这个点上活跃的；否则这个变量就是死的，此时对该变量的赋值就是没有用的死代码</li>
<li>死代码多半是因为前面的<strong>优化</strong>而形成的</li>
<li>比如，B5中的 x = t~3~ 就是死代码</li>
<li>消除后得到</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\8_机器无关的优化\image-20231219102339094.png" alt="image-20231219102339094" style="zoom:50%;" />
<ul>
<li><strong>代码移动</strong>
<ul>
<li>循环中的代码会被执行很多次
<ul>
<li>循环不变表达式：循环的同一次运行的不同迭代中， 表达式的值不变</li>
</ul>
</li>
<li>把循环不变表达式移动到循环入口之前计算可以提高效率
<ul>
<li>循环入口：进入循环的跳转都以这个入口为目标</li>
</ul>
</li>
<li>while (i &lt;= limit – 2) …
<ul>
<li>如果循环体不改变 limit 的值，可在循环外计算 limit – 2</li>
<li>t = limit – 2<br>
while (i &lt;= t) …</li>
</ul>
</li>
</ul>
</li>
<li><strong>归纳变量和强度消减</strong>
<ul>
<li>每次对x赋值都使x增加c</li>
<li>把赋值改为增量操作，可消减计算强度</li>
<li>两个归纳变量步调一致，可删除一个</li>
<li>例子
<ul>
<li>循环开始保持 t~4~ = 4 * j</li>
<li>j = j – 1 后面的 t~4~ = 4 * j 每次赋值使 t~4~ 减 4</li>
<li>可替换为 t~4~ = t~4~ – 4</li>
<li>t~2~ 也可同样处理为 t~2~ = t~2~ + 4</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\8_机器无关的优化\image-20231219102854625.png" alt="image-20231219102854625" style="zoom:50%;" />
<h2 id="数据流分析">数据流分析</h2>
<ul>
<li>
<p>数据流分析</p>
<ul>
<li>用于获取<strong>数据沿着程序执行路径流动</strong>信息的相关技术，是优化的基础</li>
<li>例如
<ul>
<li>两个表达式是否一定计算得到相同的值？(<strong>可用表达式</strong>→公共子表达式)</li>
<li>一个语句的计算结果是否可能被后续语句使用？(<strong>活跃变量分析</strong>→死代码消除)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数据流抽象</p>
<ul>
<li>
<p>程序点</p>
<ul>
<li>三地址语句<strong>之前</strong>或<strong>之后</strong>的位置</li>
<li>基本块内部：一个语句之后的程序点等于下一个语句之前的程序点</li>
<li>如果流图中有B1到B2的边，那么B2的第一个语句之前的<strong>点</strong>可能紧跟在B1的最后语句之后的<strong>点</strong>后面执行</li>
</ul>
</li>
<li>
<p>从p~1~到p~n~的<strong>执行路径</strong>：p~1~, p~2~, …, p~n~</p>
<ul>
<li>要么p~i~是一个<strong>语句之前</strong>的点，且p~i+1~是该<strong>语句之后</strong>的点</li>
<li>要么p~i~是某个<strong>基本块的结尾</strong>，且p~i+1~是该<strong>基本块的某个后继的开头</strong></li>
</ul>
</li>
<li>
<p>出现在某个程序点的<strong>程序状态</strong></p>
<ul>
<li>在某运行时刻，当指令指针指向这个程序点时，各个变量和动态内存中存放的<strong>值</strong></li>
<li>指令指针<strong>可能</strong>多次指向同一个程序点，因此一个程序点可能对应<strong>多个</strong>程序状态</li>
</ul>
</li>
<li>
<p>数据流分析把可能出现在<strong>某个程序点上的程序状态集合</strong>总结为一些特性</p>
<ul>
<li>不管程序怎么运行，当它到达某个程序点时，程序状态<strong>总是满足</strong>分析得到的特性</li>
<li>不同的分析技术关心不同的信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\8_机器无关的优化\image-20231219104643641.png" alt="image-20231219104643641" style="zoom:50%;" />
<ul>
<li><strong>性质和算法</strong>
<ul>
<li>根据不同的需要来设置不同的性质集合，然后设计分析算法
<ul>
<li>程序点上的性质被表示成为<strong>数据流值</strong>，求解这些数据流值实际上就是推导这些性质的过程</li>
</ul>
</li>
<li>例子
<ul>
<li>如果要求出变量在某个点上的值可能在哪里定值，可以使用到达定值 (Reaching Definition)
<ul>
<li>性质形式：x 由 d1 定值</li>
</ul>
</li>
<li>如果希望实现常量折叠优化，我们关心的是某个点上变量x的值是否总是由某个常量赋值语句赋予
<ul>
<li>性质形式：x = c，以及x = NAC（Not A Constant）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数据流分析
<ul>
<li>对一组约束求解，得到各个点上的数据流值
<ul>
<li>两类约束：基于<strong>语句语义</strong>和基于<strong>控制流</strong></li>
</ul>
</li>
<li>基于<strong>语句语义</strong>的约束
<ul>
<li>一个语句之前和之后的数据流值受到其语义的约束
<ul>
<li>语句语义通常用转换函数表示，它把一个数据流值<strong>映射</strong>为另一个数据流值
<ul>
<li>OUT[s] = 𝑓~s~(IN[s]) // 正向</li>
<li>IN[s] =𝑓~s~(OUT[s]) // 逆向</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>基于<strong>控制流</strong>的约束
<ul>
<li>在基本块内部，<strong>一个语句的输出 = 下一语句的输入</strong></li>
<li>流图的控制流边也对应新的约束</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\8_机器无关的优化\image-20231219110943736.png" alt="image-20231219110943736" style="zoom:50%;" />
<ul>
<li>基本块内的数据流模式
<ul>
<li>基本块内的控制流非常简单
<ul>
<li>从头到尾不会中断</li>
<li>没有分支</li>
</ul>
</li>
<li>基本块的效果就是各个语句的效果的<strong>复合</strong></li>
<li>可以预先处理基本块内部的数据流关系，给出基本块对应的<strong>转换函数</strong>
<ul>
<li>OUT[B] = 𝑓~B~(IN[B]) 或 IN[B] = 𝑓~B~(OUT[B])</li>
</ul>
</li>
<li>设基本块包含语句𝑠~1~, 𝑠~2~, … , 𝑠~n~
<ul>
<li>𝑓~B~ = 𝑓~sn~ ∘ ⋯ ∘ 𝑓~s2~ ∘ 𝑓~s1~</li>
</ul>
</li>
</ul>
</li>
<li>基本块之间的控制流约束
<ul>
<li><strong>前向数据流问题</strong>
<ul>
<li>B的传递函数根据IN[B]计算得到OUT[B]</li>
<li>IN[B]和B的<strong>各前驱基本块</strong>的OUT值之间具有约束关系</li>
</ul>
</li>
<li>逆向数据流问题
<ul>
<li>B的传递函数根据OUT[B]计算得到IN[B]</li>
<li>OUT[B]和B的<strong>各后继基本块</strong>的IN值之间具有约束关系</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\8_机器无关的优化\image-20231219111359729.png" alt="image-20231219111359729" style="zoom: 50%;" />
<ul>
<li>
<p>数据流方程解的<strong>精确性</strong>和<strong>安全性</strong></p>
<ul>
<li>数据流方程通常没有唯一解</li>
<li>目标是寻找一个最“精确”且满足约束的解
<ul>
<li>精确：能够进行更多的改进</li>
<li>满足约束：根据分析结果来改进代码是<strong>安全</strong>的</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>到达定值</strong></p>
<ul>
<li>假定 x 有定值 d，如果存在一个路径，从<strong>紧随 d 的点到达某点 p</strong>，并且此路径上面<strong>没有 x 的其他定值点</strong>，则称 x 的定值 d 到达 p</li>
<li>如果在这条路径上有对 x 的其它定值，我们说变量 x 的这个定值 d 被<strong>杀死</strong>了</li>
<li>如果某个变量 x 的一个定值 d 到达了点 p，在 p 点使用变量x的时候，x 的值是由 d最后定值的</li>
<li>到达定值的解<strong>允许不精确</strong>，但<strong>必须是安全的</strong>
<ul>
<li>分析得到的到达定值可能实际上不会到达</li>
<li>但是实际到达的一定要被分析出来，否则不安全</li>
</ul>
</li>
<li>比如确定x在p点是否为<strong>常量</strong>
<ul>
<li>忽略实际的到达定值使得变化的值被误认为常量，将这些值替换为常量会引起错误，<strong>不安全</strong></li>
<li><strong>过多</strong>估计则相反</li>
</ul>
</li>
</ul>
</li>
<li>
<p>示例</p>
<ul>
<li>B~1~全部定值到达B~2~的开头</li>
<li>d~5~到达B~2~的开头 (循环)</li>
<li>d~2~被d~5~杀死，不能到达B~3~、B~4~的开头</li>
<li>d~4~不能到达B~2~的开头，因为被d~7~杀死</li>
<li>d~6~到达B~2~的开头</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\8_机器无关的优化\image-20231219112250942.png" alt="image-20231219112250942" style="zoom:50%;" />
<ul>
<li><strong>语句/基本块的转换方程</strong>
<ul>
<li>定值 𝑑: 𝑢 = 𝑣 + 𝑤
<ul>
<li>生成了对变量 𝑢 的定值 𝑑，杀死其它对 𝑢 的定值</li>
<li>生成-杀死（gen-kill）形式：𝑓~𝑑~(𝑥) = 𝑔𝑒𝑛~𝑑~ ∪ (𝑥 – 𝑘𝑖𝑙𝑙~𝑑~)</li>
<li>𝑔𝑒𝑛~𝑑~ = 𝑑 , 𝑘𝑖𝑙𝑙~𝑑~ = { 程序中其它对 𝑢 的定值 }</li>
</ul>
</li>
<li>生成-杀死形式的函数复合仍具有该形式
<ul>
<li><strong>生成的定值</strong>：由第二部分生成、以及由第一部分生成且没有被第二部分杀死</li>
<li><strong>杀死的定值</strong>：被第一部分杀死、以及被第二部分杀死的定值</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>𝑓</mi><mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>𝑥</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>𝑔</mi><mi>𝑒</mi><msub><mi>𝑛</mi><mn>2</mn></msub><mo>∪</mo><mo stretchy="false">(</mo><mi>𝑔</mi><mi>𝑒</mi><msub><mi>𝑛</mi><mn>1</mn></msub><mo>∪</mo><mo stretchy="false">(</mo><mi>𝑥</mi><mo>−</mo><mi>𝑘</mi><mi>𝑖</mi><mi>𝑙</mi><msub><mi>𝑙</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>−</mo><mi>𝑘</mi><mi>𝑖</mi><mi>𝑙</mi><msub><mi>𝑙</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>𝑔</mi><mi>𝑒</mi><msub><mi>𝑛</mi><mn>2</mn></msub><mo>∪</mo><mo stretchy="false">(</mo><mi>𝑔</mi><mi>𝑒</mi><msub><mi>𝑛</mi><mn>1</mn></msub><mo>−</mo><mi>𝑘</mi><mi>𝑖</mi><mi>𝑙</mi><msub><mi>𝑙</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">(</mo><mi>𝑥</mi><mo>−</mo><mi>𝑘</mi><mi>𝑖</mi><mi>𝑙</mi><msub><mi>𝑙</mi><mn>1</mn></msub><mo>∪</mo><mi>𝑘</mi><mi>𝑖</mi><mi>𝑙</mi><msub><mi>𝑙</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align}
𝑓_2(f_1(𝑥)) &amp;= 𝑔𝑒𝑛_2 ∪ (𝑔𝑒𝑛_1 ∪ (𝑥 - 𝑘𝑖𝑙𝑙_1) - 𝑘𝑖𝑙𝑙_2) \\&amp;= (𝑔𝑒𝑛_2 ∪ (𝑔𝑒𝑛_1 - 𝑘𝑖𝑙𝑙_2)) ∪ (𝑥 - 𝑘𝑖𝑙𝑙_1 ∪ 𝑘𝑖𝑙𝑙_2)
\end{align}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">ki</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">ki</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">ki</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">ki</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">ki</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:2.84em;"></span><span class="eqn-num"></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></p>
<ul>
<li>
<ul>
<li>设 B 有n个语句，第 i 个语句的转换函数为𝑓~i~</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝑓</mi><mi>B</mi></msub><mo stretchy="false">(</mo><mi>𝑥</mi><mo stretchy="false">)</mo><mo>=</mo><mi>𝑔</mi><mi>𝑒</mi><msub><mi>𝑛</mi><mi>n</mi></msub><mo>∪</mo><mo stretchy="false">(</mo><mi>𝑥</mi><mtext>–</mtext><mi>𝑘</mi><mi>𝑖</mi><mi>𝑙</mi><msub><mi>𝑙</mi><mi>B</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑓_B(𝑥)=𝑔𝑒𝑛_n∪(𝑥–𝑘𝑖𝑙𝑙_B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">–</span><span class="mord mathnormal">ki</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑔</mi><mi>𝑒</mi><msub><mi>𝑛</mi><mi>B</mi></msub><mo>=</mo><mi>𝑔</mi><mi>𝑒</mi><msub><mi>𝑛</mi><mi>n</mi></msub><mo>∪</mo><mo stretchy="false">(</mo><mi>𝑔</mi><mi>𝑒</mi><msub><mi>𝑛</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mtext>–</mtext><mi>𝑘</mi><mi>𝑖</mi><mi>𝑙</mi><msub><mi>𝑙</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>∪</mo><mo>⋯</mo><mo>∪</mo><mo stretchy="false">(</mo><mi>𝑔</mi><mi>𝑒</mi><msub><mi>𝑛</mi><mn>1</mn></msub><mtext>–</mtext><mi>𝑘</mi><mi>𝑖</mi><mi>𝑙</mi><msub><mi>𝑙</mi><mn>2</mn></msub><mtext>–</mtext><mi>𝑘</mi><mi>𝑖</mi><mi>𝑙</mi><msub><mi>𝑙</mi><mn>3</mn></msub><mtext>–</mtext><mo>…</mo><mo>−</mo><mi>𝑘</mi><mi>𝑖</mi><mi>𝑙</mi><msub><mi>𝑙</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑔𝑒𝑛_B=𝑔𝑒𝑛_n∪(𝑔𝑒𝑛_{n-1}–𝑘𝑖𝑙𝑙_n)∪⋯∪(𝑔𝑒𝑛_1–𝑘𝑖𝑙𝑙_2–𝑘𝑖𝑙𝑙_3–…-𝑘𝑖𝑙𝑙_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord">–</span><span class="mord mathnormal">ki</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">–</span><span class="mord mathnormal">ki</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">–</span><span class="mord mathnormal">ki</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">–</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ki</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑘</mi><mi>𝑖</mi><mi>𝑙</mi><msub><mi>𝑙</mi><mi>B</mi></msub><mo>=</mo><mi>𝑘</mi><mi>𝑖</mi><mi>𝑙</mi><msub><mi>𝑙</mi><mn>1</mn></msub><mo>∪</mo><mi>𝑘</mi><mi>𝑖</mi><mi>𝑙</mi><msub><mi>𝑙</mi><mn>1</mn></msub><mo>∪</mo><mo>⋯</mo><mo>∪</mo><mi>𝑘</mi><mi>𝑖</mi><mi>𝑙</mi><msub><mi>𝑙</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">𝑘𝑖𝑙𝑙_B=𝑘𝑖𝑙𝑙_1∪𝑘𝑖𝑙𝑙_1∪⋯∪𝑘𝑖𝑙𝑙_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">ki</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">ki</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">ki</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">ki</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑔</mi><mi>𝑒</mi><msub><mi>𝑛</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">𝑔𝑒𝑛_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是被第 i 个语句生成，且没有被其后的句子杀死的定值的集合</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑘</mi><mi>𝑖</mi><mi>𝑙</mi><msub><mi>𝑙</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">𝑘𝑖𝑙𝑙_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">ki</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为被 B 各个语句杀死的定值的并集</li>
</ul>
</li>
</ul>
</li>
<li>
<p>活跃变量分析</p>
<ul>
<li>定义
<ul>
<li>x 在 p 上的值是否会在<strong>某条从 p 出发的路径中使用</strong></li>
<li>变量 x 在 p 上<strong>活跃</strong>，<strong>当且仅当</strong>存在<strong>一条</strong>从 p 开始的路径，该路径的<strong>末端</strong>使用了 x，且路径上<strong>没有对 x 进行定值</strong></li>
</ul>
</li>
<li>用途
<ul>
<li>寄存器分配/死代码删除/…</li>
</ul>
</li>
<li>数据流值
<ul>
<li>(活跃) 变量的集合</li>
</ul>
</li>
</ul>
</li>
<li>
<p>可用表达式分析</p>
<ul>
<li>x + y在p点可用的条件
<ul>
<li>从流图入口结点到达p的<strong>每条路径</strong>都对x + y求值，且在最后一次求值之后再没有对x或y赋值</li>
</ul>
</li>
<li>主要用途
<ul>
<li>寻找<strong>全局公共子表达式</strong></li>
</ul>
</li>
<li>生成-杀死
<ul>
<li><strong>生成</strong>：基本块求值x + y，且之后没有对x或y赋值，那么它生成了x + y</li>
<li><strong>杀死</strong>：基本块对x或y赋值，且没有重新计算x + y，那么它杀死了x + y</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="部分冗余消除">部分冗余消除</h2>
<ul>
<li>消除冗余计算
<ul>
<li>目标：尽量减少<strong>表达式求值</strong>的次数</li>
<li>对于表达式x + y
<ul>
<li><strong>全局公共子表达式</strong>：如果对x + y求值前的程序点上x + y可用，那么不需要再对x + y求值</li>
<li><strong>循环不变表达式</strong>：循环中的表达式x + y的值不变，可以只计算一次</li>
<li><strong>部分冗余</strong>：在程序按照某些路径到达这个点的时候x + y已经被计算过，但沿着另外一些路径到达时，x + y尚未计算过</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\8_机器无关的优化\image-20231221100410824.png" alt="image-20231221100410824" style="zoom:50%;" />
<ul>
<li>需要添加基本块来消除的冗余
<ul>
<li>进行两种操作
<ul>
<li>在<strong>关键边</strong>上增加基本块</li>
<li>进行<strong>代码复制</strong></li>
</ul>
</li>
<li>关键边
<ul>
<li>从<strong>具有多个后继的结点</strong>到达<strong>具有多个前驱的结点</strong></li>
<li>如下图1中的 B~3~→B~4~</li>
</ul>
</li>
<li>示例
<ul>
<li>为了优化某条路径，而使另外一条路径计算量增加，这是不允许的</li>
<li>下图2中的情况更为复杂，需要进行对 B~6~ 和与其关联的 B~4~ 进行代码复制</li>
<li>下图2中的优化是没必要的，因为复制了控制流，会大大增加优化后代码的大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\8_机器无关的优化\image-20231221102227180.png" alt="image-20231221102227180" style="zoom:50%;" />
<ul>
<li>懒惰代码移动
<ul>
<li>目标
<ul>
<li>所有不复制代码就可消除的冗余计算都被消除</li>
<li>优化后的代码不会执行原程序中不执行的任何计算</li>
<li>表达式的计算应该<strong>尽量靠后</strong>，以利于寄存器的分配</li>
</ul>
</li>
<li>冗余消除
<ul>
<li>完全冗余</li>
<li>部分冗余：在流图中<strong>放置</strong>表达式x + y的<strong>拷贝</strong>，使得某处的x + y成为完全冗余，从而删除</li>
</ul>
</li>
<li>基本步骤
<ol>
<li>找出各程序点上<strong>预期执行</strong>的所有表达式</li>
<li>在表达式被预期执行但是不可用的程序点上，放置表达式的计算</li>
<li>把表达式尽量<strong>后延</strong>到某个程序点（考虑到寄存器分配），在到达这个点的所有路径上，这个表达式在这个程序点之前被预期执行，但是还没有使用这个值</li>
<li>消除只使用一次的临时变量</li>
</ol>
</li>
<li>被预期执行
<ul>
<li>如果从程序点p出发的<strong>所有路径都会计算</strong>表达式b + c的值，并且b和c在那时的值<strong>就是它们在点p的值</strong>，那么表达式b + c在点p上被预期执行</li>
<li>示例1
<ul>
<li>表达式b + c在B~3~、B~4~、B~5~、 B~6~、B~7~和B~9~的入口处被预期执行</li>
<li>B~2~ 没有预期执行，因为其改变了 c 的值</li>
<li>B~8~ 没有预期执行，因为它不一定会执行 b+c</li>
</ul>
</li>
</ul>
</li>
<li>可用表达式
<ul>
<li>和前面的可用表达式类似，但假设代码已经被<strong>复制到了预期执行点</strong>上</li>
<li>表达式在基本块的<strong>出口处可用</strong>的条件
<ul>
<li>在基本块的入口处可用，或在基本块的入口处的预期执行表达式中</li>
<li>且没有被这个基本块杀死</li>
</ul>
</li>
</ul>
</li>
<li>可后延表达式
<ul>
<li>在保持程序语义的情况下，尽可能延后计算表达式</li>
<li>示例2
<ul>
<li>b + c在B~1~被预期执行</li>
<li>b + c可后延到B~4~→B~7~的边上</li>
</ul>
</li>
</ul>
</li>
<li>
<h2 id="被使用的表达式（跳过）">被使用的表达式（跳过）</h2>
</li>
</ul>
</li>
</ul>
<p><img src="D:\Typora_picture\8_机器无关的优化\image-20231221103124105.png" alt="image-20231221103124105" style="zoom:60%;" /><img src="D:\Typora_picture\8_机器无关的优化\image-20231221103748486.png" alt="image-20231221103748486" style="zoom:80%;float:right" /></p>
<h2 id="循环的识别、分析和优化">循环的识别、分析和优化</h2>
<ul>
<li><strong>支配结点</strong>
<ul>
<li>如果每条<strong>从入口结点到达n的路径都经过d</strong>，那么 d 支配 n，记为𝑑 dom 𝑛</li>
</ul>
</li>
<li>示例：
<ul>
<li>1支配所有结点；</li>
<li>2只支配自己；</li>
<li>3支配除了1、2外的其它结点；</li>
<li>4支配1、2、3外的其它结点；</li>
<li>5、6只支配自身；</li>
<li>7支配7、8、9、10；</li>
<li>8支配8、9、10；</li>
<li>9、10只支配自身</li>
</ul>
</li>
</ul>
<p><img src="D:\Typora_picture\8_机器无关的优化\image-20231221104445588.png" alt="image-20231221104445588" style="zoom: 75%;" /><img src="D:\Typora_picture\8_机器无关的优化\image-20231229155017437.png" alt="image-20231229155017437" style="zoom: 75%;" /></p>
<ul>
<li>支配结点树
<ul>
<li><strong>支配结点树</strong>可以表示支配关系
<ul>
<li><strong>根结点</strong>：入口结点</li>
<li>每个结点d支配且只支配树中的<strong>后代结点</strong></li>
</ul>
</li>
<li><strong>直接支配节点</strong>
<ul>
<li>从入口结点到达n的任何路径 (不含n) 中，它是路径中<strong>最后</strong>一个支配n的结点</li>
<li>前面的例子：1直接支配3，3直接支配4</li>
<li><strong>n的直接支配结点m</strong>具有如下性质：如果𝑑 ≠ 𝑛且𝑑 dom 𝑛，那么𝑑 dom 𝑚</li>
</ul>
</li>
</ul>
</li>
<li>寻找支配节点算法
<ul>
<li>计算流图中各个结点n的所有支配结点
<ul>
<li>𝑝~1~, 𝑝~2~, … , 𝑝~𝑘~是𝑛的所有前驱且𝑑 ≠ 𝑛，那么𝑑 dom 𝑛当且仅当𝑑 dom 𝑝~𝑖~ (1 ≤ 𝑖 ≤ 𝑘)</li>
</ul>
</li>
<li>一个结点的<strong>支配结点集合</strong>是它的<strong>所有前驱的支配结点集合的交集</strong> (加上它<strong>自己</strong>)</li>
<li><strong>前向</strong>数据流分析问题</li>
<li>求解如图所示的数据流方程组，可以得到各结点对应的支配结点集合。其中，IN[B]是在<strong>基本块B入口处</strong>的支配结点集合，OUT[B]是在<strong>基本块B出口处</strong>的支配结点集合。
<ul>
<li>OUT[ENTRY] = {ENTRY}</li>
<li>OUT[B] = IN[B] ∪ {B}                    (B ≠ ENTRY)</li>
<li>IN[B] = ∩ ~P是B的一个前驱~OUT[P]       (B ≠ ENTRY)</li>
</ul>
</li>
<li>D(n) = OUT[n]</li>
<li>示例：
<ul>
<li>注意：
<ul>
<li>N是全节点集合</li>
<li>3的前驱是1、2、4、8</li>
<li>4、7的前驱同理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\8_机器无关的优化\image-20231229155625149.png" alt="image-20231229155625149" style="zoom:50%;" />
<img src="D:\Typora_picture\8_机器无关的优化\image-20231229155706196.png" alt="image-20231229155706196" style="zoom:50%;" />
<ul>
<li>深度优先生成树
<ul>
<li><strong>深度优先搜索</strong> (Depth-First Search / DFS)
<ul>
<li>搜索过程从入口结点开始，并首先访问已知离入口结点<strong>最远</strong>的结点</li>
</ul>
</li>
<li><strong>深度优先生成树</strong>
<ul>
<li>一个深度优先过程中的搜索<strong>路线</strong>形成了一个深度优先生成树 (Depth-First Spanning Tree / DFST)</li>
</ul>
</li>
</ul>
</li>
<li>示例：
<ul>
<li><strong>实线边</strong>形成了这棵树，<strong>虚线边</strong>是流图中其它的边</li>
<li>左边：流图，右边：深度优先生成树</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\8_机器无关的优化\image-20231221105205931.png" alt="image-20231221105205931" style="zoom: 67%;" />
<ul>
<li>流图中边的分类
<ul>
<li>为一个流图构造出<strong>DFST</strong>之后，流图中的边可以分为三类
<ul>
<li>前进边：从结点m到达m在DFST树中的一个真后代结点的边 (DFST中的所有边都是前进边)</li>
<li>后退边：从m到达m在DFST树中的某个祖先 (包括m) 的边</li>
<li>交叉边：边的src和dest都不是对方的祖先</li>
</ul>
</li>
<li>示例，上图2中，10→7是后退边，5→7是交叉边</li>
</ul>
</li>
<li>==<strong>回边与可归约性</strong>==
<ul>
<li>回边的定义
<ul>
<li>边a→b，头b<strong>支配</strong>了尾a（注意不是直接支配）</li>
<li>每条回边都是后退边，但不是所有后退边都是回边</li>
</ul>
</li>
<li>若一个流图的任何深度优先生成树的<strong>所有后退边都是回边</strong>，则该流图就是<strong>可归约</strong>的</li>
</ul>
</li>
<li><strong>自然循环</strong>
<ul>
<li>自然循环的性质
<ul>
<li>有一个<strong>唯一</strong>的入口结点 (循环头Header)，这个结点<strong>支配</strong>循环中的所有结点</li>
<li>必然存在<strong>进入循环头的回边</strong></li>
</ul>
</li>
<li>自然循环的定义
<ul>
<li>给定回边n→<strong>d</strong>的自然循环是d，加上<strong>不经过d就能够到达n的结点的集合</strong></li>
<li>d是这个循环的头</li>
</ul>
</li>
<li>示例
<ul>
<li>回边：10 → 7
<ul>
<li>{ 7, 8, 10 }</li>
</ul>
</li>
<li>回边：7 → 4
<ul>
<li>{ 4, 5, 6, 7, 8, 10 }</li>
<li>结点 8 可以不经过 4 就到达 7</li>
<li>包含了前面的循环</li>
</ul>
</li>
<li>回边4 → 3 (8 → 3)
<ul>
<li>同样的头</li>
<li>同样的结点集合{ 3, 4, 5, 6, 7, 8, 10 }</li>
</ul>
</li>
<li>回边9→1
<ul>
<li>整个流图</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\8_机器无关的优化\image-20231221110643148.png" alt="image-20231221110643148" style="zoom:50%;" />
<ul>
<li><strong>循环头上头</strong>
<ul>
<li>每个自然循环都有一个循环头header</li>
<li>一些循环相关的优化 (如循环不变量移动) 需要<strong>在循环头之前插入代码</strong></li>
<li>常见做法是在循环头之前插入一个<strong>基本块</strong> (称为 preheader)，用于存放相关的代码</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\8_机器无关的优化\image-20231221111134927.png" alt="image-20231221111134927" style="zoom: 67%;" />
<h2 id="总结">总结</h2>
<ul>
<li>优化的来源
<ul>
<li>冗余计算</li>
</ul>
</li>
<li>基本优化技术
<ul>
<li>公共子表达式消除、复制传播、死代码消除、常量折叠</li>
</ul>
</li>
<li>数据流分析
<ul>
<li>控制流图</li>
<li>到达定值分析、活跃变量分析、可用表达式分析</li>
</ul>
</li>
<li>部分冗余消除
<ul>
<li>预期执行表达式、懒惰代码移动</li>
</ul>
</li>
<li>循环的识别
<ul>
<li>支配节点、自然循环</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/12/CF_7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhangChengWei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Methods for DIP">
      <meta itemprop="description" content="paper analysis">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Methods for DIP">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/12/CF_7/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-12 17:28:06" itemprop="dateCreated datePublished" datetime="2024-02-12T17:28:06+08:00">2024-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-30 22:16:32" itemprop="dateModified" datetime="2023-12-30T22:16:32+08:00">2023-12-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>代码生成</h1>
<h2 id="代码生成器的位置">代码生成器的位置</h2>
<ul>
<li>代码生成器的输入：<strong>中间表示</strong>和<strong>符号表</strong></li>
<li>根据中间表示(IR) 生成代码</li>
<li>代码生成器之前可能有一个<u>优化组件</u></li>
<li>代码生成器的三个任务
<ul>
<li><strong>指令选择</strong>：选择适当的指令实现IR语句</li>
<li><strong>寄存器分配和指派</strong>：把哪个值放在哪个寄存器中</li>
<li>指令排序：按照什么顺序安排指令执行</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\7_代码生成\image-20231130111153837.png" alt="image-20231130111153837" style="zoom:50%;" />
<h2 id="代码生成器的设计">代码生成器的设计</h2>
<h3 id="设计目标">设计目标</h3>
<ul>
<li>正确性：正确的机器指令</li>
<li>易于实现、测试和维护</li>
<li>输入IR的选择
<ul>
<li>四元式、三元式、字节代码、堆栈机代码、后缀表示、抽象语法树、DAG图、…</li>
</ul>
</li>
<li>输出
<ul>
<li><strong>RISC</strong>、CISC</li>
<li>可重定向代码、<strong>汇编语言</strong></li>
</ul>
</li>
</ul>
<h3 id="目标机模型">目标机模型</h3>
<ul>
<li>
<p>使用三地址机器的模型</p>
</li>
<li>
<p>与三地址码的关键区别：<strong>寄存器</strong></p>
<ul>
<li>位于 CPU 内部，用于存放数据的小型高速存储区域</li>
<li>几乎所有 CPU 计算都需要寄存器参与(存放参数/结果)</li>
<li>几乎所有参与计算的程序数据都位于内存中(使用外存数据也须先读入内存)</li>
<li>机器码需要频繁地<strong>在寄存器与内存之间搬运数据</strong></li>
</ul>
</li>
<li>
<p><strong>指令</strong></p>
<ul>
<li><strong>加载</strong>：LD <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">dst, addr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> (把地址 addr 中的内容加载到 dst 所指的寄存器)</li>
<li><strong>保存</strong>：ST <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">x, r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> (把寄存器 r 中的内容保存到 x 中)</li>
<li><strong>计算</strong>：&lt;OP&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi>s</mi><mi>r</mi><mi>c</mi><mn>1</mn><mo separator="true">,</mo><mi>s</mi><mi>r</mi><mi>c</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">dst, src1, src2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">src</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">src</span><span class="mord">2</span></span></span></span>  (把 src1和 src2中的值运算后将结果存放到 dst 中)</li>
<li><strong>无条件跳转</strong>：BR <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> (控制流转向标号 L 的指令)</li>
<li><strong>条件跳转</strong>：B&lt;cond&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo separator="true">,</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">r, L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span></span></span></span> (对 r 中的值进行测试，如果为真则转向 L；cond代表对寄存器r中的值做某个常见测试，如BLTZ r, L 表示当r &lt; 0时跳转到L )</li>
</ul>
</li>
<li>
<p><strong>寻址模式</strong></p>
<ul>
<li>变量 x：指向分配 x 的内存位置</li>
<li>a®：地址是 a 的左值<strong>加</strong>上寄存器 r 中的值</li>
<li>constant®：寄存器 r 中内容<strong>加</strong>上前面的常数即其地址</li>
<li>*r：寄存器 r 的内容所表示的位置上存放的<strong>内容</strong>位置</li>
<li>*constant®：寄存器中内容加上常量所代表的位置上的内容所表示的位置</li>
<li>常量 #constant</li>
</ul>
</li>
</ul>
<p><img src="D:\Typora_picture\7_代码生成\image-20231130113029753.png" alt="image-20231130113029753" style="zoom: 33%;" /><img src="D:\Typora_picture\7_代码生成\image-20231130113047944.png" alt="image-20231130113047944" style="zoom: 36%;" /></p>
<img src="D:\Typora_picture\7_代码生成\image-20231130113138835.png" alt="image-20231130113138835" style="zoom: 33%;" />
<ul>
<li>
<p>程序及指令的代价</p>
<ul>
<li>不同的目的有不同的度量
<ul>
<li>最短编译时间、运行时间、目标程序大小、能耗</li>
</ul>
</li>
<li>不可判定一个目标程序是否最优</li>
<li>假设每个指令有<strong>固定的代价</strong>，设定为1加上<strong>运算分量寻址模式的代价</strong>
<ul>
<li>LD R0, R1：代价为1</li>
<li>LD R0, M：代价是2</li>
<li>LD R1, *100(R2)：代价为2</li>
</ul>
</li>
</ul>
</li>
<li>
<p>目标代码中的地址</p>
<ul>
<li>如何为过程调用和返回生成代码？
<ul>
<li>静态分配 (活动记录)</li>
<li>栈式分配 (活动记录)</li>
</ul>
</li>
<li>如何将IR中的名字 (过程名或变量名) 转换成为目标代码中的地址？
<ul>
<li>不同区域中的名字采用不同的寻址方式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="活动记录的栈式分配">活动记录的栈式分配</h3>
<ul>
<li>寄存器SP指向栈顶活动记录起始处</li>
<li>第一个过程 (main) 初始化栈区</li>
<li>过程调用指令序列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD SP, SP, <span class="meta">#caller.recordSize 	<span class="comment">// 增大栈指针</span></span></span><br><span class="line">ST <span class="number">0</span>(SP), <span class="meta">#here + 16 			<span class="comment">// 保存返回地址</span></span></span><br><span class="line">BR callee.codeArea 				<span class="comment">// 转移到被调用者</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回指令序列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BR *<span class="number">0</span>(SP) 						<span class="comment">// 被调用者执行，返回调用者</span></span><br><span class="line">SUB SP, SP, <span class="meta">#caller.recordSize 	<span class="comment">// 调用者减小栈指针</span></span></span><br></pre></td></tr></table></figure>
<h3 id="名字的运行时刻地址">名字的运行时刻地址</h3>
<ul>
<li>在三地址语句中使用<strong>名字</strong> (实际上是指向<strong>符号表条目</strong>) 来引用变量</li>
<li>语句 x = 0
<ul>
<li>如果 x 分配在静态区域，且静态区开始位置为static
<ul>
<li>static[12] = 0 LD 112, #0 // static = 100</li>
</ul>
</li>
<li>如果 x 分配在栈区，且相对地址为12，则
<ul>
<li>LD 12(SP), #0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="算法的基本思想和数据结构">算法的基本思想和数据结构</h3>
<ul>
<li>依次考虑各三地址指令，<strong>尽可能把值保留在寄存器中</strong>，减少寄存器/内存之间的数据交换</li>
<li>为一个三地址指令生成机器指令时
<ul>
<li>只有当<strong>运算分量不在寄存器</strong>中时，才从内存载入</li>
<li>尽量保证只有当<strong>寄存器中值不被使用</strong>（称之为<strong>不活跃</strong>）时，才覆盖掉</li>
</ul>
</li>
<li>数据结构（编译期）
<ul>
<li>==<strong>寄存器描述符</strong>==：跟踪各个寄存器都存放了<strong>哪些变量的当前值</strong></li>
<li>==<strong>地址描述符</strong>==：各个<strong>变量的当前值存放在哪些位置</strong>（包括内存位置和寄存器）上</li>
</ul>
</li>
</ul>
<h3 id="代码生成算法">代码生成算法</h3>
<ul>
<li>重要子函数：==<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>e</mi><mi>t</mi><mi>R</mi><mi>e</mi><mi>g</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">getReg(I)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.00773em;">tR</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span>==
<ul>
<li>根据<strong>寄存器描述符</strong>和<strong>地址描述符</strong>等数据流信息，<strong>为三地址指令 I 选择最佳的寄存器</strong></li>
<li>得到的机器指令的质量依赖于 <strong>getReg 函数选取寄存器的算法</strong></li>
</ul>
</li>
<li>代码生成算法逐个处理三地址指令</li>
<li>运算语句：x = y + z
<ul>
<li>getReg(x = y + z) 为 x, y, z 选择寄存器 R~x~, R~y~, R~z~</li>
<li>检查 R~y~ 的寄存器描述符，如果 y 不在 R~y~中则生成指令
<ul>
<li>LD R~y~ , y’ // <strong>y’表示存放 y 值的当前位置</strong></li>
<li>类似地确定是否生成LD R~z~ , z’</li>
</ul>
</li>
<li>生成指令 ADD R~x~, R~y~ , R~z~</li>
</ul>
</li>
<li>赋值语句：x = y
<ul>
<li>getReg(x = y)为 x 和 y 选择<strong>相同的寄存器</strong> (运行后值相同)</li>
<li>如果 y 不在 R~y~中，则生成指令 LD R~y~ , y</li>
</ul>
</li>
<li>基本块的收尾
<ul>
<li>如果变量 x <strong>活跃</strong>，且不在内存中，则生成指令 ST x, R~x~</li>
</ul>
</li>
<li>==代码生成同时<strong>更新寄存器和地址描述符</strong>==（记）
<ol>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>D</mi><mtext> </mtext><mi>R</mi><mo separator="true">,</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">LD\ R, x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span></span></span></span>
<ul>
<li>R 的寄存器描述符：<strong>只包含 x</strong></li>
<li>x 地址描述符：R 作为新位置<strong>加入</strong>到 x 的位置集合中</li>
<li>从任何不同于 x 的变量的地址描述符中<strong>删除</strong> R</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>T</mi><mtext> </mtext><mi>x</mi><mo separator="true">,</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">ST\ x, R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">ST</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>
<ul>
<li>x 的地址描述符：包含自己的内存位置 (<strong>新增</strong>)</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>D</mi><mi>D</mi><mtext> </mtext><msub><mi>R</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>R</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>R</mi><mi>z</mi></msub></mrow><annotation encoding="application/x-tex">ADD\ R_x, R_y, R_z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">DD</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
<ul>
<li>R~x~ 的寄存器描述符：<strong>只</strong>包含 x</li>
<li>x 的地址描述符：<strong>只</strong>包含 R~x~ (不包含 x 的内存位置)(R~x~ 是 x 所在的<strong>唯一最新</strong>位置)</li>
<li>从任何不同于 x 的变量的地址描述符中<strong>删除</strong> Rx</li>
</ul>
</li>
<li>处理 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x = y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 时
<ul>
<li>如果生成LD R~y~, y，按照规则1处理</li>
<li>把 x 加入到 R~y~ 的寄存器描述符中 (即 R~y~ 同时存放了 x 和 y 的当前值)</li>
<li>x 的地址描述符：只包含 R~y~ (不包含 x 的内存位置)</li>
</ul>
</li>
</ol>
</li>
<li>示例
<ul>
<li>a、b、c、d在 5) 后仍活跃</li>
<li>t、u、v是局部临时变量</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\7_代码生成\image-20231205103155723.png" alt="image-20231205103155723" style="zoom:50%;" />
<img src="D:\Typora_picture\7_代码生成\image-20231205103545991.png" alt="image-20231205103545991" style="zoom:50%;" />
<img src="D:\Typora_picture\7_代码生成\image-20231205103629411.png" alt="image-20231205103629411" style="zoom:50%;" />
<ul>
<li><strong>getReg函数</strong>
<ul>
<li>目标：<strong>减少 LD/ST 指令</strong></li>
<li>任务：为运算<strong>分量</strong>和<strong>结果</strong>分配寄存器</li>
<li>为 x = y op z 的运算分量 y 和 z 分配寄存器
<ul>
<li>如果 y <strong>已经在某个寄存器中</strong>，不需要进行处理，选择这个寄存器作为 R~y~</li>
<li>如果 y 不在寄存器中，且<strong>有空闲寄存器</strong>，选择一个空闲寄存器作为 R~y~</li>
<li>如果 y <strong>不在寄存器</strong>中，且<strong>没有空闲</strong>寄存器，则：
<ul>
<li>若选择寄存器 R，且已知其寄存器描述符表示某<strong>变量 v 的值在 R 中</strong>，则
<ol>
<li>如果 v 的地址描述符表明可在<strong>别的地方找到 v</strong>，选择 R</li>
<li>v 就是 x (即结果)，且 x 不是运算分量 z，选择 R</li>
<li>如果 v 在此<strong>之后</strong>不会被使用 (不活跃)，选择 R</li>
<li>生成<strong>保存指令</strong> ST v, R (溢出操作) (搬回内存)并<strong>修改 v 的地址描述符</strong>；如果 R 中存放了多个变量的值，那么需要生成多条 ST 指令</li>
</ol>
</li>
</ul>
</li>
<li>为结果 x 选择寄存器 R~x~ 的方法，基本上和把 y 从内存 LD 时一样，但是：
<ul>
<li>只存放 x 值的寄存器<strong>总是可接受的</strong></li>
<li>如果 y 在指令之后不再使用，且 R~y~ 仅仅保存了 y 的值， 那么 R~y~ 同时也可以作为R~x~ (对 z 也一样)</li>
</ul>
</li>
<li>处理 x = y 时
<ul>
<li>先选择 R~y~</li>
<li>然后让 R~x~ = R~y~</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如何判断一个变量是否活跃？
<ul>
<li>需要沿着代码<strong>执行路径</strong>向 “前” 看</li>
<li>变量值的使用
<ul>
<li>三地址语句 i 向变量 x <strong>赋值</strong>，若另一个语句 j 的运算分量为 x，且<strong>从 i 开始有一条路径到达 j</strong>，且<strong>路径上没有对 x 赋值</strong>，那么 j 就使用了 i 处计算得到的 x 的值</li>
<li>我们说变量 x 在语句 i 后的程序点上<strong>活跃</strong>
<ul>
<li>程序执行完语句 i 时，x 中存放的值将被后面的语句使用</li>
<li><strong>不活跃</strong>是指变量的<strong>值</strong>不会被使用，而不是变量不会被使用</li>
</ul>
</li>
</ul>
</li>
<li>这些信息可以用于代码生成
<ul>
<li>若 x 在 i 处不活跃，且 x 占用了一个寄存器，我们可把这个寄存器用于其它目的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="基本块和流图">基本块和流图</h2>
<ul>
<li>
<p>基本块</p>
<ul>
<li>对每个过程内的<strong>指令</strong>进行<strong>划分</strong></li>
<li>必然连续执行的指令划入一组，称为基本块
<ul>
<li>控制流只能从基本块的<strong>第一条</strong>指令进入</li>
<li>除基本块的<strong>最后一条指令</strong>外，控制流不会跳转/停机</li>
</ul>
</li>
<li>每个基本块内只有一条执行路径
<ul>
<li>易于分析</li>
</ul>
</li>
</ul>
</li>
<li>
<p>基本块划分的方法</p>
<ul>
<li>输入：<strong>三地址指令</strong>序列</li>
<li>输出：<strong>基本块的列表</strong></li>
<li>方法（“<strong>跳转</strong>”会打断指令的连续执行）
<ul>
<li>确定<strong>首指令leader</strong> (基本块的第一个指令)
<ul>
<li>第一个三地址指令</li>
<li>任意一个(条件或无条件) <strong>转移指令</strong>的<strong>目标</strong>指令</li>
<li><strong>紧跟</strong>在一个(条件或无条件) <strong>转移指令之后</strong>的指令</li>
</ul>
</li>
<li>确定基本块
<ul>
<li>每个首指令对应于一个基本块：从首指令开始到下一个首指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>基本块划分的例子</p>
</li>
</ul>
<img src="D:\Typora_picture\7_代码生成\image-20231205111727767.png" alt="image-20231205111727767" style="zoom:50%;" />
<ul>
<li><strong>确定基本块中的活跃性、后续使用</strong>
<ul>
<li>输入：基本块 B，开始时 B 中的所有<strong>非临时变量</strong>都是<strong>活跃</strong>的</li>
<li>输出：各个语句 i 上变量的活跃性、后续使用信息</li>
<li>方法
<ul>
<li>从 B 的最后一个语句开始<strong>反向扫描</strong></li>
<li>对于每个语句 i：x = y + z
<ul>
<li>令语句 i 和 x、y、z 的当前活跃性信息/使用信息关联</li>
<li>设置 <strong>x</strong> 为“<strong>不活跃</strong>”和“<strong>无后续使用</strong>”</li>
<li>设置 y 和 z 为“<strong>活跃</strong>”，并指明它们的<strong>下一次使用设置为语句 i</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>示例</li>
</ul>
<img src="D:\Typora_picture\7_代码生成\image-20231205112905208.png" alt="image-20231205112905208" style="zoom:50%;" />
<img src="D:\Typora_picture\7_代码生成\image-20231205113041503.png" alt="image-20231205113041503" style="zoom:50%;" />
<h2 id="基本块优化">基本块优化</h2>
<ul>
<li>
<p>针对基本块的优化可以有很好的效果 (局部优化)</p>
</li>
<li>
<p>许多局部优化技术需要先将基本块内的指令转化为<strong>有向无环图</strong> (DAG)</p>
</li>
<li>
<p>DAG可反映变量及其值对其他变量的依赖关系</p>
<ul>
<li>结点表示变量的值</li>
<li>边表示计算值形成的依赖关系</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\7_代码生成\image-20231206195417112.png" alt="image-20231206195417112" style="zoom:50%;" />
<ul>
<li>构造方法
<ul>
<li>每个变量都有一个对应的DAG结点表示其<strong>初始值</strong></li>
<li>每个语句 s 有一个相关的结点 N，代表此计算得到的值
<ul>
<li>N 的子结点对应于(得到其运算分量当前值的) 其它语句</li>
<li>N的<strong>标号</strong>是 s 中的<strong>运算符</strong>，同时还有一组变量被关联到 N，表示 s 是最新对这些变量进行定值的语句</li>
</ul>
</li>
<li>为基本块中出现的每个变量建立结点 (表示初始值)，各变量和相应结点关联</li>
<li>顺序扫描各三地址指令，进行如下处理
<ul>
<li>指令 x = y op z
<ul>
<li>为该指令建立结点 N，标号为 op，令 x 和 N 关联</li>
<li>N 的子结点为 y、z 当前关联的结点</li>
</ul>
</li>
<li>指令 x = y
<ul>
<li>假设 y 关联到 N，那么x现在也关联到 N</li>
</ul>
</li>
</ul>
</li>
<li>扫描结束后，对所有在<strong>出口处活跃</strong>的变量 x，将 x 所<strong>关联的结点</strong>设置为<strong>输出结点</strong></li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\7_代码生成\image-20231206200208741.png" alt="image-20231206200208741" style="zoom: 40%;" />
<ul>
<li>
<p>DAG的作用</p>
<ul>
<li>DAG图描述了基本块运行时<strong>各变量的值</strong> (和初始值) 之间的关系</li>
<li>以DAG为基础，对代码进行转换
<ul>
<li>寻找<strong>局部公共子表达式</strong></li>
<li>消除死代码</li>
<li>代数恒等式的使用</li>
<li>数组引用的表示</li>
<li>指针赋值和过程调用</li>
</ul>
</li>
</ul>
</li>
<li>
<p>局部公共子表达式的发现</p>
<ul>
<li>建立某个结点 M 之前，检查是否存在一个结点 N，它和 M 具有<strong>相同的运算符</strong>和<strong>子结点</strong> (<strong>顺序也相同</strong>)</li>
<li>如果存在，则不需要生成新的结点，用 N 代表 M
<ul>
<li>如下图1，b = a - d 和 d = a - d 是公共子表达式</li>
<li>如下图2，没有公共子表达式</li>
<li>如下图3，没有公共子表达式（可能出现 i = j 的情况）</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\7_代码生成\image-20231206201014728.png" alt="image-20231206201014728" style="zoom:50%;" />
<img src="D:\Typora_picture\7_代码生成\image-20231206201241005.png" alt="image-20231206201241005" style="zoom:45%;" />
<img src="D:\Typora_picture\7_代码生成\image-20231214101651448.png" alt="image-20231214101651448" style="zoom: 50%;" />
<ul>
<li>消除死代码
<ul>
<li>在DAG图上消除<strong>没有附加活跃变量</strong>的<strong>根结点</strong>，即消除死代码</li>
<li><strong>如果</strong>上图2中 c、e 不是活跃变量 (但 a、b 是)，则可以先删除标号为 e 的结点，再删除标号为 c 的结点</li>
</ul>
</li>
<li>基于代数恒等式的优化
<ul>
<li>消除计算步骤
<ul>
<li>x + 0 = 0 + x = x</li>
<li>x – 0 = x</li>
<li>x * 1 = 1 * x = x</li>
<li>x / 1 = x</li>
</ul>
</li>
<li>强度消减
<ul>
<li>x^2^ = x * x</li>
<li>2*x = x + x</li>
<li>x/2 = x * 0.5</li>
</ul>
</li>
<li>常量合并
<ul>
<li>如：2 * 3.14可以用 6.28 替换</li>
<li>如何确保编译替换结果与运行结果一致？
<ul>
<li>进行编译，在目标机上执行目标代码，然后吧表达式替换为执行结果</li>
</ul>
</li>
</ul>
</li>
<li>实现这些优化，只需在DAG图上寻找特定的<strong>模式</strong></li>
</ul>
</li>
<li><strong>数组引用</strong>
<ul>
<li>a[j] 可能改变 a[i] 的值 (别名)，因此不能像普通运算符一样构造结点</li>
<li><strong>从数组取值</strong>的运算 x = a[i] 对应于 <strong>=[]</strong> 的结点
<ul>
<li>这个结点的<strong>左右子节点</strong>是<strong>数组初始值 a~0~</strong> 和<strong>下标 i</strong></li>
<li>变量 x 是这个结点的标号之一</li>
</ul>
</li>
<li><strong>对数组赋值</strong>的运算 a[j] = y 对应于 <strong>[]=</strong> 的结点
<ul>
<li>这个结点的三个子节点分别表示 <strong>a~0~、j 和 y</strong></li>
<li>杀死所有<strong>依赖于 a~0~</strong> 的结点</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\7_代码生成\image-20231214102916870.png" alt="image-20231214102916870" style="zoom:50%;" />
<ul>
<li>数组引用示例
<ul>
<li>设 a 是数组，b 是指针
<ul>
<li>b = 12 + a</li>
<li>x = b[i]</li>
<li>b[j] = y</li>
</ul>
</li>
<li>一个结点被杀死，意味着它不能被复用
<ul>
<li>考虑再有指令m = b[i]</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\7_代码生成\image-20231214103157287.png" alt="image-20231214103157287" style="zoom:50%;" />
<ul>
<li><strong>指针赋值/过程调用</strong>
<ul>
<li>通过指针进行取值/赋值：x = *p、*q = y
<ul>
<li>x 使用了任意变量( p 不知道指向何处 )，因此程序中<strong>所有的死代码都无法消除</strong></li>
<li>*q = y 对任意变量赋值，因此<strong>杀死了全部其他结点</strong></li>
</ul>
</li>
<li>可通过 <strong>(全局/局部) 指针分析</strong>部分地解决这个问题 (部分可解)
<ul>
<li>p = &amp;x</li>
<li>*p = y</li>
</ul>
</li>
<li>过程调用也类似，必须安全地假设它：
<ul>
<li><strong>使用</strong>了可访问范围内的所有变量</li>
<li><strong>修改</strong>了可访问范围内的所有变量</li>
</ul>
</li>
</ul>
</li>
<li>从DAG到基本块（基本块→ DAG → DAG优化 → 重构的基本块）
<ul>
<li><strong>重构</strong>的方法
<ul>
<li>每个结点构造一个三地址语句，计算对应的值</li>
<li>结果应该<strong>尽量赋给一个活跃的变量</strong></li>
<li>如果结点有多个关联的变量，则需要用<strong>赋值语句</strong>进行赋值</li>
</ul>
</li>
<li>根据DAG构造时结点产生的顺序
<ul>
<li>a = b + c</li>
<li>b = a – d</li>
<li>d = b</li>
<li>c = b + c</li>
</ul>
</li>
<li>如果<strong>b在出口处不活跃</strong>，更优的方法为：
<ul>
<li>a = b + c</li>
<li>d = a – d</li>
<li>c = d + c</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\7_代码生成\image-20231214104744289.png" alt="image-20231214104744289" style="zoom:50%;" />
<ul>
<li>
<p>重组的规则</p>
<ul>
<li>注意求值顺序
<ul>
<li>指令顺序必须遵守DAG中结点的顺序</li>
<li>对数组<strong>赋值</strong> (write) 要跟在原来之前的<strong>赋值/求值</strong>之后</li>
<li>对数组<strong>求值</strong> (read) 要跟在原来之前的<strong>赋值</strong>指令之后</li>
<li>对<strong>变量的使用</strong>必须跟在所有原来在它之前的<strong>过程调用</strong>和<strong>指针间接赋值</strong>之后</li>
<li>任何过程调用或指针间接赋值必须跟在原来在它之前的变量求值之后</li>
</ul>
</li>
<li>即保证：
<ul>
<li>如果两个指令之间相互影响，它们的顺序就不该改变</li>
</ul>
</li>
</ul>
</li>
<li>
<p>窥孔优化</p>
<ul>
<li>
<p>使用一个滑动窗口 (窥孔) 来检查目标指令，在窥孔内实现优化</p>
<ul>
<li>
<p><strong>冗余指令消除</strong></p>
<ul>
<li>
<p>多余的LD/ST指令</p>
<ul>
<li>LD R~0~, a</li>
<li>ST a, R~0~</li>
<li>如果ST a, R~0~ 是非跳转目标，可删除</li>
</ul>
</li>
<li>
<p>级联跳转代码</p>
<ul>
<li>
<p>if debug == 1 goto L1; goto L2; L1: …; L2: …;</p>
<p>• =&gt; if debug != 1 goto L2; L1: …; L2: …;</p>
</li>
<li>
<p>如果已知debug一定是0，那么可替换下面的写法</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>控制流优化</strong></p>
<ul>
<li>
<p>goto L1; … …; L1: goto L2</p>
<p>• =&gt; goto L2; … …; L1: goto L2</p>
</li>
<li>
<p>if <strong>a &lt; b</strong> goto L1; … … ; L1: goto L2</p>
<p>• =&gt; if <strong>a &lt; b</strong> goto <strong>L2</strong>; … … ; L1: goto L2</p>
</li>
</ul>
</li>
<li>
<p><strong>代数化简/强度消减</strong></p>
<ul>
<li>应用代数恒等式进行优化
<ul>
<li>消除 x = x + 0, x = x * 1, …</li>
<li>用 x * x 替换 x2</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>机器特有指令的使用</strong></p>
<ul>
<li><strong>INC</strong>, DEC, …</li>
</ul>
</li>
</ul>
</li>
<li>
<p>滑动窗口 (窥孔) 并无准确定义，可理解为只需关注<strong>少量相关指令</strong>即可完成的优化</p>
</li>
</ul>
</li>
<li>
<p>树重写实现指令选择</p>
<ul>
<li>在某些机器上，同一个三地址指令可以使用<strong>多种机器指令实现</strong>，有时<strong>多个三地址指令</strong>可以使用一个机器指令实现</li>
<li>指令选择
<ul>
<li>需求：为实现中间表示形式中出现的运算符选择适当的机器指令</li>
<li>思路：用<strong>树</strong>来表示<strong>中间代码</strong>，按照特定的规则不断<strong>覆盖</strong>这棵树并生成机器指令</li>
</ul>
</li>
<li>示例
<ul>
<li>a[i] = b + 1
<ul>
<li>ind：把参数作为内存地址</li>
<li>a, i：<strong>局部</strong>变量（C~a~ 和 C~i~ 存放的是<strong>偏移</strong>）</li>
<li>b：<strong>全局</strong>变量</li>
<li>SP：栈顶指针</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\7_代码生成\image-20231214111130736.png" alt="image-20231214111130736" style="zoom:50%;" />
<ul>
<li>目标指令选择
<ul>
<li>通过应用一个<strong>树重写规则</strong>序列来生成</li>
<li>重写规则形式（大树优先：6优于5）</li>
<li>
<img src="D:\Typora_picture\7_代码生成\image-20231214111648156.png" alt="image-20231214111648156" style="zoom:50%; float:left" />
</li>
<li>一组树重写规则被称为一个树翻译方案</li>
<li>树重写规则示例</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\7_代码生成\image-20231214111717906.png" alt="image-20231214111717906" style="zoom:50%;" />
<img src="D:\Typora_picture\7_代码生成\image-20231214111959149.png" alt="image-20231214111959149" style="zoom:50%;" />
<img src="D:\Typora_picture\7_代码生成\image-20231214112009289.png" alt="image-20231214112009289" style="zoom:50%;" />
<ul>
<li>覆盖重写过程</li>
</ul>
<img src="D:\Typora_picture\7_代码生成\image-20231214112659615.png" alt="image-20231214112659615" style="zoom:50%;" />
<ul>
<li>树翻译方案的工作模式
<ul>
<li>给定一颗输入树，树重写规则中的<strong>模板</strong>被用来匹配输入树的<strong>子树</strong></li>
<li>如果找到一个匹配的模板，那么输入树中匹配的子树将被替换为相应规则中的<strong>替换结点</strong>，并执行相应的<strong>动作</strong>，这可能是生成相应的机器指令序列</li>
<li>不断匹配，直到这颗树被规约成<strong>单个结点</strong>，或找不到匹配的模板为止</li>
<li>在此过程中生成的机器指令代码序列就是树翻译方案作用于给定输入树得到的输出</li>
</ul>
</li>
<li>树翻译方案生成目标指令示例
<ul>
<li>如何完成树匹配？
<ul>
<li>把树重写规则替换成相应的上下文无关文法的产生式</li>
<li>产生式的右部是其指令模板的<strong>前缀表示</strong></li>
</ul>
</li>
<li>如果在某个时刻有多个模板可以匹配
<ul>
<li>匹配到<strong>大树优先</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\7_代码生成\image-20231214112855552.png" alt="image-20231214112855552" style="zoom: 67%;" />
<h2 id="代码生成器">代码生成器</h2>
<ul>
<li>根据三地址指令序列生成机器指令
<ul>
<li>假设每个三地址指令只有一个对应的机器指令</li>
<li>有一组寄存器用于计算基本块内部的值</li>
</ul>
</li>
<li>主要的目标是<strong>减少加载 (LD) 和保存 (ST) 指令</strong>，即<strong>最大限度地利用寄存器</strong></li>
<li>寄存器的使用方法
<ul>
<li>执行运算时，运算分量必须放在寄存器中</li>
<li>存放临时变量</li>
<li>存放全局的值</li>
<li>进行运行时刻管理 (比如栈顶指针)</li>
</ul>
</li>
</ul>
<h2 id="寄存器分配和指派">寄存器分配和指派</h2>
<ul>
<li><strong>寄存器分配</strong>
<ul>
<li>确定在程序的每个点上，<strong>哪个值</strong>应该存放在寄存器中</li>
</ul>
</li>
<li><strong>寄存器指派</strong>
<ul>
<li>各个值应该存放在<strong>哪个寄存器</strong>中</li>
</ul>
</li>
<li>简单方法：把特定类型的值分配给特定的寄存器
<ul>
<li>数组基地址指派给一组寄存器，算术计算分配给一组寄存器，栈顶指针分配一个寄存器，循环，……</li>
<li>缺点：寄存器的使用<strong>效率较低</strong></li>
</ul>
</li>
<li>全局寄存器分配
<ul>
<li>在循环中频繁使用的值存放在固定寄存器
<ul>
<li>分配固定多个寄存器来存放<strong>内部循环</strong>中<strong>最活跃</strong>的值</li>
</ul>
</li>
<li>可以通过使用<strong>计数</strong>的方法来<strong>估算</strong>把一个变量放到寄存器中会带来多大好处，然后根据这个估算来分配寄存器</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/12/CF_6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhangChengWei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Methods for DIP">
      <meta itemprop="description" content="paper analysis">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Methods for DIP">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/12/CF_6/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-12 17:28:06" itemprop="dateCreated datePublished" datetime="2024-02-12T17:28:06+08:00">2024-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-28 15:46:37" itemprop="dateModified" datetime="2023-12-28T15:46:37+08:00">2023-12-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>运行时刻环境</h1>
<h2 id="存储组织">存储组织</h2>
<p><strong>运行时刻环境</strong></p>
<ul>
<li>
<p>为数据分配<strong>安排存储位置</strong></p>
</li>
<li>
<p>确定访问变量时使用的机制</p>
</li>
<li>
<p>过程之间的<strong>连接、参数传递</strong></p>
</li>
<li>
<p>(略)和操作系统、输入输出设备相关的其它接口</p>
</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231116102857716.png" alt="image-20231116102857716" style="zoom: 67%;" />
<ul>
<li>目标程序的代码放置在<strong>代码区</strong></li>
<li>静态区、堆区、栈区分别放置不同类型生命期的<strong>数据</strong>值</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231116103057183.png" alt="image-20231116103057183" style="zoom:50%;" />
<p><strong>章节主题</strong></p>
<ul>
<li>
<p>存储管理：<strong>栈分配、堆管理、垃圾回收</strong></p>
</li>
<li>
<p>对变量、数据的访问</p>
</li>
</ul>
<p><strong>活动记录</strong></p>
<ul>
<li>为了管理过程在<u>一次执行</u>中所需要的信息，使用一个<strong>连续</strong>的存储块，称为活动记录</li>
</ul>
<p><strong>静态分配</strong></p>
<ul>
<li>编译器在<u>编译时刻</u>就可以做出<u>存储分配决定</u>，不需要考虑程序运行时刻的情形</li>
<li>名字在程序被编译时<strong>绑定</strong>到存储单元，不需要运行时的支持</li>
<li>绑定的生存期是程序的整个运行期间</li>
<li><strong>全局常量、全局变量</strong></li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231116104243069.png" alt="image-20231116104243069" style="zoom:50%;" />
<p><strong>动态分配</strong></p>
<ul>
<li>
<p><u>栈式存储</u>：和过程的调用/返回同步进行分配和回收，值的生命期与过程生命期相同</p>
</li>
<li>
<p><u>堆存储</u>：数据对象可比创建它的过程调用更长寿</p>
</li>
<li>
<p>手工进行回收</p>
</li>
<li>
<p><strong>垃圾回收机制</strong></p>
</li>
</ul>
<h2 id="栈式分配">栈式分配</h2>
<h3 id="活动树">活动树</h3>
<ul>
<li>
<p>如果过程p调用q，那么q的该次活动必定在p的活动结束之前结束：</p>
<ul>
<li><strong>q正常结束</strong>，p继续</li>
<li><strong>q中止</strong>，p和q同时结束</li>
<li><strong>q因异常结束</strong>，p可能会处理这个异常，此时q结束，p继续(不一定从调用q的点开始)</li>
</ul>
</li>
<li>
<p>过程调用(过程活动)在<strong>时间</strong>上总是<strong>嵌套</strong>的</p>
<ul>
<li>后调用的先返回</li>
<li>用<strong>栈</strong>来分配过程活动所需内存空间</li>
</ul>
</li>
<li>
<p>程序运行的所有过程活动可以用<strong>树</strong>表示</p>
<ul>
<li>
<p>每个<strong>结点</strong>对应于一个<strong>过程活动</strong>(一次函数调用)</p>
</li>
<li>
<p><strong>根结点</strong>对应于<strong>main</strong>过程的活动</p>
</li>
<li>
<p>过程p的某次活动对应的结点的所有子结点</p>
<ul>
<li>
<p>表示此次活动所调用的各个过程活动</p>
</li>
<li>
<p><strong>从左向右</strong>，表示调用的<strong>先后顺序</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>例：快速排序程序</p>
<ul>
<li>过程调用(返回)序列和活动树的前序(后序)遍历对应</li>
<li>假定当前活动对应结点N，那么所有尚未结束的活动对应于N及其祖先结点</li>
<li>同层次，先左后右；不同层次，先上后下，嵌套</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231116105452726.png" alt="image-20231116105452726" style="zoom:50%;" />
<img src="D:\Typora_picture\6_运行时刻环境\image-20231116111117043.png" alt="image-20231116111117043" style="zoom: 67%;" />
<img src="D:\Typora_picture\6_运行时刻环境\image-20231116105404443.png" alt="image-20231116105404443" style="zoom:50%;" />
<h3 id="活动记录">活动记录</h3>
<ul>
<li>过程调用和返回由<strong>控制栈</strong>进行管理</li>
<li>每个<strong>活跃的</strong>活动对应于栈中的一个活动记录</li>
<li>活动记录按活动的开始时间，<strong>从栈底到栈顶排列</strong></li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231116111624981.png" alt="image-20231116111624981" style="zoom:50%;" />
<ul>
<li>运行时刻栈的例子
<ul>
<li>a[11] 为全局变量</li>
<li>main 无局部变量</li>
<li>r 有局部变量 i</li>
<li>q 有局部变量 i，和参数 m, n</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231116112125598.png" alt="image-20231116112125598" style="zoom:50%;" />
<ul>
<li>
<p>布局原则</p>
<ul>
<li>
<p>调用者和被调用者之间传递的值放在被调用者活动记录的开始位置</p>
</li>
<li>
<p>固定长度的项(控制链、访问链和机器状态字段)放在中间位置</p>
</li>
<li>
<p>早期不知道大小的项在活动记录尾部</p>
</li>
<li>
<p><strong>栈顶指针(top_sp)<strong>通常指向</strong>固定长度字段的末端</strong>(指向数据部分，即局部数据之上)</p>
</li>
</ul>
</li>
</ul>
<h3 id="调用代码序列">调用代码序列</h3>
<ul>
<li>
<p><strong>调用代码序列</strong></p>
<ul>
<li>
<p>为活动记录<strong>分配空间</strong>，填写记录中的信息</p>
<ul>
<li>调用代码序列会<strong>分割</strong>到调用者和被调用者中</li>
<li>根据源语言、目标机器和操作系统的限制，可以有不同的分割方案</li>
<li>把代码尽可能放在<strong>被调用者</strong>中（面对可能的多次调用）</li>
</ul>
</li>
<li>
<p>==具体过程==</p>
<ul>
<li><strong>调用者</strong>计算实在参数的值</li>
<li><strong>调用者</strong>将<u>返回地址和原top_sp存放到被调用者的活动记录</u>中；调用者<u>增加top_sp的值</u>（越过了调用者的局部数据和临时变量、以及被调用者的参数和机器状态字段）</li>
<li><strong>被调用者</strong>保存寄存器值和其他状态字段（刚进入被调用者时，寄存器值不变）</li>
<li><strong>被调用者</strong>初始化局部数据并开始执行</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>返回代码序列</strong></p>
</li>
<li>
<p>恢复调用者状态，使调用者继续运行</p>
<ul>
<li>==具体过程==
<ul>
<li>
<p><strong>被调用者</strong>将返回值放到与参数相邻的位置</p>
</li>
<li>
<p><strong>被调用者</strong>恢复top_sp和寄存器，跳转到返回地址</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231116114109989.png" alt="image-20231116114109989" style="zoom:50%;" />
<ul>
<li>要求
<ul>
<li>
<p>数据方面</p>
<ul>
<li>
<p>能够把<strong>参数</strong>正确地传递给被调用者</p>
</li>
<li>
<p>能够把<strong>返回值</strong>传递给调用者</p>
</li>
</ul>
</li>
<li>
<p>控制方面</p>
<ul>
<li>
<p>能够正确转到<strong>被调用</strong>过程的代码<strong>开始位置</strong></p>
</li>
<li>
<p>能够正确转回<strong>调用者</strong>的<strong>调用位置</strong>(的下一条指令)</p>
</li>
</ul>
</li>
<li>
<p>调用代码序列与<strong>活动记录的布局</strong>相关</p>
</li>
</ul>
</li>
</ul>
<h3 id="栈中的变长数据">栈中的变长数据</h3>
<ul>
<li>
<p>如果<strong>数据对象的生命期</strong>局限于<strong>过程活动的生命期(</strong> 变长数组也可以)，就可以分配在<strong>运行时刻栈</strong>中</p>
<ul>
<li>
<p>top指向<strong>实际栈顶</strong></p>
</li>
<li>
<p>top_sp用于寻找顶层记录的<strong>定长</strong>字段</p>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231116114641982.png" alt="image-20231116114641982" style="zoom:50%;" />
<h2 id="栈中非局部数据的访问">栈中非局部数据的访问</h2>
<h3 id="非局部数据的访问">非局部数据的访问</h3>
<ul>
<li>
<p><strong>无嵌套过程</strong></p>
<ul>
<li>C语言中，每个函数能访问的变量
<ul>
<li><strong>函数的局部变量</strong>：相对地址已知，且存放在当前活动记录内，top_sp指针加上相对地址即可访问</li>
<li><strong>全局变量</strong>：在静态区，地址在编译时刻可知</li>
</ul>
</li>
<li>很容易将C语言的函数作为参数进行传递
<ul>
<li>参数中只需包括函数代码的开始地址</li>
<li>在函数中访问非局部变量的模式很简单，不需要考虑过程是如何激活的</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>有嵌套过程</strong></p>
<ul>
<li>
<p>PASCAL中，若过程A的声明中包含过程B的声明，那么B可以使用在A中声明的变量</p>
</li>
<li>
<p>当B的代码运行时，如果它使用的是A中的变量，必须通过<strong>访问链</strong>访问</p>
<ul>
<li>可以通过top_sp指针直接访问吗？
<ul>
<li>不可以。A函数调用B函数，B的活动记录中可以拿到上一层A的top_sp指针，因此可以通过top_sp指针直接访问；但若A调用C且C调又用B，那么B的活动记录中只能拿到C的top_sp指针，而拿不到A的，就会出错。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231123101458794.png" alt="image-20231123101458794" style="zoom:50%;" />
<h3 id="ML：支持嵌套过程声明的语言">ML：支持嵌套过程声明的语言</h3>
<ul>
<li>定义变量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val &lt;name&gt; = &lt;expression&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;name&gt; (&lt;arguments&gt;) = &lt;body&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用下列形式的let语句来定义函数体：
<ul>
<li><strong>每个definition的作用域</strong>：该定义之后直到in为止的所有定义，以及直到end为止的所有语句</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &lt;list of definitions&gt; in &lt;statements&gt; end</span><br></pre></td></tr></table></figure>
<ul>
<li>函数可以嵌套定义
<ul>
<li>let语句里可以包含另一个函数的定义</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231123103031878.png" alt="image-20231123103031878" style="zoom: 50%;" />
<h3 id="嵌套深度">嵌套深度</h3>
<ul>
<li>嵌套深度可根据源程序<strong>静态</strong>确定
<ul>
<li>不内嵌于任何其它过程的过程，深度为1</li>
<li>嵌套于深度为 i 的过程的过程深度为 i + 1</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231123103541290.png" alt="image-20231123103541290" style="zoom: 50%;" />
<h3 id="访问链">访问链</h3>
<ul>
<li>
<p>访问链被用于访问<strong>非局部</strong>的数据</p>
<ul>
<li>如果过程 p 在声明时(直接)嵌套在过程 q 中，那么 p 活动记录中的<strong>访问链</strong>指向<strong>上层最近</strong>的 q 的活动记录</li>
</ul>
</li>
<li>
<p>从栈顶活动记录开始，访问链形成了一个链路，<strong>嵌套深度</strong>沿着链路<strong>逐一递减</strong></p>
</li>
<li>
<p>设深度为 n~p~ 的过程 p 访问变量 x，而变量 x 在深度为 n~q~ 的过程 q 中声明</p>
<ul>
<li>n~p~ – n~q~ 在编译时刻已知；</li>
<li>从当前活动记录出发，沿访问链<strong>前进 n~p~ – n~q~ 次</strong>找到活动记录</li>
<li>x 相对于这个活动记录的<strong>偏移量</strong>在编译时刻已知</li>
</ul>
</li>
<li>
<p>访问链的维护</p>
<ul>
<li>当<strong>过程 q 调用过程 p</strong> 时
<ul>
<li><strong>p 的深度大于 q</strong> ：根据作用域规则，p 必然在 q 中直接定义；那么 p 的访问链指向当前活动记录(即 q )。
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo>=</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p.access = q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ccess</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span></li>
<li>例如：sort 调用 quicksort(1,9)</li>
</ul>
</li>
<li><strong>递归调用 p = q</strong>：新活动记录的访问链等于当前记录的访问链(即和前一个q指向同一目标)。
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo>=</mo><mi>q</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">p.access = q.access</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ccess</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ccess</span></span></span></span></li>
<li>例如：quicksort(1, 9) 调用 quicksort(1, 3)</li>
</ul>
</li>
<li><strong>p 的深度小于 q</strong>：必然有过程 r，p 直接在 r 中定义， q 也嵌套在 r 中；p 的访问链指向栈中 r 的活动记录。
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo>=</mo><mi>p</mi><mi mathvariant="normal">.</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">p.access =p.outer</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ccess</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">.</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span></span></span></span></li>
<li>例如：partition 调用 exchange</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231123105242167.png" alt="image-20231123105242167" style="zoom: 67%;" />
<ul>
<li>访问链的维护(过程指针型参数)
<ul>
<li>在传递过程指针参数时，过程型参数中不仅包含过程的代码指针(<strong>开始地址</strong>)，还包括正确的<strong>访问链</strong></li>
</ul>
</li>
</ul>
<h3 id="显示表">显示表</h3>
<ul>
<li>用访问链访问数据，访问开销和<strong>嵌套深度差</strong>有关
<ul>
<li>使用显示表可以提高效率，<strong>访问开销为常量</strong></li>
</ul>
</li>
<li><strong>显示表</strong>：数组 d 为<u>每个嵌套深度保留一个指针</u>
<ul>
<li>指针 d[i] 指向栈中<strong>最近的、嵌套深度为 i 的活动记录</strong></li>
<li>如果过程 p 访问嵌套深度为 i 的过程 q 中声明的变量 x ，那么 d[i] 直接指向相应的活动记录( i 在编译时刻已知 )</li>
</ul>
</li>
<li>显示表的维护
<ul>
<li>调用过程 p 时，在 p 的活动记录中保存 d[n~p~] 的值</li>
<li>将 d[n~p~] 设置为当前活动记录( 即 p )</li>
<li>从 p 返回时，恢复 d[n~p~] 的值</li>
</ul>
</li>
</ul>
<h2 id="堆管理">堆管理</h2>
<h3 id="堆空间">堆空间</h3>
<ul>
<li>用于存放<strong>生命周期不确定</strong>、或<strong>生存到被明确删除为止</strong>的数据对象</li>
<li>例如：new生成的对象可以生存到被delete为止，malloc申请的空间生存到被free为止</li>
</ul>
<h3 id="存储管理器">存储管理器</h3>
<ul>
<li>
<p>分配/回收堆区空间的子系统</p>
</li>
<li>
<p>根据语言而定</p>
<ul>
<li>C/C++需要<strong>手动</strong>回收空间</li>
<li>Java可以<strong>自动</strong>回收空间(垃圾收集)</li>
</ul>
</li>
<li>
<p>基本功能</p>
<ul>
<li><strong>分配</strong>：为内存请求分配一段连续、适当大小的堆空间
<ul>
<li>首先从<strong>空闲的堆空间</strong>分配</li>
<li>如果不行则<strong>从操作系统中获取</strong>内存、增加堆空间</li>
</ul>
</li>
<li><strong>回收</strong>：把被回收的空间<strong>返回空闲空间缓冲池</strong>，以满足其它内存需求</li>
</ul>
</li>
<li>
<p>评价存储管理器的特性</p>
<ul>
<li>空间效率：使程序需要的堆空间最小，即<strong>减小碎片</strong></li>
<li>程序效率：运用内存系统的层次，使程序运行更快</li>
<li>低开销：使分配/收回内存的操作尽可能高效</li>
</ul>
</li>
</ul>
<h3 id="计算机的存储层次结构">计算机的存储层次结构</h3>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231123112701236.png" alt="image-20231123112701236" style="zoom: 67%;" />
<h3 id="程序中的局部性">程序中的局部性</h3>
<ul>
<li>程序具有<strong>高度的局部性</strong>(Locality)
<ul>
<li><strong>时间</strong>局部性：一个程序访问的存储位置很可能将在一个很短的时间段内被再次访问</li>
<li><strong>空间</strong>局部性：被访问过的存储位置的临近位置很可能在一个很短的时间段内被访问</li>
</ul>
</li>
<li>90%的时间用来执行10%的代码</li>
<li>局部性这一特性恰好可以充分利用计算机的<strong>层次存储结构</strong></li>
</ul>
<h3 id="堆空间的碎片问题">堆空间的碎片问题</h3>
<ul>
<li>随着程序分配/回收内存，堆区逐渐被割裂成若干空闲存储块(窗口)和已用存储块的交错</li>
<li>分配一块内存时，通常是把一个窗口的一部分分配出去，其余部分成为更小的块</li>
<li>回收时，被释放的存储块被放回缓冲池；通常要把连续的窗口接合成为更大的窗口</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231123112844938.png" alt="image-20231123112844938" style="zoom:50%;" />
<h3 id="堆空间分配方法">堆空间分配方法</h3>
<ul>
<li>Best-fit
<ul>
<li>总是将请求的内存分配在满足请求的<strong>最小的窗口</strong>中<br>
(从空闲分区表的第一个表目起查找该表，将最先能够满足要求的空闲区进行分配)</li>
<li>好处：可以将大的窗口保留下来，应对更大的请求</li>
</ul>
</li>
<li>First-fit
<ul>
<li>总是将对象放置在<strong>第一个</strong>能够容纳请求的窗口中<br>
(从全部空闲区中找出能满足作业要求的、且<strong>大小最小</strong>的空闲分区)</li>
<li>放置对象时花费时间较少，但是总体性能比best-fit策略差</li>
<li>通常具有<strong>较好的数据局部性</strong>：同一时间段内生成的对象经常被分配在<strong>连续</strong>的空间内</li>
</ul>
</li>
</ul>
<h3 id="使用容器的堆管理方法">使用容器的堆管理方法</h3>
<ul>
<li>设定不同大小的块规格，<strong>相同的块放入同一容器</strong></li>
<li>较小的(较常用的)尺寸设置较多的容器</li>
<li>如GNU的C编译器将所有存储块对齐到8字节边界
<ul>
<li>空闲块的大小：
<ul>
<li>16, 24, 32, 40 … , 512</li>
<li>大于512的按对数划分：每个容器的尺寸是前一容器的两倍</li>
<li><strong>荒野块</strong>：可以扩展的内存块</li>
</ul>
</li>
</ul>
</li>
<li>分配方法
<ul>
<li>小尺寸的请求，直接在<strong>相应容器</strong>中找</li>
<li>大尺寸的请求，在<strong>适当的容器</strong>中寻找适当的空闲块</li>
<li>可能需要<strong>分割内存块</strong>，可能需要从荒野块中分割</li>
</ul>
</li>
</ul>
<h3 id="管理和接合空闲空间">管理和接合空闲空间</h3>
<ul>
<li>
<p>当回收一个块时，可以把这个块和相邻的块<strong>接合</strong>起来，构成更大的块</p>
<ul>
<li>有些管理方法不需要进行接合</li>
</ul>
</li>
<li>
<p>支持相邻块接合的数据结构</p>
<ul>
<li><strong>边界标记</strong>：在每个存储块的两端，分别设置一个free/used位，并在相邻的位置上存放字节总数</li>
<li><strong>双重链接</strong>的空闲块列表：列表的指针存放在空闲块中、用双向指针的方式记录了有哪些空闲块</li>
</ul>
</li>
<li>
<p>例：</p>
<ul>
<li>相邻的存储块A、B、C
<ul>
<li>当回收B时，通过对free/used位的查询，可知B左边的A是空闲的，而C不空闲</li>
<li>同时还可以知道A、B合并为长度为300的块</li>
<li>修改双重链表，把A替换为A、B接合后的空闲块</li>
</ul>
</li>
<li>注意：双重链表中<strong>一个结点的前驱</strong>并<strong>不一定</strong>是它邻近的块</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231123113852883.png" alt="image-20231123113852883" style="zoom:50%;" />
<h3 id="处理手工存储管理">处理手工存储管理</h3>
<ul>
<li>两大问题
<ul>
<li><strong>内存泄露</strong>(Memory leak)：未能删除不可能再被引用的数据</li>
<li><strong>悬空指针引用</strong>(Dangling pointer)：引用已被删除的数据</li>
</ul>
</li>
<li>其他问题
<ul>
<li>空指针访问/数组越界访问</li>
</ul>
</li>
</ul>
<h2 id="垃圾回收">垃圾回收</h2>
<h3 id="垃圾与垃圾回收">垃圾与垃圾回收</h3>
<ul>
<li>垃圾
<ul>
<li>广义：<strong>不需要</strong>再被引用的数据</li>
<li>狭义：<strong>不能</strong>被引用(不可达)的数据</li>
</ul>
</li>
<li>垃圾回收：自动回收不可达数据的机制，解除了程序员的负担
<ul>
<li>使用的语言：Java、Perl、ML、Modula-3、Prolog、Smalltalk</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收器的设计目标">垃圾回收器的设计目标</h3>
<ul>
<li>基本要求
<ul>
<li>语言必须是<strong>类型安全</strong>的：保证<strong>回收器能够知道</strong>数据元素是否为一个指向某内存块的指针（静态类型ML、动态类型Java）</li>
<li>类型不安全的语言：C/C++ (实践上也有垃圾回收器)</li>
</ul>
</li>
<li>性能目标
<ul>
<li>总体运行时间：不显著增加应用程序的总运行时间</li>
<li>空间使用：最大限度地利用可用内存</li>
<li>停顿时间：当垃圾回收机制启动时，可能引起<strong>应用程序的停顿</strong>，这个停顿应该<strong>比较短</strong>（很少在实时应用中使用）</li>
<li>程序局部性：改善空间局部性和时间局部性</li>
</ul>
</li>
</ul>
<h3 id="可达性">可达性</h3>
<ul>
<li>可达性就是指一个存储块<strong>可以被程序访问到</strong></li>
<li>根集：<strong>不需要指针解引用</strong>就可以<strong>直接访问</strong>的数据
<ul>
<li>Java：静态成员、栈中变量</li>
</ul>
</li>
<li>可达性
<ul>
<li>根集的成员都是可达的</li>
<li>对于任意一个对象，如果指向它的一个指针被保存在<strong>可达对象的某字段或数组元素</strong>中，那么这个对象也是可达的</li>
</ul>
</li>
<li>性质
<ul>
<li>==一旦一个对象变得不可达，它就不会再变成可达的==</li>
</ul>
</li>
</ul>
<h3 id="改变可达对象集合的操作">改变可达对象集合的操作</h3>
<ul>
<li>对象分配
<ul>
<li>返回一个指向新存储块的引用</li>
</ul>
</li>
<li>参数传递和返回值</li>
<li>引用赋值：u = v （u: x / o.f / a[i]）
<ul>
<li>v 的引用被复制到 u 中，<strong>u 中原有引用丢失</strong>；</li>
<li>这 (可能) 使 u 原来指向的对象变得不可达，并递归使更多对象变得不可达</li>
</ul>
</li>
<li>过程返回
<ul>
<li>活动记录出栈，局部变量消失，根集变小，使一些对象变得不可达</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收方法">垃圾回收方法</h3>
<ul>
<li>关注不可达
<ul>
<li>跟踪相关操作，捕获对象<strong>变得不可达的时刻</strong>，<strong>回收</strong>对象占用的空间</li>
</ul>
</li>
<li>关注可达
<ul>
<li>在需要时，标记出所有可达对象，回收其它对象</li>
</ul>
</li>
</ul>
<h3 id="基于引用计数的垃圾回收器">基于引用计数的垃圾回收器</h3>
<ul>
<li>每个<strong>对象</strong>有一个用于存放引用计数的字段，并按如下方式维护：
<ul>
<li>对象分配：引用计数<strong>设</strong>为1</li>
<li>参数传递：引用计数<strong>加</strong>1</li>
<li>引用赋值：u = v，u 指向的对象引用<strong>减</strong>1，v 指向的对象引用<strong>加</strong>1</li>
<li>过程返回：<strong>局部变量</strong>指向对象的<strong>引用计数减1</strong></li>
</ul>
</li>
<li>如果一个对象的引用计数为0，需要==此对象中各个指针<strong>所指对象的引用计数减1</strong>，然后删除该对象==</li>
<li>特点：开销较大，但不会引起停顿</li>
<li>考虑如下操作，则如下左图所示
<ul>
<li>Y = X</li>
<li>Y 是当前函数 f 的局部变量，且 f 返回</li>
</ul>
</li>
</ul>
<p><img src="D:\Typora_picture\6_运行时刻环境\image-20231130102553520.png" alt="image-20231130102553520" style="zoom:58%;" /><img src="D:\Typora_picture\6_运行时刻环境\image-20231204112024404.png" alt="image-20231204112024404" style="zoom: 58%;" /></p>
<ul>
<li>修改计数后总是考虑是否释放</li>
<li>释放一个对象之前总是先处理对象内部的指针</li>
</ul>
<h3 id="基于引用计数的缺陷–循环垃圾">基于引用计数的缺陷–循环垃圾</h3>
<ul>
<li>三个对象相互引用，没有来自外部的指针，又不是根集成员，都是垃圾，但是引用计数都大于 0</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231130102743011.png" alt="image-20231130102743011" style="zoom:50%;" />
<h3 id="基于跟踪的垃圾回收">基于跟踪的垃圾回收</h3>
<h4 id="标记-清扫式垃圾回收">标记-清扫式垃圾回收</h4>
<ul>
<li>一种直接的、全面停顿的算法</li>
<li>分成两个阶段
<ul>
<li>标记：从<strong>根集</strong>开始，跟踪并标记出所有的<strong>可达</strong>对象</li>
<li>清扫：遍历整个<strong>堆区</strong>，释放<strong>不可达</strong>对象</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231130103004161.png" alt="image-20231130103004161" style="zoom:50%;" />
<ul>
<li>若把<strong>数据对象</strong>看作<strong>结点</strong>、<strong>引用</strong>看作有向<strong>边</strong>，则标记的过程就是<u>从根集开始的<strong>图遍历</strong></u>过程</li>
<li>示例
<ul>
<li>假设X是全局变量，Y是当前函数的局部变量</li>
<li>函数返回后进行标记清扫
<ul>
<li>A, D, E, F, G, H, I可达</li>
<li>B, C不可达</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231130103235740.png" alt="image-20231130103235740" style="zoom: 50%;" />
<ul>
<li>优点
<ul>
<li>实现简单，无需移动对象(修改引用地址)</li>
</ul>
</li>
<li>缺点
<ul>
<li><strong>效率</strong>堪忧，清扫阶段总是需要遍历所有内存</li>
<li>易产生<strong>内存碎片</strong></li>
</ul>
</li>
</ul>
<h4 id="标记-拷贝式垃圾回收">标记-拷贝式垃圾回收</h4>
<ul>
<li>目标
<ul>
<li>只处理<strong>可达对象</strong>(减少回收时间)</li>
<li>将可达对象<strong>安排到一起</strong>(减少内存碎片)</li>
</ul>
</li>
<li>堆空间被分为两个半区
<ul>
<li>应用程序在某个半区内分配存储，当充满这个半区时，开始垃圾回收</li>
<li>回收时，复制可达对象到另一个半区(需修改引用地址)</li>
<li>回收完成后，两个半区角色对调</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231130103853271.png" alt="image-20231130103853271" style="zoom: 50%;" />
<ul>
<li>优点
<ul>
<li>只处理可达对象(减少回收时间)</li>
<li>将可达对象安排到一起(减少内存碎片)</li>
</ul>
</li>
<li>缺点
<ul>
<li>一半预留区域的内存无法使用</li>
</ul>
</li>
</ul>
<h4 id="标记-整理式垃圾回收">标记-整理式垃圾回收</h4>
<ul>
<li>对可达对象进行<strong>重定位</strong>可以消除存储碎片
<ul>
<li>与标记-复制法将对象移动到预留另一半区不同，标记-整理法<strong>把可达对象移动到堆区的一端</strong>，另一端则是空闲空间</li>
<li>空闲空间合并成单一块，提高分配内存时的效率</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231130104308582.png" alt="image-20231130104308582" style="zoom:50%;" />
<ul>
<li>算法的整个过程分成三个步骤：
<ul>
<li>标记(与前述算法相同)</li>
<li>计算新位置</li>
<li>移动并设置新的引用</li>
</ul>
</li>
</ul>
<h4 id="垃圾回收算法对比">垃圾回收算法对比</h4>
<ul>
<li>标记-清扫式垃圾回收
<ul>
<li>回收效率不高，易造成碎片</li>
</ul>
</li>
<li>标记-复制式垃圾回收
<ul>
<li>将可达对象复制到预留半区，只需遍历可达对象</li>
<li>管理区域内<strong>大部分对象为垃圾对象</strong>时效率高(只需移动少量可达对象)，反之则效率低</li>
</ul>
</li>
<li>标记-整理式垃圾回收
<ul>
<li>将可达对象移动到堆区的一端，需遍历整个区域</li>
<li>管理区域内<strong>大部分对象为可达对象</strong>时效率高(经过之前的整理、大部分对象已经到位)，反之则效率低</li>
</ul>
</li>
</ul>
<h3 id="分代式垃圾回收">分代式垃圾回收</h3>
<ul>
<li>对象生存<strong>周期特征</strong>
<ul>
<li>大多数对象刚创建不久后就不再使用(短命)</li>
<li>存在时间越长的对象，通常被回收的几率越小(命硬)</li>
</ul>
</li>
<li>根据生存周期，对对象<strong>分代管理</strong>
<ul>
<li>新创建的对象均放入年轻代区域(从幼年期开始)</li>
<li>年轻代空间不足时，对该区域执行回收(<strong>标记-复制</strong>)</li>
<li>熬过回收的对象<strong>移入下一区域</strong>(进化)</li>
<li>老年代空间不足时，对该区域执行回收(<strong>标记-整理</strong>)</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\6_运行时刻环境\image-20231130104749277.png" alt="image-20231130104749277" style="zoom: 67%;" />
<h2 id="总结">总结</h2>
<ul>
<li>内存空间布局
<ul>
<li>代码区、静态区、栈区、堆区</li>
</ul>
</li>
<li>栈区内存管理
<ul>
<li>活动记录：函数调用的核心数据结构</li>
<li>进入/返回函数的操作</li>
</ul>
</li>
<li>堆区内存管理
<ul>
<li>手动管理</li>
<li>自动管理(垃圾回收)</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/12/CF_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhangChengWei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Methods for DIP">
      <meta itemprop="description" content="paper analysis">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Methods for DIP">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/12/CF_2/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-02-12 17:28:06 / 修改时间：21:28:45" itemprop="dateCreated datePublished" datetime="2024-02-12T17:28:06+08:00">2024-02-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 编译原理：词法分析</span><br><span class="line">tags: [Interpolation]</span><br><span class="line">categories: [CF]</span><br><span class="line">description: &quot;...&quot;</span><br><span class="line">date: 2023-09-15 17:03:07</span><br></pre></td></tr></table></figure>
<h1>词法分析</h1>
<h2 id="词法分析的主要任务">词法分析的主要任务</h2>
<p>  从左向右逐行扫描源程序的字符，识别出各个单词，确定单词的类型。将识别出的单词转换成统一的机内表示——词法单元(token)形式</p>
<img src="/images/image-20231225111442342.png" alt="image-20231225111442342" style="zoom: 67%;" />
<h2 id="词法分析器的作用">词法分析器的作用</h2>
<h3 id="词法分析器的作用-2">词法分析器的作用</h3>
<ul>
<li>
<p>读入字符流，组成词素，输出<strong>词法单元序列</strong></p>
</li>
<li>
<p>过滤空白、换行、制表符、注释等</p>
</li>
<li>
<p>将词素添加到<strong>符号表</strong>中</p>
</li>
</ul>
<img src="/images/image-20231225111524461.png" alt="image-20231225111524461" style="zoom:50%;" />
<h3 id="独立的词法分析器">独立的词法分析器</h3>
<ul>
<li>
<p>简化编译器的设计</p>
<ul>
<li>词法分析器可以首先完成一些简单的处理工作</li>
</ul>
</li>
<li>
<p>模块化设计，增强编译器的可移植性</p>
</li>
</ul>
<h3 id="重点名词解释">重点名词解释</h3>
<ul>
<li>
<p>词法单元 token</p>
<ul>
<li>
<p>&lt;词法单元名(类型)、属性值(可选)&gt;</p>
</li>
<li>
<p>单元名是表示词法单位<strong>种类</strong>的抽象符号，<br>
语法分析器通过单元名即可<strong>确定词法单元序列的结构</strong></p>
</li>
<li>
<p>属性值通常用于语义分析之后的阶段</p>
<ul>
<li>
<p>一个模式匹配多个词素时，必须通过<strong>属性</strong>来传递附加的信息</p>
<ul>
<li>属性值将被用于语义分析、代码生成等阶段</li>
</ul>
</li>
<li>
<p>不同的目的需要不同的属性</p>
<ul>
<li>属性值通常是一个<strong>结构化数据</strong>（包含多种信息）</li>
</ul>
</li>
<li>
<p>如词法单元id的属性</p>
<ul>
<li>id内容、类型、第一次出现的位置、 …</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>模式 pattern</p>
<ul>
<li>描述了一类词法单元的词素可能具有的形式</li>
</ul>
</li>
<li>
<p>词素 lexeme</p>
<ul>
<li>
<p><strong>源程序中的字符序列</strong></p>
</li>
<li>
<p>和某个词法单元的模式匹配，被词法分析器识别为该词法单元的实例</p>
</li>
</ul>
</li>
<li>
<p>例：</p>
</li>
</ul>
<img src="/images/image-20231225111627134.png" alt="image-20231225111627134" style="zoom: 70%;" />
<h2 id="词法单元的规约-正则表达式">词法单元的规约(正则表达式)</h2>
<h3 id="串和语言">串和语言</h3>
<ul>
<li>
<p><strong>字母表</strong></p>
<ul>
<li>
<p>一个有穷的符号集合，如字母、数字、标点等</p>
</li>
<li>
<p>如{0,1}，ASCII，Unicode</p>
</li>
<li>
<p>任意的<strong>有限</strong>集合都可看作字母表</p>
</li>
</ul>
</li>
<li>
<p><strong>串</strong></p>
<ul>
<li>
<p>字母表中符号的<strong>有穷序列</strong></p>
</li>
<li>
<p>|s|：串s的长度，指s中符号出现的次数(即长度)</p>
<ul>
<li>空串：长度为0的串， ε</li>
</ul>
</li>
<li>
<p>其他术语</p>
<ul>
<li>
<p>前缀</p>
<ul>
<li>从串的尾部删除<strong>0个或多个</strong>符号后得到的串</li>
</ul>
</li>
<li>
<p>后缀</p>
<ul>
<li>从串的开始处删除<strong>0个或多个</strong>符号后得到的串</li>
</ul>
</li>
<li>
<p><strong>子串</strong></p>
</li>
<li>
<p>删除串的<strong>某个前缀</strong>和<strong>某个后缀</strong>得到的串</p>
</li>
</ul>
</li>
<li>
<p>真前缀、真后缀、真子串</p>
<ul>
<li>不等于<strong>原串</strong>，也<strong>不等于空串</strong>的前缀、后缀、子串</li>
</ul>
</li>
<li>
<p><strong>子序列</strong></p>
<ul>
<li>从原串中删除0个或者多个符号后得到的串</li>
</ul>
</li>
<li>
<p>串的运算</p>
<ul>
<li>
<p>连接：x和y连接即将y附加到x后面，记作xy</p>
</li>
<li>
<p>幂运算：x^0 = ε，s^1 = s, x^i = s^(i-1) * s</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>语言</strong></p>
<ul>
<li>
<p>某个给定字母表上的<strong>串的可数集合</strong></p>
</li>
<li>
<p>语言的运算</p>
</li>
</ul>
</li>
</ul>
<img src="/images/image-20231225111940054.png" alt="image-20231225111940054" style="zoom:50%;" />
<h3 id="语言上的运算">语言上的运算</h3>
<h3 id="正则表达式和正则定义">正则表达式和正则定义</h3>
<ul>
<li>
<p>正则表达式</p>
</li>
<li>
<p>高效简洁地描述处理词法单元时用到的<strong>模式类型</strong><br>
(给出字母、数位集合的名字，再用并、链接、闭包等运算来描述标识符)</p>
</li>
<li>
<p>字母表Σ上的正则表达式</p>
<ul>
<li>
<p>L® 表示<strong>正则表达式 r</strong> 所表达的语言</p>
</li>
<li>
<p>基本部分</p>
<ul>
<li>
<p>ε是一个正则表达式， L(ε) = {ε}</p>
</li>
<li>
<p>如果a是Σ上的一个 符号，那么a是正则表达式， L(a) = {a}</p>
</li>
</ul>
</li>
<li>
<p>归纳步骤</p>
<ul>
<li>
<p>选择： ®|(s)  &lt;=&gt;  L(®|(s)) = L® ∪ L(s)</p>
</li>
<li>
<p>连接： ®(s)  &lt;=&gt;  L(®(s)) = L®L(s)</p>
</li>
<li>
<p>闭包： ®*  &lt;=&gt;  L(  ®* ) = ( L® )*</p>
</li>
<li>
<p>括号： ®  &lt;=&gt;  L(®) = L®</p>
</li>
</ul>
</li>
<li>
<p><strong>优先级</strong></p>
</li>
<li>
<p>第一级：*<br>
第二级：连接<br>
第三级：|</p>
</li>
<li>
<p>正则语言：可以用一个正则表达式定义的语言</p>
</li>
</ul>
</li>
<li>
<p>正则定义</p>
<ul>
<li>
<p>正则定义是<strong>对正则表达式的命名</strong>，是如下形式的定义序列：</p>
</li>
<li>
<img src="/images/image-20231225112220767.png" alt="image-20231225112220767" style="zoom:50%;float:left" />
</li>
<li>
<p>d~i~不在Σ中，且各不相同</p>
</li>
<li>
<p>每个r~i~是字母表Σ ∪ {d~1~, d~2~, …, d~i-1~}上的正则表达式，保证了不会出现递归定义</p>
</li>
<li>
<p>C语言标识符的正则定义</p>
<ul>
<li>
<p>letter_ → A | B | … | Z | a | b | … | z |</p>
</li>
<li>
<p>digit → 0 | 1 | … | 9</p>
</li>
<li>
<p>id → letter_ ( letter_ | digit )*</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="正则表达式的扩展">正则表达式的扩展</h3>
<ul>
<li>
<p>使正则表达式更简洁，但不会使其描述能力增强</p>
</li>
<li>
<p>扩展的运算符</p>
<ul>
<li>
<p>一个或多个实例：单目后缀 +</p>
</li>
<li>
<p>零个或一个实例：？</p>
</li>
<li>
<p>字符类</p>
<ul>
<li>
<p>[a~1~a~2~…a~n~]等价于a~1~ | a~2~ | … | a~n~</p>
</li>
<li>
<p>符号，如：[a-e]等价于a | b | c | d | e</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="词法单元识别">词法单元识别</h3>
<ul>
<li>
<p>词法分析器要求能够<strong>检查输入字符串</strong>，在其<strong>前缀</strong>中找出和某个模式匹配的词素</p>
</li>
<li>
<p>通过正则定义来描述各种词法单元的模式</p>
</li>
<li>
<p>定义ws → (blank | tab | newline)+ 来消除空白</p>
<ul>
<li>当词法分析器<strong>识别出</strong>这个模式时，<strong>不返回词法单元</strong>， 继续识别其它模式</li>
</ul>
</li>
</ul>
<h2 id="词法单元的识别-状态转换图">词法单元的识别(状态转换图)</h2>
<p><strong>状态转换图是词法分析器的重要组件之一</strong></p>
<ul>
<li>
<p>点[状态]：表示在识别词素时可能出现的情况</p>
<ul>
<li>
<p>状态看作是<strong>已处理部分</strong>的总结[lexemeBegin指针和forward指针之间的串]</p>
</li>
<li>
<p>开始状态 (初始状态)：用Start边表示</p>
</li>
<li>
<p>某些状态为接受状态/最终状态，表明已找到词素</p>
</li>
<li>
<p>加上*的接受状态表示最后读入的符号不在词素中</p>
</li>
</ul>
</li>
<li>
<p>边[转换]：从一个状态指向另一个状态</p>
<ul>
<li>
<p>边的标号是一个或多个符号</p>
</li>
<li>
<p>当前状态为s，下一个输入符号为a，就沿着从s离开，标号为a的边到达下一个状态</p>
</li>
</ul>
</li>
<li>
<p>例：注意，*号表示将最后读入的other字符“吐出”</p>
</li>
</ul>
<img src="/images/image-20231225112708998.png" alt="image-20231225112708998" style="zoom:50%;" />
<h3 id="保留字和标识符的识别">保留字和标识符的识别</h3>
<ul>
<li>
<p>识别标识符的状态转换图也会<strong>识别保留字</strong></p>
</li>
<li>
<p>解决方法</p>
<ol>
<li>在<strong>符号表中先填保留字</strong> ，指明不是普通标识符</li>
<li>为保留字建立独立的、 <strong>高优先级的状态转换图</strong></li>
</ol>
</li>
</ul>
<img src="/images/image-20231225112845280.png" alt="image-20231225112845280" style="zoom:50%;" />
<h2 id="词法分析器的体系结构">词法分析器的体系结构</h2>
<ul>
<li>
<p>从转换图构造词法分析器的方法</p>
<ul>
<li>
<p>变量state记录当前状态</p>
</li>
<li>
<p>一个switch根据state的值转到相应的代码</p>
</li>
<li>
<p>每个状态对应于一段代码</p>
<ul>
<li>这段代码根据读入的符号，确定下一个状态</li>
<li>如果找不到相应的边，则调用fail进行错误恢复</li>
<li>进入某个接受状态时，返回相应的词法单元</li>
</ul>
</li>
</ul>
</li>
<li>
<p>注意状态有*标记时，需要回退forward指针</p>
</li>
</ul>
<img src="/images/image-20231225113039850.png" alt="image-20231225113039850" style="zoom: 45%;" />
<h2 id="词法分析器生成工具及设计">词法分析器生成工具及设计</h2>
<h3 id="Lex-Flex">Lex/Flex</h3>
<ul>
<li>核心：将<strong>输入的模式</strong>生成为<strong>状态转换图</strong>，并生成代码</li>
</ul>
<h3 id="Lex源程序的结构">Lex源程序的结构</h3>
<ul>
<li>
<p>声明部分</p>
<ul>
<li>
<p>常量：表示常数的标识符</p>
</li>
<li>
<p>正则定义</p>
</li>
</ul>
</li>
<li>
<p>转换规则</p>
<ul>
<li>
<p>模式 { 动作 }</p>
<ul>
<li>
<p>模式是正则表达式</p>
</li>
<li>
<p>动作表示识别到相应模式时应采取的处理方式</p>
</li>
<li>
<p>处理方式通常用是C语言代码表示</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>辅助函数</p>
<ul>
<li>各个动作中使用的函数</li>
</ul>
</li>
</ul>
<p>语法分析器调用getNextToken()函数，在其内会调用词法分析器这里的代码</p>
<h3 id="Lex中的冲突解决方式">Lex中的冲突解决方式</h3>
<ul>
<li>
<p>冲突：多个输入前缀与某个模式相匹配，或者一个前缀与多个模式匹配</p>
</li>
<li>
<p>多个前缀可能匹配时，选择最长的前缀</p>
<ul>
<li>比如，词法分析器把&lt;=当作一个词法单元识别</li>
</ul>
</li>
<li>
<p>某前缀和多个模式匹配时，选择列在前面的模式</p>
<ul>
<li>如果保留字的规则在标识符的规则之前，词法分析器将识别出保留字</li>
</ul>
</li>
</ul>
<h2 id="有穷自动机：从正则表达式到NFA">有穷自动机：从正则表达式到NFA</h2>
<ul>
<li>
<p>不确定的有穷自动机 <strong>NFA</strong></p>
<ul>
<li>边上的标号没有限制，<strong>一个符号可出现在离开同一个状态的多条边上</strong>，<strong>ε可以做标号</strong></li>
</ul>
</li>
<li>
<p>三个组成部分</p>
<ul>
<li>
<p>一个<strong>有穷的状态集合</strong>S</p>
<ul>
<li>
<p>S中的某个**状态s~0~**被指定为开始状态/初始状态(有些定义中可以有多个开始状态)</p>
</li>
<li>
<p>S的一个<strong>子集F</strong>被指定为接受状态集合</p>
</li>
</ul>
</li>
<li>
<p>一个<strong>输入符号字母表</strong>Σ</p>
</li>
<li>
<p>相应的<strong>转换函数</strong></p>
</li>
<li>
<p>对于每个状态和Σ ∪ {ε}中的符号，给出<strong>相应的后继状态集合</strong></p>
</li>
</ul>
</li>
<li>
<p>用二维表表示NFA转换函数</p>
<ul>
<li>
<p>每行对应于一个状态</p>
</li>
<li>
<p>每列对应于一个输入符号或者ε</p>
</li>
<li>
<p>每个条目表示对应的后继状态集合</p>
<ul>
<li>例：当处于状态0时，输入为a，则后继状态为0或1</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/image-20231225113914502.png" alt="image-20231225113914502" style="zoom:50%;" />
<ul>
<li>
<p>NFA接收的语言：从开始状态到达接受状态的<strong>所有可能路径的标号串</strong>的集合</p>
<ul>
<li>
<p>NFA接受的语言即为其接收的所有符号串的集合</p>
</li>
<li>
<p>注意’或’的表达方法，也可以0-2直接连接</p>
</li>
</ul>
</li>
<li>
<p>对于每个可以用正则表达式描述的语言，均可用某个NFA或DFA来识别；反之亦然</p>
</li>
</ul>
<h2 id="有穷自动机：从NFA到DFA">有穷自动机：从NFA到DFA</h2>
<ul>
<li>
<p>确定的有穷自动机DFA</p>
<ul>
<li>
<p>对于<strong>每个状态</strong>以及<strong>每个符号</strong>，<strong>有且只有一条边</strong>(或最多只有一条边)</p>
</li>
<li>
<p>NFA：易于从正则表达式转换（ε跳转）</p>
</li>
<li>
<p>DFA：可由NFA转换，便于机器高效模拟执行</p>
</li>
</ul>
</li>
<li>
<p>一个NFA被称为DFA，如果</p>
</li>
<li>
<p><strong>没有标号为ε</strong>的转换</p>
</li>
<li>
<p>对于每个状态s和每个输入符号a，<strong>有且仅有一条标号为a的离开s的边</strong></p>
</li>
<li>
<p>转换算法</p>
</li>
<li>
<p>基本规则部分（略）</p>
</li>
<li>
<p>归纳部分：</p>
</li>
</ul>
<img src="/images/image-20231225114710057.png" alt="image-20231225114710057" style="zoom:50%;" />
<ul>
<li>
<p>子集构造法</p>
</li>
<li>
<p>基本思想</p>
<ul>
<li>
<p>构造所得DFA的每个<strong>状态</strong>和NFA的<strong>状态子集</strong>对应</p>
</li>
<li>
<p>DFA读入a~1~, a~2~, …, a~n~后到达的状态对应于<br>
从NFA开始状态出发沿着a~1~, a~2~, …, a~n~可能到达的状态集合</p>
</li>
<li>
<p>在算法中“并行地模拟”NFA在遇到一个给定输入串时可能执行的所有动作</p>
</li>
<li>
<p>理论上，最坏情况下DFA的状态个数会是NFA状态个数的指数多个（幂集，2^n），但对于大部分应用，NFA和相应的DFA的状态数量大致相同</p>
</li>
</ul>
</li>
<li>
<p><strong>基本操作</strong></p>
<ul>
<li>
<p><strong>ε-closure(s)</strong></p>
<ul>
<li>从NFA状态s开始，<strong>只通过ε转换</strong>能到达的NFA状态集合</li>
</ul>
</li>
<li>
<p>ε-closure(T)</p>
<ul>
<li>枚举T中所有状态，从某个状态s开始，<strong>只通过ε转换</strong>能到达的NFA状态集合</li>
</ul>
</li>
<li>
<p>mova(T,a)</p>
<ul>
<li>枚举T中所有状态，从某个状态s出发， <strong>只通过一个标号为a的转换</strong>能到达的NFA状态集合</li>
</ul>
</li>
<li>
<p>Dstates</p>
<ul>
<li>DFA状态，每个元素对应一个NFA状态集合</li>
</ul>
</li>
<li>
<p><strong>Dtran</strong></p>
</li>
<li>
<p>DFA状态转换表：<strong>先move，再ε-closure</strong></p>
</li>
<li>
<p>Dtran[A,a]=ε-closure(move(A,a))</p>
</li>
</ul>
</li>
</ul>
<img src="/images/image-20231225123224432.png" alt="image-20231225123224432" style="zoom:50%;" />
<ul>
<li>
<p><strong>DFA状态数量的最小化</strong></p>
</li>
<li>
<p>DFA状态越少，空间效率越高</p>
</li>
<li>
<p>一个正则语言可对应于多个识别此语言的DFA</p>
</li>
<li>
<p>通过DFA的最小化可得到<strong>状态数量最少</strong>的DFA</p>
</li>
<li>
<p>状态的区分</p>
<ul>
<li>
<p>状态的<strong>可区分</strong></p>
<ul>
<li>
<p>如果存在串x，使得从状态s1和s2，一个<strong>到达接受状态</strong>而另一个到达非接受状态，那么x就区分了s1和s2</p>
</li>
<li>
<p>如果存在某个串区分了s和t，则s和t是可区分的，否则它们是不可区分的</p>
</li>
</ul>
</li>
<li>
<p>不可区分的两个状态就是<strong>等价</strong>的，可以<strong>合并</strong></p>
</li>
<li>
<p>必要不充分条件</p>
</li>
</ul>
</li>
<li>
<p>DFA最小化算法</p>
</li>
<li>
<p>基本思想</p>
<ul>
<li>把所有可区分的状态分开</li>
</ul>
</li>
<li>
<p>划分部分</p>
<ul>
<li>
<p>设置初始划分</p>
<ul>
<li>π = { S - F , F }</li>
</ul>
</li>
<li>
<p>迭代，枚举字母表，不断划分等价类</p>
</li>
<li>
<p>如果 π(new) == π，令 π(final) = π，算法完成；否则π = π(new)，转步骤2</p>
<ul>
<li>注意S-F=F时</li>
</ul>
</li>
</ul>
</li>
<li>
<p>构造部分</p>
<ul>
<li>
<p>在 π(final)的每个组中选择一个状态作代表，作为最小化DFA中的状态</p>
<ul>
<li>
<p>开始状态就是包含原开始状态的组的代表</p>
</li>
<li>
<p>接受状态就是包含原接受状态的组的代表(这个组一定只包含接受状态)</p>
</li>
<li>
<p>转换关系构造</p>
<ul>
<li>如果s是G的代表，而原DFA中s在a上的转换到达t，且t所在组的代表为r，那么最小化DFA中有从s到r的在a上的转换</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/images/image-20231225123504491.png" alt="image-20231225123504491" style="zoom:50%;" />
<h2 id="自动机到词法分析器">自动机到词法分析器</h2>
<ul>
<li>
<p>正则表达式：识别单个模式</p>
</li>
<li>
<p>词法分析器：识别<strong>多种模式</strong></p>
<ul>
<li>关键字、运算符、标识符、数字…</li>
</ul>
</li>
<li>
<p>NFA合并方法</p>
<ul>
<li>引入新的开始状态，并引入<strong>从该开始状态到各个原开始状态的ε转换</strong></li>
<li>得到的NFA所接受的语言是原来各个NFA语言的<strong>并集</strong></li>
<li>不同的接受状态代表不同的模式</li>
</ul>
</li>
</ul>
<img src="/images/image-20231225123622053.png" alt="image-20231225123622053" style="zoom:50%;" />
<img src="/images/image-20231225123739380.png" alt="image-20231225123739380" style="zoom:52%;" />
<h3 id="词法分析器状态的最小化">词法分析器状态的最小化</h3>
<ul>
<li>基本思想和DFA最小化算法相同</li>
<li>差别
<ul>
<li>词法分析器中的<strong>接受状态</strong>对应于<strong>不同的模式</strong></li>
<li>对应不同模式的接受状态<strong>一定是不等价的</strong></li>
<li>初始划分为
<ul>
<li>所有非接受状态集合 + 对应各模式的接受状态集合</li>
</ul>
</li>
</ul>
</li>
<li>其余划分和构造的方法均相同</li>
<li>接受状态对应的模式就是原来的模式</li>
</ul>
<img src="/images/image-20231225123939500.png" alt="image-20231225123939500" style="zoom:50%;" />

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/12/CF_3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhangChengWei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Methods for DIP">
      <meta itemprop="description" content="paper analysis">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Methods for DIP">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/12/CF_3/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-12 17:28:06" itemprop="dateCreated datePublished" datetime="2024-02-12T17:28:06+08:00">2024-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-05 23:59:29" itemprop="dateModified" datetime="2024-01-05T23:59:29+08:00">2024-01-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>语法分析</h1>
<h2 id="语法分析作用">语法分析作用</h2>
<ul>
<li>
<p>语法分析器从词法分析器输出的<strong>token序列</strong>中识别出各类<strong>短语</strong>，并<strong>构造语法分析树</strong></p>
</li>
<li>
<p>语法分析树描述了句子的<strong>语法结构</strong></p>
</li>
</ul>
<img src="D:\Typora_picture\3_语法分析\48c2199598949353ab1ee6d3760d5bd.png" alt="48c2199598949353ab1ee6d3760d5bd" style="zoom: 30%;" />
<h2 id="语法分析器">语法分析器</h2>
<h3 id="基本作用">基本作用</h3>
<img src="D:\Typora_picture\3_语法分析\1697094343848.jpg" alt="1697094343848" style="zoom:50%;" />
<ul>
<li>
<p>从词法分析器获得<strong>词法单元的序列</strong>，确认该序列是否可以由语言的文法生成</p>
</li>
<li>
<p>对于语法错误的程序，<strong>报告错误</strong>信息</p>
</li>
<li>
<p>对于语法正确的程序，生成<strong>语法分析树</strong> (简称语法树)(通常产生抽象语法树(AST))</p>
</li>
</ul>
<h3 id="分类">分类</h3>
<ul>
<li>
<p>通用的</p>
<ul>
<li>
<p>对任意文法做语法分析</p>
</li>
<li>
<p>效率很低</p>
</li>
<li>
<p>不能用于编译器产品</p>
</li>
</ul>
</li>
<li>
<p>非通用的（专用）</p>
<ul>
<li>
<p>自顶向下：从顶（根节点）向底部（叶子）构造语法分析树</p>
</li>
<li>
<p>自底向上：从叶子逐渐向根节点构造语法分析树</p>
</li>
<li>
<p>只能处理某些文法子类，但已经足够描述现代编程语言的大部分语法</p>
</li>
</ul>
</li>
</ul>
<h2 id="上下文无关文法CFG-BNF">上下文无关文法CFG/BNF</h2>
<h3 id="总体概述">总体概述</h3>
<img src="D:\Typora_picture\3_语法分析\907ae7231e12edc569aa6583539c3de.png" alt="907ae7231e12edc569aa6583539c3de" style="zoom: 20%;" />
<p>程序设计语言构造的语法可使用上下文无关文法或BNF表示法来描述</p>
<ul>
<li>
<p>文法可给出精确易懂的语法规则</p>
</li>
<li>
<p>可以自动构造出某些类型的文法的语法分析器</p>
</li>
<li>
<p>文法指出了语言的结构，有助于进一步的语义处理/代码生成</p>
</li>
<li>
<p>支持语言的演化和迭代</p>
</li>
</ul>
<p><strong>上下文无关文法定义</strong></p>
<ul>
<li>
<p><strong>终结符号</strong>：组成串的基本符号(词法单元名字)(语法树的叶子节点)</p>
<p>​					一般就是<strong>不在产生式头的符号</strong>。</p>
</li>
<li>
<p><strong>非终结符号</strong>：表示串的集合的语法变量，一般就是<strong>各产生式头</strong>的符号。</p>
<ul>
<li>
<p>在程序设计语言中通常对应于某个程序构造，比如stmt (语句)</p>
</li>
<li>
<p>给出语言的层次结构，是语法分析和翻译的关键</p>
</li>
</ul>
</li>
<li>
<p><strong>产生式</strong>：<br>
描述将终结符号和非终结符号组成串的方法</p>
<ul>
<li>
<p>形式：头(左)部 → 体(右)部</p>
<ul>
<li>如：expression → expression + term</li>
</ul>
</li>
<li>
<p><strong>头部是一个非终结符号</strong>，右部是一个<strong>符号串</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>起始符号</strong>：某个被指定的非终结符号(语法树的根节点)</p>
<ul>
<li>起始符号对应的串的集合就是文法的语言</li>
</ul>
</li>
</ul>
<p>示例：</p>
<ul>
<li>终结符号： id, +, –, *, /, (, )</li>
<li>非终结符号：expression (表达式), term (项), factor (因子)</li>
<li>起始符号： expression</li>
<li>产生式集合(下图)</li>
</ul>
<img src="D:\Typora_picture\3_语法分析\1697094505776.jpg" alt="1697094505776" style="zoom: 68%" />
<img src="D:\Typora_picture\3_语法分析\image-20231225170330842.png" alt="image-20231225170330842" style="zoom:70%;" />
<ul>
<li>
<p>文法简写(右图)</p>
<ul>
<li>
<p>E：expression     T：term     F：factor</p>
</li>
<li>
<p><strong>| 是元符号</strong> (文法描述中的符号，而不是文法符号)</p>
</li>
<li>
<p>(  和  ) 不是元符号，而是终结符</p>
</li>
</ul>
</li>
</ul>
<h3 id="符号表示的约定">符号表示的约定</h3>
<ul>
<li>
<p>终结符</p>
<ul>
<li>
<p>字母表<strong>排前</strong>的<strong>小写</strong>字母，如a、 b、 c</p>
</li>
<li>
<p><strong>运算</strong>符号，如+、 *等</p>
</li>
<li>
<p><strong>标点</strong>符号，如括号、逗号等。</p>
</li>
<li>
<p>数字<strong>0-9</strong></p>
</li>
<li>
<p><strong>黑体</strong>字符串，如id、 if，每个这样的字符串表示一个终结符号</p>
</li>
</ul>
</li>
<li>
<p>非终结符</p>
<ul>
<li>
<p>字母表排前的<strong>大写</strong>字母，如A、 B、 C</p>
</li>
<li>
<p>字母<strong>S</strong>，通常表示开始符号</p>
</li>
<li>
<p><strong>小写、斜体</strong>的名字，比如expr、 stmt</p>
</li>
<li>
<p>大写字母与用于表示代表程序构造的非终结符，如E、 T、 F通常表示表达式、项、因子</p>
</li>
</ul>
</li>
<li>
<p>文法符号(非终结符或终结符)</p>
<ul>
<li>字母表排后的大写字母（如X、 Y、 Z）</li>
</ul>
</li>
<li>
<p>(可能为空的)终结符号串</p>
<ul>
<li>字母表排后的小写字母（主要是u、 v、 …、 z）</li>
</ul>
</li>
</ul>
<h2 id="上下文无关文法的推导">上下文无关文法的推导</h2>
<h3 id="重要术语">重要术语</h3>
<ul>
<li>
<p>句型</p>
<ul>
<li>
<p>若S ⇒* 𝛼(经零或多步)， 那么𝛼就是<strong>文法S的句型</strong></p>
</li>
<li>
<p>可能既包含非终结符号，又包含终结符号，也可以是空串</p>
</li>
</ul>
</li>
<li>
<p>句子</p>
<ul>
<li>文法的句子就是只包含<strong>终结符号</strong>/空串的句型</li>
</ul>
</li>
<li>
<p>语言</p>
<ul>
<li>
<p>文法G的语言就是G的<strong>句子的集合</strong>，记为L(G)</p>
</li>
<li>
<p>从文法起始符号出发，推导到的所有句子的集合</p>
</li>
<li>
<p>w在L(G)中当且仅当w是G的句子</p>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\3_语法分析\image-20231225171040236.png" alt="image-20231225171040236" style="zoom: 50%;" />
<img src="D:\Typora_picture\3_语法分析\image-20231225170916942.png" alt="image-20231225170916942" style="zoom:50%;" />
<h3 id="从文法开始符号S-推导-出词串w的过程">从文法开始符号S 推导 出词串w的过程</h3>
<ul>
<li>
<p>根据给定的文法，识别输入句子中的各类短语</p>
</li>
<li>
<p>如果输入串的各个单词恰好自左至右地位于分析树的各个叶节点上，那么该词串就是该语言的一个句子</p>
</li>
</ul>
<h3 id="推导">推导</h3>
<ul>
<li>
<p>将待处理的串中的某个<strong>非终结符号</strong>替换为这个非终结符号的某个<strong>产生式的体(右部)</strong></p>
</li>
<li>
<p>从<strong>起始符号</strong>出发，不断进行上面的替换，就可以得到文法的不同句型</p>
  <img src="D:\Typora_picture\3_语法分析\1697094629495.jpg" alt="1697094629495" style="zoom: 33%;" />
<ul>
<li>“零步或多步”包括“一步”</li>
</ul>
</li>
</ul>
<p><img src="D:%5CTypora_picture%5C3_%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%5C1697094713205.jpg" alt="1697094713205"></p>
<ul>
<li>
<p>在这个例子中，id、()是终结符，E是非终结符</p>
<ul>
<li>
<p>替换当前句型中的哪个非终结符</p>
</li>
<li>
<p>用该非终结符的哪个候选式进行替换</p>
</li>
<li>
<p>显然，输入的<strong>短语</strong>是该语言的一个<strong>句子</strong>/<strong>句型</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="最左推导-自顶向下">最左推导(自顶向下)</h3>
<ul>
<li>
<p>总是选择每个句型的<strong>最左非终结符</strong>进行替换</p>
<ul>
<li>是最左推导的符号<img src="D:\Typora_picture\3_语法分析\image-20231225171226509.png" alt="image-20231225171226509" style="zoom: 50%;float:left" /></li>
</ul>
</li>
<li>
<p>例：</p>
<img src="D:\Typora_picture\3_语法分析\1697094729000.jpg" alt="1697094729000" style="zoom: 50%;" />
</li>
</ul>
<h3 id="最右推导-自底向上">最右推导(自底向上)</h3>
<ul>
<li>总是选择每个句型的<strong>最右非终结符</strong>进行替换</li>
</ul>
<h3 id="语法分析树">语法分析树</h3>
<ul>
<li>推导的图形表示形式
<ul>
<li><strong>根结点</strong>的标号是文法的<strong>起始符号</strong></li>
<li>每个叶子结点的标号是非终结符号、终结符号或ε</li>
<li>每个内部结点的标号是非终结符号</li>
<li>每个内部结点表示某个产生式的一次<strong>应用</strong>
<ul>
<li>结点的标号为产生式头，其子结点从左到右是产生式的体</li>
</ul>
</li>
</ul>
</li>
<li>树的<strong>叶子</strong>组成的<strong>序列</strong>是根的文法符号的一个<strong>句型</strong></li>
<li>一棵语法分析树可对应多个推导序列
<ul>
<li>但只有<strong>唯一的最左推导及最右推导</strong></li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\3_语法分析\image-20231225171544811.png" alt="image-20231225171544811" style="zoom:50%;" />
<h2 id="设计文法">设计文法</h2>
<h3 id="词法分析与语法分析">词法分析与语法分析</h3>
<img src="D:\Typora_picture\1697094805833.jpg" alt="1697094805833" style="zoom:33%;" />
<ul>
<li>
<p><strong>上下文无关文法</strong>比正则表达式的能力更强</p>
</li>
<li>
<p>所有的正则语言都可以使用文法描述</p>
</li>
<li>
<p>但一些用文法描述的语言不能用正则表达式描述<br>
- 有穷自动机不能无穷计数</p>
</li>
<li>
<p>依旧需要正则表达式</p>
<ul>
<li>
<p>正则表达式更加简洁、易于理解</p>
</li>
<li>
<p>根据正则表达式自动构造的词法分析器的效率高</p>
</li>
</ul>
</li>
</ul>
<p>文法能够描述程序设计语言的大部分语法：</p>
<ul>
<li>
<p>但不是“全部”</p>
<ul>
<li>如，“标识符的先声明后使用”无法用CFG描述</li>
</ul>
</li>
<li>
<p>因此语法分析器接受的语言是程序设计语言的 超集 ；必须通过 语义分析 来剔除一些符合文法、但不合法的程序</p>
</li>
</ul>
<img src="D:\Typora_picture\1697094828282.jpg" alt="1697094828282" style="zoom:50%;" />
<p>在进行高效的语法分析前，对文法的处理：</p>
<ul>
<li><strong>消除二义性</strong>
<ul>
<li>
<p>如果一个文法可以为某个句子生成多棵语法分析树，这个文法就是二义的</p>
</li>
<li>
<p>消除二义性的惯用技术： <strong>分层</strong></p>
<ul>
<li>
<p>改造文法，对于引发二义性的多种推导处于文法同一层的情况，将<strong>真正想要的推导</strong>提取出来，放到<strong>更深的层次</strong></p>
</li>
<li>
<p>最左推导中，更深层的非终结符总会被优先替换</p>
</li>
<li>
<p>确保只有一种最左推导，消除二义性</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\3_语法分析\image-20231225172204357.png" alt="image-20231225172204357" style="zoom:50%;" />
<ul>
<li>
<p>==<strong>消除左递归</strong>（重点）==</p>
<ul>
<li>左递归：文法中一个非终结符号A，对某个串α，存在一个推导 A =&gt; Aα</li>
<li>见下</li>
</ul>
</li>
<li>
<p>提取左公因子</p>
<ul>
<li>将产生式体中 | 的左公因子提取出来，将其他非公因子放到更深的层次</li>
</ul>
</li>
</ul>
<h2 id="语法分析技术-自顶向下">语法分析技术-自顶向下</h2>
<h3 id="为输入串构造语法分析树">为输入串构造语法分析树</h3>
<img src="D:\Typora_picture\1697094935922.jpg" alt="1697094935922" style="zoom: 50%;" />
<ul>
<li>
<p>从分析树的根结点（即文法的起始符号）开始，自顶向下，按照先根次序，深度<br>
优先地创建各个结点</p>
</li>
<li>
<p>对应于最左推导</p>
</li>
<li>
<p>关键步骤：应用产生式创建新的子结点</p>
</li>
<li>
<p>例：</p>
<ul>
<li>输入串: id+id，</li>
<li>文法：<br>
𝐸 → 𝐸 + 𝑇 | 𝑇<br>
𝑇 → 𝑇 ∗ 𝐹 | 𝐹<br>
𝐹 → 𝐸 | 𝐢𝐝</li>
</ul>
</li>
</ul>
<h3 id="递归下降的语法分析">递归下降的语法分析</h3>
<ul>
<li>
<p>每个非终结符号对应于一个 过程/函数，该过程负责<strong>扫描此非终结符号对应的结构</strong></p>
</li>
<li>
<p>程序执行从开始符号对应的过程开始</p>
<ul>
<li>当扫描整个输入串时宣布分析成功完成</li>
</ul>
</li>
<li>
<p>关键步骤：应用产生式</p>
<ul>
<li>
<p>A -&gt; X1 | X2 | X3 … 如何知道应用哪个产生式？</p>
</li>
<li>
<p>依次<strong>猜</strong>X1 、X2 、X3 …猜对结束，猜错回溯</p>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\1697095003731.jpg" alt="1697095003731" style="zoom: 33%;" />
<ul>
<li>
<p>例：</p>
<ul>
<li>
<p>文法：S -&gt; cAd 、A -&gt; ab | a<br>
输入串：cad<br>
证明：cAd是S的句子</p>
</li>
<li>
<p>调用函数S，选择S -&gt; cAd</p>
</li>
<li>
<p>输入中的c与句型中的c匹配，调用函数A</p>
</li>
<li>
<p>A选择A -&gt; ab，但b不匹配</p>
</li>
<li>
<p><strong>回溯并选择下一个产生式</strong>A -&gt; a，匹配，对函数A的调用返回到S的调用</p>
</li>
<li>
<p>S -&gt; cAd中最后的d与下一个输入d匹配，结束</p>
</li>
</ul>
</li>
<li>
<p>==<strong>左递归</strong>==</p>
<ul>
<li>
<p>如果一个文法中有非终结符号A使得 <strong>𝐴 +⇒ 𝐴𝛼</strong>，这个文法就是左递归的</p>
</li>
<li>
<p>直接左递归</p>
<ul>
<li>文法中存在一个形如<strong>𝐴 -&gt; 𝐴𝛼</strong>的产生式</li>
</ul>
</li>
<li>
<p>自顶向下的语法分析技术不能处理左递归的情况，因此需要消除左递归，但是自底向上的技术可以处理左递归（如 LR 算法）</p>
</li>
</ul>
</li>
<li>
<p><strong>直接左递归的消除</strong></p>
<ul>
<li>
<p>==<strong>将直接左递归更换成下面形式：</strong>==</p>
<img src="D:\Typora_picture\1697095088924.jpg" alt="1697095088924" style="zoom: 50%;" />
<ul>
<li>最后，成为 由A生成的串以某个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">β_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>开头，然后跟上零个或多个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">α_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 的形式<br>
<img src="D:\Typora_picture\3_语法分析\image-20231225190325117.png" alt="image-20231225190325117" style="zoom:50%;" /></li>
</ul>
</li>
<li>
<p>示例：</p>
<ul>
<li>注意consume会一直消耗；注意边界判断</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\3_语法分析\image-20231221214835203.png" alt="image-20231221214835203" style="zoom:25%;" />
<img src="D:\Typora_picture\1697095153948.jpg" alt="1697095153948" style="zoom:33%;" />
<ul>
<li>
<p>直接左递归消除后还需要处理间接左递归</p>
</li>
<li>
<p>间接左递归</p>
<ul>
<li>也可以消除，这里不作要求</li>
</ul>
</li>
</ul>
<h3 id="基于预测的语法分析">基于预测的语法分析</h3>
<ul>
<li>
<p>为输入串构造语法分析树</p>
<ul>
<li>
<p>从分析树的根结点（即文法的起始符号）开始，按照<strong>先根次序</strong>，深度优先地创建<br>
各个结点</p>
</li>
<li>
<p>对应于<strong>最左</strong>推导</p>
</li>
</ul>
</li>
<li>
<p>基本步骤</p>
<ul>
<li>
<p>确定句型中<strong>最左边的非终结符号</strong>应用哪个产生式</p>
</li>
<li>
<p>然后对该产生式与输入符号进行匹配</p>
</li>
</ul>
</li>
<li>
<p>关键步骤</p>
<ul>
<li>
<p>A -&gt; X~1~ | X~2~ | X~3~ … 如何知道应用哪个产生式？</p>
</li>
<li>
<p>根据<strong>下一字符</strong>，预测正确的产生式，<strong>避免回溯</strong></p>
</li>
</ul>
</li>
<li>
<p>简介</p>
<ul>
<li>
<p>试图从开始符号推导出输入符号串</p>
</li>
<li>
<p>每次为最左边的非终结符号选择<strong>适当</strong>的产生式</p>
</li>
<li>
<p>当两个产生式具有<strong>相同前缀</strong>时</p>
<ul>
<li>提取公因子的文法变换</li>
</ul>
</li>
</ul>
</li>
<li>
<p>提取公因子的文法变换</p>
<ul>
<li>
<p>输入：文法G</p>
</li>
<li>
<p>输出：等价地<strong>提取了左公因子</strong>的文法</p>
</li>
<li>
<p>方法：对于每个非终结符号A，找出它的两个或多个可选产生式体之间的最长公共前缀，将它们提取出来</p>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\3_语法分析\image-20231225192226470.png" alt="image-20231225192226470" style="zoom: 67%;" />
<ul>
<li>
<p>==<strong>预测分析法：LL(k)</strong>==</p>
<ul>
<li>
<p>LL：left-to-right从左到右扫描、left-most最左推导</p>
</li>
<li>
<p>k：向前看k个符号(一般为1)</p>
</li>
<li>
<p>FIRST和FOLLOW</p>
<ul>
<li>
<p>简要证明</p>
<ul>
<li>当前句型是xAβ，输入是xa …，<br>
选择产生式A -&gt; α的必要条件是下列之一
<ul>
<li>
<p>𝛼 *⇒ 𝑎</p>
</li>
<li>
<p>𝛼 *⇒ 𝜖，且β以a开头，即某个句型中a跟在A之后</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如果按照这两个条件选择时能够保证唯一性，就可以避免回溯</p>
</li>
<li>
<p>==<strong>FIRST(α)</strong>==</p>
<ul>
<li>
<p>可以<strong>从α推导</strong>得到<strong>串的首符号</strong>的集合</p>
</li>
<li>
<p>如果𝛼 *⇒ 𝜖，那么 𝜖 也在FIRST(α)中</p>
</li>
<li>
<p>计算FIRST(X)</p>
<ul>
<li>
<p>X 是<strong>终结符号</strong>，那么**添加 **X</p>
</li>
<li>
<p>X 是<strong>非终结符号</strong>，且 X -&gt; Y~1~Y~2~…Y~k~ 是产生式</p>
<ul>
<li>
<p>如果 a 在FIRST(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)中，且 ε 在FIRST(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">Y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>), … , FIRST(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">Y_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>)中，那么也添加 a</p>
</li>
<li>
<p>如果 ε <strong>都</strong>在FIRST(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">Y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>), … ,FIRST(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">Y_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)中，那么添加ε</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">Y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的开头一定是X的开头，除非<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">Y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为空，此时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">Y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的开头一定是X的开头，以此类推……</p>
</li>
</ul>
</li>
<li>
<p>X是非终结符号且X -&gt; ε，那么也添加ε</p>
</li>
</ul>
</li>
<li>
<p>计算FIRST(X~1~X~2~…X~n~)</p>
<ul>
<li>
<p>加入FIRST(X~1~)中所有<strong>非ε符号</strong></p>
</li>
<li>
<p>若<strong>ε在</strong>FIRST(X~1~)中，加入FIRST(<strong>X~2~</strong>)中所有<strong>非ε</strong>符号</p>
</li>
<li>
<p>若ε在<strong>所有</strong>FIRST(X~i~)中，也<strong>加入ε</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>==<strong>FOLLOW(A)</strong>==</p>
<ul>
<li>
<p>可能在某些句型中<strong>紧跟在A右边</strong>的<strong>终结符号</strong>的集合</p>
<ul>
<li>例如：S -&gt; αAaβ，终结符号a ∈ FOLLOW(A)</li>
</ul>
</li>
<li>
<p>FOLLOW函数的意义</p>
<ul>
<li>
<p>如果A -&gt; α，当α =&gt; ε 时，FOLLOW(A)可以帮助我们选择恰当的产生式</p>
</li>
<li>
<p>例如：A -&gt; α，而b属于FOLLOW(A)，如果α =&gt; ε ，而当前输入符号是b，则可以选择A -&gt; α，因为A最终到达了ε，而且后面跟着b</p>
</li>
</ul>
</li>
<li>
<p>计算FOLLOW(S)</p>
<ul>
<li>
<p>将<strong>输入结束标记$<strong>加入</strong>FOLLOW(S)<strong>中（S是</strong>开始符号</strong>）</p>
</li>
<li>
<p>按照下面两个规则不断<strong>迭代</strong>，直到所有的FOLLOW集合都不再增长为止</p>
<ul>
<li>
<p>如果存在产生式A -&gt; α<strong>Bβ</strong>，那么**FIRST(β)**中所有非ε的符号都加入FOLLOW(<strong>B</strong>)中</p>
</li>
<li>
<p>如果存在一个产生式A -&gt; αB，或者A -&gt; αBβ且FIRST(β)包含ε，那么FOLLOW(<strong>A</strong>)中所有符号都加入FOLLOW(<strong>B</strong>)中</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>==<strong>LL(1)文法</strong>==</p>
<ul>
<li>
<p>对文法的任意两个产生式A -&gt; α | β</p>
<ul>
<li>
<p>不存在终结符号a使α和β都可推导出以a开头的串</p>
</li>
<li>
<p>α和β最多只有一个可推导出空串</p>
</li>
<li>
<p>若β可推导出空串，则α不能推导出以FOLLOW(A) 中任何<strong>终结符号开头</strong>的串</p>
</li>
</ul>
</li>
<li>
<p>等价于</p>
<ul>
<li>
<p><strong>FIRST(α)与FIRST(β)不相交</strong>(条件一、二)</p>
</li>
<li>
<p>如果 𝜖 ∈ 𝐹𝐼𝑅𝑆𝑇(𝛽) ，即𝛽 *⇒ 𝜖，那么<strong>FOLLOW(A)与FIRST(α)不相交</strong>；反之亦然(条件三)</p>
<ul>
<li>
<p>任何情况下只能选一个展开</p>
</li>
<li>
<p>a不是独立的，外部可能包括其他东西</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>示例：</p>
</li>
<li>
<p>==<strong>预测分析表构造算法</strong>==</p>
<ul>
<li>
<p>输入：文法G</p>
</li>
<li>
<p>输出：预测分析表</p>
<ul>
<li>
<p>二维表，非终结符 (行) × 终结符 (列) → 产生式</p>
</li>
<li>
<p>展开非终结符时，根据输入终结符选择相应产生式</p>
</li>
</ul>
</li>
<li>
<p>方法：对于文法G的每个产生式A -&gt; α</p>
<ul>
<li>
<p>对于FIRST(α)中的<strong>每个终结符号</strong>a，将<strong>A -&gt; α</strong>加入到**M[A, a]**中</p>
</li>
<li>
<p>如果<strong>ε</strong>在FIRST(<strong>α</strong>)，那么对于<strong>FOLLOW(A)<strong>中的</strong>每个符号b</strong>，将<strong>A -&gt; ε</strong>加入到**M[A, b]**中</p>
</li>
<li>
<p>最后在所有的<strong>空白条目</strong>中填入<strong>error</strong></p>
</li>
</ul>
</li>
<li>
<p>示例：</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\3_语法分析\1697096167034.jpg" alt="1697096167034" style="zoom: 33%;" />
<img src="D:\Typora_picture\3_语法分析\image-20231012153644474.png" alt="image-20231012153644474" style="zoom:33%;" />
<ul>
<li>
<p>LL(1)文法的递归下降分析</p>
<ul>
<li>
<p>递归下降语法分析程序由一组过程组成</p>
</li>
<li>
<p>每个非终结符号对应于一个过程，该过程负责扫描该非终结符号对应的结构</p>
</li>
<li>
<p>可以使用当前的输入符号来唯一地选择产生式</p>
</li>
<li>
<p>示例：A → X | Y | Z</p>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\3_语法分析\image-20231225201123239.png" alt="image-20231225201123239" style="zoom:50%;" />
<ul>
<li>
<p>非递归的预测分析</p>
<ul>
<li>
<p>递归下降分析的输入太大时，易导致(调用)栈溢出</p>
</li>
<li>
<p>可以用<strong>栈模拟</strong>递归过程，实现非递归的分析</p>
</li>
<li>
<p>在自顶向下分析的过程中，我们总是</p>
<ul>
<li>
<p>匹配掉句型中<strong>左边的所有终结符号</strong></p>
</li>
<li>
<p>对于<strong>最左边的非终结符号</strong>，选择适当的产生式<strong>展开</strong></p>
</li>
<li>
<p>匹配成功的终结符号不会再被考虑，因此只需要记住句型的余下部分，以及尚未匹配的输入终结符号串</p>
</li>
<li>
<p>由于展开的动作总是发生在余下部分的左端，我们可以用栈来存放这些符号</p>
</li>
</ul>
</li>
<li>
<p>分析时的处理过程</p>
<ul>
<li>
<p>初始化时，栈中仅包含<strong>开始符号S和$</strong></p>
</li>
<li>
<p>如果栈顶元素是<strong>终结符号</strong>，那么跟输入进行<strong>匹配</strong></p>
</li>
<li>
<p>如果栈顶元素是<strong>非终结符号</strong></p>
<ul>
<li>
<p>使用<strong>预测分析表</strong>来选择适当的<strong>产生式</strong></p>
</li>
<li>
<p>在栈顶用产生式右部替换产生式左部</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>预测分析算法</p>
<ul>
<li>初始化：输入缓冲区中为w$，栈中为S$，ip指向w的第一个符号</li>
<li>令X = 栈顶符号，ip指向输入符号a</li>
<li>不断执行第二步，直到要么报错，要么栈中为空</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\1697096505800.jpg" alt="1697096505800" style="zoom:33%;" />
<ul>
<li>示例
<ul>
<li>输入为id+id*id，预测表如下：</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\1697096541641.jpg" alt="1697096541641" style="zoom:50%;" />
<p>​									                         见PPT ch4-3的5-9页</p>
<img src="D:\Typora_picture\3_语法分析\image-20231225201836213.png" alt="image-20231225201836213" style="zoom:50%;" />
<h3 id="自顶向下语法分析的局限">自顶向下语法分析的局限</h3>
<ul>
<li>
<p>根据<strong>极为有限的信息</strong>预测 (猜) 产生式</p>
</li>
<li>
<p>能识别的文法有局限性</p>
<ul>
<li>
<p>需要改造文法消除左递归</p>
</li>
<li>
<p>改造后的文法不直观</p>
</li>
<li>
<p>生成的语法树不易理解和处理</p>
</li>
</ul>
</li>
</ul>
<h2 id="语法分析技术-自底向上">语法分析技术-自底向上</h2>
<h3 id="自底向上的语法分析">自底向上的语法分析</h3>
<ul>
<li>
<p>为一个输入串构造语法分析树的过程</p>
</li>
<li>
<p>从<strong>叶子</strong> (输入串中的<strong>终结符号</strong>，将位于分析树的底端) 开始，向上到达根结点</p>
<ul>
<li>在实际的语法分析过程中并不一定会构造出相应的分析树，但是用分析树的<br>
概念可以方便理解</li>
</ul>
</li>
<li>
<p>重要的自底向上语法分析的通用框架</p>
<ul>
<li><strong>移入-归约</strong> (shift-reduce)</li>
</ul>
</li>
<li>
<p>多种LR技术</p>
<ul>
<li>
<p>简单LR技术 (Simple LR)</p>
</li>
<li>
<p>向前看LR技术(Look-Ahead LR)</p>
</li>
<li>
<p>……</p>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\3_语法分析\image-20231225203823822.png" alt="image-20231225203823822" style="zoom:50%;" />
<h3 id="归约">归约</h3>
<ul>
<li>
<p>自底向上的语法分析过程可以看成是从<strong>串w归约为文法开始符号S</strong>的过程</p>
</li>
<li>
<p>归约步骤：一个与某<strong>产生式体</strong>匹配的特定<strong>子串</strong>被替换为该<strong>产生式头</strong>的非终结符号</p>
</li>
<li>
<p>归约过程等于一个反向最右推导</p>
</li>
</ul>
<img src="D:\Typora_picture\3_语法分析\image-20231225203859468.png" alt="image-20231225203859468" style="zoom:50%;" />
<h3 id="句柄">句柄</h3>
<ul>
<li><strong>最右句型</strong>(由<strong>最右推导</strong>或<strong>最左规约</strong>得到的句型)中和某个<strong>产生式体 (右部)<strong>相匹配的子串，对它的归约代表了该</strong>最右句型的最右推导</strong>的<strong>最后一步</strong></li>
<li>正式定义
<ul>
<li>
<p>在一个最右句型中，句柄<strong>右边只有终结符号</strong>（右边只有终结符号的不一定是句柄）</p>
</li>
<li>
<p>如果文法是无二义性的，那么 每个句型<strong>有且只有一个</strong>句柄</p>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\3_语法分析\image-20231225204124135.png" alt="image-20231225204124135" style="zoom: 45%;" />
<ul>
<li>自底向上分析的过程就是<strong>识别</strong>和<strong>归约句柄</strong>的过程</li>
<li>示例：
<ul>
<li>符号T并不是最右句型T*id~2~的句柄，因为若T替换为E，接下来不能进一步进行规约</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\3_语法分析\image-20231225204311159.png" alt="image-20231225204311159" style="zoom: 33%;" />
<h3 id="移入-归约分析技术">移入-归约分析技术</h3>
<ul>
<li>
<p>使用一个<strong>栈</strong>来保存归约/扫描移入的文法符号</p>
</li>
<li>
<p>栈中符号 (从底向上) 和待扫描的符号组成了一个<strong>最右句型</strong></p>
</li>
<li>
<p>开始时刻：栈中只包含$，而输入为w$</p>
</li>
<li>
<p>结束时刻：栈中为S$，而输入为$</p>
</li>
<li>
<p>在分析过程中，不断<strong>移入符号</strong>，并在<strong>识别到句柄时</strong>进行归约</p>
</li>
<li>
<p>句柄被识别时总是出现在栈的顶部</p>
</li>
<li>
<p>四种状态：</p>
<ul>
<li>移入：将下一个输入符号移入到栈顶</li>
<li>归约：将句柄归约为相应的非终结符号
<ul>
<li>句柄总是在栈顶</li>
<li>具体操作时<strong>弹出句柄</strong>，压入被归约到的<strong>非终结符号</strong></li>
</ul>
</li>
<li>接受：宣布分析过程成功完成</li>
<li>报错：发现语法错误，调用错误恢复子程序</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\3_语法分析\image-20231225205608369.png" alt="image-20231225205608369" style="zoom:50%;" />
<h3 id="LR语法分析技术">LR语法分析技术</h3>
<ul>
<li>
<p>LR(k)的语法分析概念</p>
<ul>
<li>
<p>L 表示<strong>最左扫描</strong>，R 表示<strong>反向</strong>构造出<strong>最右推导</strong></p>
</li>
<li>
<p>k 表示最多向前看 k 个符号</p>
</li>
</ul>
</li>
<li>
<p>当k增大时，相应的语法分析器的规模急剧增大</p>
</li>
<li>
<p>只考虑k &lt;= 1的情况</p>
</li>
</ul>
<h3 id="LR语法分析器的优点">LR语法分析器的优点</h3>
<ul>
<li>由<strong>表格驱动</strong>，虽然手工构造表格工作量很大，但表格可以自动生成</li>
<li>对于几乎所有的程序设计语言，只要写出上下文无关文法，就能够构造出识别该语言的LR语法分析器</li>
<li>最通用的<strong>无回溯</strong>移入-归约分析技术</li>
<li>能分析的文法比LL(k)文法<strong>更多</strong></li>
</ul>
<h3 id="LR语法分析思路">LR语法分析思路</h3>
<ul>
<li>
<p>核心任务：<strong>识别</strong>句柄，<strong>归约</strong>句柄</p>
</li>
<li>
<p>如何知道栈中内容可以归约了？</p>
<ul>
<li>维护一个<strong>状态</strong>，记录当前句柄识别的<strong>进度</strong></li>
</ul>
</li>
<li>
<p>==<strong>项</strong>==</p>
<ul>
<li>
<p>一个文法产生式加上在其中某处的<strong>一个点</strong></p>
<ul>
<li>
<p>A -&gt; ·XYZ，A -&gt; X·YZ，A -&gt; XY·Z，A -&gt; XYZ·</p>
</li>
<li>
<p>A -&gt; α·β表示<strong>已扫描/归约到了α</strong>，并<strong>期望</strong>在接下来的输入中经过扫描/归约<strong>得到β</strong>，然后<strong>把αβ归约到A</strong></p>
</li>
<li>
<p>A -&gt; αβ·表示<strong>已扫描/归约得到了αβ</strong>，可以把αβ归约为A</p>
</li>
<li>
<p>注意：A -&gt; ε只对应一个项A -&gt; ·</p>
</li>
</ul>
</li>
<li>
<p>一个项读入一个符号后，可变为另一个项</p>
<ul>
<li>
<p>A -&gt; ·xyz 读入x变为 A -&gt; x·yz，类似状态间的跳转</p>
</li>
<li>
<p>类似词法分析DFA的状态</p>
</li>
</ul>
</li>
<li>
<p>文法产生式是有限的，每个产生式右部的长度也是有限的</p>
<ul>
<li>项的数量也是有限的</li>
</ul>
</li>
<li>
<p>同一时刻只识别一个句柄，因此只需关注一个项</p>
<ul>
<li>有穷自动机，被称为LR(0)自动机</li>
</ul>
</li>
<li>
<p>项既表示过去（已扫描/归约的串） 也预示未来（想要扫描/归约的串）</p>
</li>
<li>
<p>识别句柄的过程中，可能有多个可选的产生式，因此可能同时满足多个项(同时处于多个状态：NFA)</p>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\1697097423695.jpg" alt="1697097423695" style="zoom:33%;" />
<ul>
<li>
<p>LR(0)项集规范族的构造</p>
<ul>
<li>
<p>==<strong>增广文法(引入起始状态)</strong>==</p>
<ul>
<li>
<p>G的增广文法G’是在G中<strong>增加新开始符号S’</strong>，并加入<strong>产生式S’ -&gt; S</strong>而得到的</p>
</li>
<li>
<p>显然G’和G接受相同的语言，且按照S’ -&gt; S进行归约实际上就表示已经将输入符号串归约成为开始符号</p>
</li>
<li>
<p>方便引入S的项，表示<strong>识别的起始(S’ -&gt; ·S)/结束(S’ -&gt; S·)</strong></p>
</li>
</ul>
</li>
<li>
<p>==<strong>项集闭包CLOSURE(状态机确定化)</strong>==</p>
<ul>
<li>
<p>根据一个项(状态)，扩充读取<strong>相同输入</strong>后可能<strong>同时处于的多个项(状态)</strong>–类似NFA的ε-CLOSURE</p>
</li>
<li>
<p>如果<strong>I</strong>是文法G的一个项集，**CLOSURE(I)**是根据下列两条规则从I构造得到的项集</p>
<ul>
<li>将<strong>I中的各项加入</strong>CLOSURE(I)中</li>
<li>如果A -&gt; α·Bβ在CLOSURE(I)中，而B -&gt; γ 是一个产生式，且项B -&gt; ·γ不在CLOSURE(I)中，就将该项加入其中，不断应用该规则到<strong>无新项可加入</strong></li>
</ul>
</li>
<li>
<p>意义</p>
<ul>
<li>A -&gt; α·Bβ，表示希望看到<strong>由Bβ推导出的串</strong>，那要先看到<strong>由B推导</strong>出的串，因此加上<strong>B的各个产生式</strong>对应的<strong>项</strong></li>
</ul>
</li>
<li>
<p>示例：</p>
<img src="D:\Typora_picture\3_语法分析\image-20231225210050155.png" alt="image-20231225210050155" style="zoom: 33%;" />
</li>
</ul>
</li>
<li>
<p>==<strong>GOTO函数(定义状态跳转)</strong>==</p>
<ul>
<li>
<p>I 是一个项集，X 是一个文法符号，则<strong>GOTO(I, X)<strong>定义为I中所有形如</strong>[A -&gt; α·Xβ]的项</strong>所对应的项**[A -&gt; αX·β]<strong>的集合的</strong>闭包**</p>
</li>
<li>
<p>示例：</p>
<img src="D:\Typora_picture\3_语法分析\image-20231225210528072.png" alt="image-20231225210528072" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p>求规范LR(0)项集族的算法</p>
<ul>
<li>从<strong>初始项集</strong>(增广文法的第一个产生式的第一个项)开始，不断计算各种可能的后继，直到生成所有的项集
<ul>
<li>输入：增广文法</li>
<li>输出：跳转表GOTO</li>
</ul>
</li>
</ul>
</li>
<li>
<p>LR(0)自动机的构造</p>
<ul>
<li>
<p>基于规范LR(0)项集族可以构造LR(0)自动机</p>
</li>
<li>
<p>规范LR(0)项集族中的每个<strong>项集</strong>对应于LR(0)自动机的一个状态</p>
</li>
<li>
<p><strong>状态转换</strong>：如果GOTO(I, X) = J，则从 I 到 J有一个标号为 X的转换</p>
</li>
<li>
<p><strong>开始状态</strong>为CLOSURE({ S’ -&gt; ·S })对应的项集</p>
</li>
</ul>
</li>
<li>
<p>LR(0)自动机的作用</p>
</li>
<li>
<p>示例：</p>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\3_语法分析\image-20231225210657269.png" alt="image-20231225210657269" style="zoom: 50%;" />
<ul>
<li>
<p>Simple LR 语法分析表的构造</p>
<ul>
<li>
<p>以LR(0)自动机为基础的SLR语法分析表构造算法</p>
<ul>
<li>
<p>构造增广文法G’的LR(0)项集规范族{I~0~, I~1~, …, I~n~}</p>
</li>
<li>
<p>状态i对应项集I~i~，相关的ACTION/GOTO表条目如下：</p>
<ul>
<li>[A → α·aβ]在Ii中，且GOTO(I~i~, a) = I~j~，则ACTION[i, a] = “移入j”</li>
<li>[A → α·]在Ii中，那么<strong>对FOLLOW(A)中所有a</strong>(注意这里对规约条件进行了约束)，ACTION[i, a] = “按A → α归约”</li>
<li>如果[S’ → S·]在I~i~中，那么将ACTION[i, $]设为&quot;<strong>接受</strong>&quot;</li>
<li>如果GOTO(I~i~, A) = I~j~，那么在GOTO表中，GOTO[i, A] = j</li>
</ul>
</li>
<li>
<p>空白的条目设为error</p>
</li>
<li>
<p>如果SLR分析表没有冲突，该文法就是SLR的</p>
</li>
<li>
<p>思想：把α规约成A，后面需是FOLLOW(A)中的终结符号，否则只能移入</p>
</li>
</ul>
</li>
<li>
<p>SLR语法分析器的弱点</p>
<ul>
<li>
<p>SLR技术解决冲突的方法</p>
<ul>
<li>项集中包含[A → α·]时，按照A → α进行归约的条件是下一个输入符号<br>
x可以在某个句型中跟在A之后</li>
</ul>
</li>
<li>
<p>如果此时对于x还有其它的移入/归约操作，则出现冲突</p>
</li>
</ul>
</li>
<li>
<p>假设此时栈中的符号串为βα</p>
<ul>
<li>如果βAx不是任何最右句型的前缀，那么即使x在某个句型中跟在A之后，仍不应该按A → α归约</li>
</ul>
</li>
<li>
<p>进行归约的条件更加严格可以降低冲突的可能性</p>
</li>
</ul>
</li>
<li>
<p>更强大的LR语法分析器</p>
<ul>
<li>
<p>规范LR方法</p>
<ul>
<li>
<p>添加项[A → ·α]时，把<strong>期望的向前看符号也加入项</strong>中，成为LR(1)项集</p>
</li>
<li>
<p>向前看符号(串)的长度即为LR(k)中的k</p>
</li>
<li>
<p>这个做法可以充分利用向前看符号，但是<strong>状态很多</strong></p>
</li>
</ul>
</li>
<li>
<p>向前看LR(LALR)</p>
<ul>
<li>
<p>基于LR(0)项集族，但<strong>每个LR(0)项都带有向前看符号</strong></p>
</li>
<li>
<p>分析能力<strong>强</strong>于SLR方法，且分析表和SLR分析表<strong>一样大</strong></p>
</li>
<li>
<p>LALR已经可以处理大部分的程序设计语言</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>LR(1)项</p>
<ul>
<li>
<p>LR(1)项中包含更多信息来<strong>消除</strong>一些归约动作</p>
</li>
<li>
<p>实际的做法相当于“分裂”一些LR(0)状态，<strong>精确指明</strong>何时应该<strong>归约</strong></p>
</li>
<li>
<p>LR(1)项的形式</p>
<ul>
<li>LR(1)项的形式[A → α·β, a]
<ul>
<li>
<p>a ∈FOLLOW(A)  ，称为<strong>向前看符号</strong>，可以是终结符号或者$</p>
</li>
<li>
<p>a表示如果将来要按照A → αβ进行归约，归约时的下一个输入符号必须是a</p>
</li>
<li>
<p>当 β 非空时，移入动作不考虑 a，a 传递到下一状态</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h2 id="LR-1-项和可行前缀">LR(1)项和可行前缀</h2>
</li>
<li>
<h2 id="LR-1-项的作用">LR(1)项的作用</h2>
</li>
</ul>
</li>
</ul>
<h2 id="语法分析器生成工具">语法分析器生成工具</h2>
<p>略</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/12/CF_4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhangChengWei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Methods for DIP">
      <meta itemprop="description" content="paper analysis">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Methods for DIP">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/12/CF_4/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-12 17:28:06" itemprop="dateCreated datePublished" datetime="2024-02-12T17:28:06+08:00">2024-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-02 20:51:58" itemprop="dateModified" datetime="2023-12-02T20:51:58+08:00">2023-12-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>语法制导</h1>
<h2 id="语义分析的任务">语义分析的任务</h2>
<p>1、在代码的声明语句中，会声明一些数据对象或过程并命名 -&gt; 标识符。语义分析就是<strong>收集标识符的属性信息</strong>，如==种属、类型、存储位置和长度、值、作用域、参数和返回值信息==，存于<strong>符号表</strong>中。</p>
<p>标识符往往存于字符串表中，故符号表的NAME字段存储其在字符串表中的起始位置与长度</p>
<p>2、语义分析的另一个任务，就是语义检查</p>
<ul>
<li>
<p>未经声明就使用</p>
</li>
<li>
<p>重复声明</p>
</li>
<li>
<p>类型不匹配</p>
</li>
<li>
<p>…</p>
</li>
</ul>
<h2 id="词法分析与语法分析后得到的信息">词法分析与语法分析后得到的信息</h2>
<p>输入程序通过了词法分析</p>
<ul>
<li>
<p>输入程序符合词法规则</p>
</li>
<li>
<p>过滤了注释、空白字符等无用信息</p>
</li>
<li>
<p>得到合法的符号流（合法的变量名、关键字…）</p>
</li>
</ul>
<p>输入程序通过了语法分析</p>
<ul>
<li>
<p>输入程序符合语法规则</p>
</li>
<li>
<p>得到合法的语法分析树</p>
</li>
</ul>
<p>语法分析技术不能检查语义</p>
<ul>
<li>
<p>语义分析往往与语法元素的上下文密切相关</p>
</li>
<li>
<p>完全相同的语句在不同上下文中可具有不同语义</p>
</li>
</ul>
<h2 id="语法制导：SDD与SDT概述">语法制导：SDD与SDT概述</h2>
<p><strong>语法制导的两个阶段</strong></p>
<ul>
<li>
<p>语法分析</p>
</li>
<li>
<p>语义翻译(语义分析、中间代码生成)</p>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231117224746499.png" alt="image-20231117224746499" style="zoom:50%;" />
<p>语法制导翻译使用<strong>上下文无关文法</strong>(CFG)来引导对语言的翻译，是一种面向文法的翻译技术</p>
<p><strong>语法制导翻译的基本思想</strong></p>
<ul>
<li>
<p>如何表示语义信息</p>
<ul>
<li>为CFG中的文法符号设置语义属性，用来表示语法成分对应的语义信息</li>
</ul>
</li>
<li>
<p>如何计算语义属性</p>
<ul>
<li>
<p>文法符号的语义属性值是与文法符号所在产生式(语法规则)相关联的语义规则来计算的</p>
</li>
<li>
<p>对于给定的输入串x，构建x的语法分析树，并利用与产生式(语法规则)相关联的语义规则来计算分析树中各结点对应的语义属性值</p>
</li>
</ul>
</li>
</ul>
<p><strong>SDD与SDT概述</strong></p>
<ul>
<li>
<p>语法制导定义（Syntax-directed definitions，SDD）</p>
<ul>
<li>简单来说，如果 X 是一个文法符号， a 是 X 的属性，则用 X.a 来表示属性 a 在分析树上的标号为 X 的节点的值，这样的文法就称为SDD</li>
</ul>
</li>
<li>
<p>语法制导翻译方案（Syntax-directed Translation Scheme，SDT）</p>
<ul>
<li>在产生式体中嵌入了<strong>称为语义动作的程序片段</strong>的CFG，对文法符号的属性值进行计算</li>
</ul>
</li>
<li>
<p>关系与区别</p>
<ul>
<li>SDD是关于语言翻译的高层次规格说明，隐藏了许多实现细节；</li>
<li>SDT可以看做是对SDD的一个补充，它显式地指明了<strong>语义规则的计算顺序</strong>，以便说明某些实现细节</li>
</ul>
</li>
</ul>
<p><strong>语法制导定义SDD</strong>(Syntax-Directed Definition)</p>
<ul>
<li>
<p>SDD是对CFG的推广</p>
<ul>
<li>
<p>将每个文法符号和一个语义属性集合相关联</p>
</li>
<li>
<p>将每个产生式和一组语义规则相关联，这些规则用于计算该产生式中各文法符号的属性值</p>
</li>
</ul>
</li>
<li>
<p>若X是一个文法符号，a是X的一个属性，则用X.a表示属性a在某个标号为X的分析树结点上的值</p>
</li>
</ul>
<p><strong>语法制导翻译方案SDT</strong></p>
<ul>
<li>
<p>SDT是在产生式右部嵌入了程序片段的CFG，这些程序片段称为语义动作，放在{}内</p>
</li>
<li>
<p>SDD的具体实施方案</p>
</li>
</ul>
<h2 id="语法制导SDD">语法制导SDD</h2>
<p><strong>SDD是 上下文无关文法 和 ==属性/规则== 的结合</strong></p>
<ul>
<li>
<p><strong>属性</strong>和<strong>文法符号</strong>相关联，按照需要来确定各个文法符号需要哪些属性</p>
</li>
<li>
<p><strong>规则</strong>和<strong>产生式</strong>相关联</p>
</li>
<li>
<p>SDD<strong>三要素</strong>：==文法、属性、规则==</p>
</li>
<li>
<p>属性可视为语义的具象化表示： 类型、 值、 名字、 地址……</p>
</li>
</ul>
<p><strong>对于文法符号X和属性a，我们用X.a表示分析树中某个标号为X的结点的值</strong></p>
<ul>
<li>
<p>一个分析树结点和它的分支对应一个产生式规则</p>
</li>
<li>
<p>对应的语义规则确定这些结点属性的<strong>取值和计算</strong></p>
</li>
<li>
<p>基于SDD， 我们可以在一个程序的分析树上进行语义信息的计算</p>
</li>
</ul>
<p><strong>示例1</strong>：</p>
<ul>
<li>产生式规则1：E → E1 + T<br>
<code>E.type = if (E1.type == T.type) T.type else float;</code></li>
<li>产生式规则2： F → id<br>
<code>F.type = lookupIDTable(id.name)-&gt;type;</code></li>
<li>产生式规则3： E → T<br>
<code>E.type = T.type;</code></li>
<li>产生式规则4： T → F<br>
<code>T.type = F.type;</code></li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231017102547500.png" alt="image-20231017102547500" style="zoom:50%;" />
<p>==<strong>综合属性</strong>==</p>
<ul>
<li>自底向上</li>
<li>节点N的属性值由<strong>N的产生式</strong>所关联的语义规则来定义</li>
<li>通过N的<strong>子节点</strong>或<strong>N本身</strong>的属性值来定义</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231017102835811.png" alt="image-20231017102835811" style="zoom: 50%;" />
<p>==<strong>继承属性</strong>==</p>
<ul>
<li>
<p>自顶向下</p>
</li>
<li>
<p>结点N的属性值由<strong>N的父节点</strong>所关联的语义规则来定义</p>
</li>
<li>
<p>依赖于<strong>N的父节点</strong>、<strong>N本身</strong>和<strong>N的兄弟节点</strong>上的属性值</p>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231017102852535.png" alt="image-20231017102852535" style="zoom:50%;" />
<h3 id="S属性的SDD">S属性的SDD</h3>
<ul>
<li>
<p>只包含<strong>综合属性</strong>的SDD称为<strong>S属性的SDD</strong></p>
<ul>
<li>每个语义规则都根据<strong>产生式体中的属性值</strong>来计算头部非终结符号的属性值</li>
</ul>
</li>
<li>
<p>S属性的SDD可以和LR语法分析器一起实现</p>
<ul>
<li>
<p>栈中的状态/文法符号可以<strong>附加相应的属性值</strong></p>
</li>
<li>
<p><strong>归约时</strong>，按照语义规则<strong>计算</strong>归约得到的符号的属性值</p>
</li>
</ul>
</li>
<li>
<p>语义规则一般不应该有复杂的副作用</p>
<ul>
<li>副作用不影响其它属性的求值</li>
<li>没有副作用的SDD称为属性文法</li>
<li>这样就便于语义信息的计算，每次可专注于当前的产生式</li>
</ul>
</li>
</ul>
<p><strong>示例2</strong>：</p>
<p>​	终结符号digit有综合属性lexval</p>
<p>​	产生式与语义规则如下：</p>
<img src="D:\Typora_picture\4_语法制导\image-20231017103157631.png" alt="image-20231017103157631" style="zoom:50%;" />
<ul>
<li>
<p>在依赖图中，总是通过<strong>子结点的属性值</strong>来计算<strong>父结点的属性值</strong>，可以与自底向上或自顶向下的<strong>语法分析过程</strong>一起计算</p>
<ul>
<li>自底向上：在构造分析树结点的同时计算相关的属性</li>
<li>自顶向下：在递归子程序法中，在过程A()的最后计算A的属性</li>
</ul>
</li>
<li>
<p>在分析树上计算SDD：</p>
<ul>
<li>按照<strong>后序遍历</strong>的顺序计算属性值即可</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">postorder(N)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (从左边开始，对N的每个子结点C)</span><br><span class="line">		postorder(C);</span><br><span class="line">	<span class="comment">// 递归调用返回时，各子结点的属性已计算完毕</span></span><br><span class="line">	对N的各个属性求值; <span class="comment">// N.a = … Ci.ai …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>S属性SDD的局限
<ul>
<li>S属性的SDD中每个属性都是综合属性</li>
<li>无法计算<strong>同时</strong>需要继承和综合属性的语义信息。如下例：
<ul>
<li><strong>id</strong>类型的确定需要<strong>兄弟节点</strong>先确定</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231017112244551.png" alt="image-20231017112244551" style="zoom:50%;" />
<h3 id="SDD的求值顺序">SDD的求值顺序</h3>
<ul>
<li>
<p><strong>注释语法分析树</strong></p>
<ul>
<li>
<p>包含了各个结点的各属性值的语法分析树</p>
</li>
<li>
<p>步骤：</p>
<ul>
<li>对于任意的输入串，首先构造出相应的<strong>分析树</strong></li>
<li>给各个结点 (根据其文法符号) <strong>加上相应的属性</strong></li>
<li>按照语义规则<strong>计算</strong>这些属性的值</li>
</ul>
</li>
<li>
<p>计算顺序</p>
<ul>
<li>
<p>如果某个结点N的属性a为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>N</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>N</mi><mi>k</mi></msub><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(N_1.b_1,…,N_k.b_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>， 那么我们需要先算出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>N</mi><mi>k</mi></msub><mi mathvariant="normal">.</mi><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">N_1.b_1,…, N_k.b_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值</p>
</li>
<li>
<p>S属性的SDD一定可以按照<strong>自底向上</strong>的方式求值</p>
</li>
<li>
<p><strong>循环依赖</strong>的SDD不可以计算</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>注释分析树示例：</p>
<ul>
<li>对于综合属性，因为依赖于子节点，所以很自然地，可以按照<strong>自下向上</strong>的文法分析方法获得val属性。在下面的注释语法分析树中我们可以看到，每个节点都关联了一个值。分析各个节点的属性的计算可以自下而上地完成。</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231017110729555.png" alt="image-20231017110729555" style="zoom:40%;" />
<img src="D:\Typora_picture\4_语法制导\image-20231117230329717.png" alt="image-20231117230329717" style="zoom:50%;" />
<ul>
<li>和<strong>终结符号</strong>的综合属性<strong>直接由词法分析器给出</strong>不同，<strong>非终结符号</strong>的综合属性和继承属性都或多或少地<strong>依赖于其他属性</strong>，因此确定一棵注释语法分析树中属性的求值顺序是十分重要的，我们可以使用<strong>依赖图</strong>来表示计算顺序
<ul>
<li>依赖图：描述了某棵特定的分析树上各个属性之间的<strong>信息流</strong>（计算顺序）
<ul>
<li>属性结点：对于每个结点 N，<strong>N 的每个属性</strong>在依赖图中都有一个<strong>结点</strong></li>
<li>综合属性的边：如果和产生式 p 关联的语义规则通过 X.a 的值定义了综合属性 Y.b 的值，那么在依赖图中有一条从 X.a 到 Y.b 的边；</li>
<li>继承属性的边：如果和产生式 p 关联的语义规则通过 X.a 的值定义了继承属性 Y.b 的值，那么在依赖图中有一条从 X.a 到 Y.b 的边</li>
</ul>
</li>
<li>值的计算顺序形成<strong>偏序关系</strong>，如果依赖图中出现<strong>环</strong>，表示属性值无法计算</li>
<li>各个属性值需要按照依赖图的<strong>拓扑顺序</strong>计算</li>
</ul>
</li>
</ul>
<h3 id="L属性的SDD">L属性的SDD</h3>
<ul>
<li>
<p>在一个产生式所关联的各属性之间，依赖图的边可以从左到右，但不能从右到左</p>
</li>
<li>
<p>==<strong>L-SDD的正式定义</strong>==：</p>
<ul>
<li>
<p>一个SDD是L-属性定义，当且仅当它的<strong>每个属性</strong>满足以下<strong>一个</strong>条件:</p>
<ul>
<li>
<p>是<strong>综合属性</strong>；</p>
</li>
<li>
<p>满足以下条件的<strong>继承属性</strong>：</p>
<ul>
<li>假设存在一个产生式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>−</mo><mo>&gt;</mo><msub><mi>X</mi><mn>1</mn></msub><msub><mi>X</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A-&gt;X_1X_2...X_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其右部符号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的继承属性仅依赖于以下属性：
<ul>
<li>
<p><strong>A <strong>的</strong>继承属性</strong>(而不是综合属性)；</p>
</li>
<li>
<p>X~i~ <strong>左边</strong>符号的属性；</p>
</li>
<li>
<p>X~i~ <strong>本身</strong>的属性（但Xi的全部属性不能成环）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>从语法分析树的角度看，当这些规则被应用于某个结点时，使用的信息“来自于<strong>上边或左边</strong>”的语法树结点。</p>
</li>
</ul>
</li>
<li>
<p>特点</p>
<ul>
<li>依赖图中的边：综合属性<strong>从下到上</strong>、继承属性<strong>从上到下</strong>或<strong>从左到右</strong></li>
<li>计算一个属性值时，它所依赖的属性值都已计算完毕</li>
<li>每个S-SDD都是L-SDD</li>
</ul>
</li>
<li>
<p><strong>L属性SDD和自顶向下语法分析</strong></p>
<ul>
<li>
<p>在递归子程序法中实现L属性</p>
</li>
<li>
<p>对于每个<strong>非终结符号A</strong>，调用其对应过程前<strong>计算继承属性</strong>，从<strong>过程返回前</strong>计算综合属性</p>
</li>
<li>
<p>在处理规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>−</mo><mo>&gt;</mo><msub><mi>X</mi><mn>1</mn></msub><msub><mi>X</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A-&gt;X_1X_2...X_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时：</p>
<ul>
<li>在调用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>()<strong>之前</strong>计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的<strong>继承属性</strong></li>
<li>在该产生式对应代码的<strong>最后计算A的综合属性</strong></li>
<li>如果所有文法符号的属性计算按上面的方式进行，计算顺序必然和依赖关系一致</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">L_dfvisit(n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> m = 从左到右n的每个子节点 <span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		计算m的继承属性;</span><br><span class="line">		L_dfvisit(m);</span><br><span class="line">	&#125;</span><br><span class="line">	计算n的综合属性;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231017113726177.png" alt="image-20231017113726177" style="zoom:100%;" />
<p><strong>示例1</strong></p>
<p>​		判断下面规则是否是L属性的SDD？</p>
<p><img src="D:%5CTypora_picture%5C4_%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%5Cimage-20231017113819447.png" alt=""></p>
<p>​		答：不是，<em>B</em>属性的计算过程依赖于<em>C</em>，但<em>C</em>在<em>B</em>的右边。</p>
<p><strong>示例2</strong></p>
<ul>
<li>
<p>下面的文法是变量声明</p>
<ul>
<li>
<p>产生式2和3的语义规则中， T 的属性是子节点定义的，是综合属性</p>
</li>
<li>
<p>产生式1和4中，D 和 L 分别获得了兄弟节点和父节点的属性，所以是继承属性。</p>
<p>这里的L.inh表示的就是<strong>它生成的变量的类型</strong></p>
</li>
<li>
<p>addtype是一个<strong>副作用</strong>，可在<strong>符号表</strong>中将对应位置给相应变量，添加上它的属性值</p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">产生式</th>
<th style="text-align:center">语义规则</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">D -&gt; T L</td>
<td style="text-align:center">L.inh =T.type</td>
</tr>
<tr>
<td style="text-align:center">T -&gt; <strong>int</strong></td>
<td style="text-align:center">T.type = int</td>
</tr>
<tr>
<td style="text-align:center">T -&gt; <strong>real</strong></td>
<td style="text-align:center">T.type = real</td>
</tr>
<tr>
<td style="text-align:center">L -&gt; L1, <strong>id</strong></td>
<td style="text-align:center">L1.inh = L.inh  <br /><em>addtype</em>(<strong>id</strong>.<em>lexeme</em>, L.inh)</td>
</tr>
<tr>
<td style="text-align:center">L -&gt; <strong>id</strong></td>
<td style="text-align:center"><em>addtype</em>(<strong>id</strong>.<em>lexeme</em>, L.inh)</td>
</tr>
</tbody>
</table>
<ul>
<li>那么，在接收 real a, b, c 时，注释分析树是这样的：
<ul>
<li>lexeme由词法分析器提供，也即是文法节点自身的属性</li>
<li>对于继承属性，因为依赖父节点，故自然地按<strong>自上向下</strong>的文法分析方法获得.inh属性</li>
<li>每个节点都关联了一个值，分析各个节点的属性的计算可以自上而下地完成。</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231117231540253.png" alt="image-20231117231540253" style="zoom: 50%;" />
<p><strong>例题</strong></p>
<ul>
<li>一、使用 S 的综合属性 val 给出下面文法 S 产生的二进制的值。例如，输入101.101时，S.val = 5.625。要求<strong>仅用综合属性</strong>来计算S.val</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>二、为文法</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S -&gt; (L) | a</span><br><span class="line">L -&gt; L,S | S</span><br></pre></td></tr></table></figure>
<p>(a) 写一个语法制导定义，它输出括号的对数。</p>
<p>(b) 写一个文法制导定义，它输出括号嵌套的最大深度。</p>
<p>© 写一个翻译方案，输出每个a的嵌套深度。如，对于句子（a,(a,a)），输出的结果是1 2 2.</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="类型">类型</h2>
<ul>
<li><strong>类型的定义</strong>：不同语言有不同的定义</li>
<li><strong>非严谨的概况</strong>：==类型 ≈ 数据 +操作==
<ul>
<li>数据：一个类型包含的所有<strong>取值</strong>集合</li>
<li>操作：一个类型支持的所有<strong>操作</strong>集合</li>
</ul>
</li>
<li><strong>类型检查</strong>
<ul>
<li>计算各<strong>表达式的类型</strong></li>
<li>检查各个运算是否是相关类型所<strong>支持</strong>的合法操作</li>
</ul>
</li>
<li><strong>基本类型的变量声明</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">产生式</th>
<th style="text-align:center">语义规则</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">D -&gt; T L</td>
<td style="text-align:center">L.inh =T.type</td>
</tr>
<tr>
<td style="text-align:center">T -&gt; <strong>int</strong></td>
<td style="text-align:center">T.type = int</td>
</tr>
<tr>
<td style="text-align:center">T -&gt; <strong>float</strong></td>
<td style="text-align:center">T.type = float</td>
</tr>
<tr>
<td style="text-align:center">L -&gt; L1, <strong>id</strong></td>
<td style="text-align:center">L1.inh = L.inh   <strong>id</strong>.type = L.inh</td>
</tr>
<tr>
<td style="text-align:center">L -&gt; <strong>id</strong></td>
<td style="text-align:center"><strong>id</strong>.type =L.inh</td>
</tr>
</tbody>
</table>
<p>​		注：L是跟在T后面的整个串</p>
<p>​				inh是定义的一种继承属性(L.inh =T.type就是<strong>从左兄弟处获得属性</strong>)</p>
<img src="D:\Typora_picture\4_语法制导\image-20231019104235009.png" alt="image-20231019104235009" style="zoom:50%;" />
<ul>
<li>具有<strong>受控副作用</strong>的语义规则(了解)
<ul>
<li>属性文法没有副作用，但增加了描述的复杂度
<ul>
<li>比如语法分析时，如果没有副作用，标识符表就必须作为属性传递</li>
<li>可以把标识符表作为全局变量，然后通过函数来添加新的标识符</li>
</ul>
</li>
<li>受控的副作用
<ul>
<li>不会对属性求值产生约束，即可以按照任何拓扑顺序求值，不会影响最终结果</li>
<li>或者对求值过程添加简单的约束</li>
</ul>
</li>
<li>示例：通过<strong>查表</strong>(需要额外空间)获取属性</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231019103902527.png" alt="image-20231019103902527" style="zoom:50%;" />
<ul>
<li><strong>计算形如int [2][3]的类型</strong>
<ul>
<li>类型包括两个部分：T -&gt; B C
<ul>
<li>基本类型 B</li>
<li>分量 C</li>
</ul>
</li>
<li>数组构造算符array(n, t)
<ul>
<li>array(2, array(3, int))表示抽象的2×3的二维数组</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231019104500299.png" alt="image-20231019104500299" style="zoom:50%;" />
<p>​		下图的计算顺序为：</p>
<p>​		<em>B.t=integer</em>   -&gt;   <em>C.b=B.t</em>   -&gt;   <em>C.t=C.b</em>   -&gt;   ……</p>
<img src="D:\Typora_picture\4_语法制导\image-20231019105737510.png" alt="image-20231019105737510" style="zoom:50%;" />
<h2 id="抽象语法树的构造">抽象语法树的构造</h2>
<ul>
<li>具体语法树(CST)
<ul>
<li>保留<strong>所有</strong>词法元素，包含对分析无用的噪音</li>
<li>所有词法元素都有<strong>对应</strong>节点，节点数量大</li>
<li><strong>完整</strong>地还原非终结符到串的推导过程，包含所有中间推导过程，引入大量中间节点</li>
<li>严格符合源语言的<strong>上下文无关</strong>文法，可根据文法自动生成</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231019111902811.png" alt="image-20231019111902811" style="zoom:50%;" />
<ul>
<li>抽象语法树(AST)
<ul>
<li><strong>只保留必要的</strong>词法元素</li>
<li><strong>某些</strong>词法元素信息<strong>存入父节点的属性</strong></li>
<li>移除没有实质信息的中间推导过程</li>
<li><strong>不符合</strong>源语言的上下文无关文法</li>
<li>优点
<ul>
<li>更少的结点数量与种类</li>
<li>更易于分析和处理</li>
<li>独⽴于具体⽂法</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231019112058886.png" alt="image-20231019112058886" style="zoom:50%;" />
<ul>
<li>构造简单表达式的抽象语法树的SDD
<ul>
<li>属性<em>E.node</em>指向E对应的抽象语法树的<strong>根结点</strong></li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231019112228158.png" alt="image-20231019112228158" style="zoom:50%;" />
<ul>
<li>输入：<strong>a-4+c</strong></li>
<li>步骤：
<ul>
<li>p1 =new Leaf(id, entry_a);</li>
<li>p2 =new Leaf(num, 4);</li>
<li>p3 =new Node(‘–’, p1, p2);</li>
<li>p4 =new Leaf(id, entry_c);</li>
<li>p5 =new Node(‘+’, p3, p4);</li>
</ul>
</li>
</ul>
<p><img src="D:%5CTypora_picture%5C4_%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%5Cimage-20231024090138324.png" alt="image-20231024090138324"></p>
<h2 id="语法制导翻译方案SDT">语法制导翻译方案SDT</h2>
<p><strong>SDT定义</strong></p>
<ul>
<li>
<p>SDT是在<strong>产生式右部</strong>中嵌入了<strong>程序片段</strong>(语义动作)的CFG</p>
</li>
<li>
<p>SDT可以看作是SDD的具体实施方案</p>
</li>
</ul>
<p><strong>SDT的基本实现方法</strong></p>
<ul>
<li>
<p>建立<strong>抽象语法分析树</strong></p>
</li>
<li>
<p>将语义动作看作是<strong>虚拟结点</strong>(绑定语义动作)</p>
</li>
<li>
<p><strong>深度优先、从左到右</strong>遍历分析树，在访问虚拟结点时执行相应的语义动作</p>
</li>
<li>
<p><strong>示例</strong></p>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231024091123923.png" alt="image-20231024091123923" style="zoom:33%;" />
<p>​		语句3*4*5的分析树如下：</p>
<p>​		动作执行顺序为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msub><mn>7</mn><mn>1</mn></msub><mo separator="true">,</mo><mi>A</mi><mn>5</mn><mo separator="true">,</mo><mi>A</mi><msub><mn>7</mn><mn>2</mn></msub><mo separator="true">,</mo><mi>A</mi><msub><mn>4</mn><mn>1</mn></msub><mo separator="true">,</mo><mi>A</mi><msub><mn>7</mn><mn>3</mn></msub><mo separator="true">,</mo><mi>A</mi><msub><mn>4</mn><mn>2</mn></msub><mo separator="true">,</mo><mi>A</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">A7_1,A5,A7_2,A4_1,A7_3,A4_2,A3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord">7</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord">7</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord">7</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mord">3</span></span></span></span></p>
<img src="D:\Typora_picture\4_语法制导\image-20231024090822728.png" alt="image-20231024090822728" style="zoom: 67%;" />
<p><strong>可在语法分析过程中实现的SDT</strong></p>
<ul>
<li>
<p>实现SDT时，实际上并不会真的构造语法分析树，而是在分析过程中执行语义动作</p>
</li>
<li>
<p>即使基础文法可以应用某种语法分析技术，仍可能因为动作的缘故导致此技术不可应用</p>
</li>
<li>
<p>判断是否可在分析过程中实现：</p>
<ul>
<li>将每个语义动作替换为一个独有的非终结符号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">M_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其产生式为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>i</mi></msub><mo>→</mo><mi>ε</mi></mrow><annotation encoding="application/x-tex">M_i → ε</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span></span></span></span></li>
<li>如果新的文法可以由某种方法进行分析，那么这个SDT就可以在这个分析过程中实现</li>
</ul>
</li>
<li>
<p><strong>示例</strong></p>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231024092046529.png" alt="image-20231024092046529" style="zoom:50%;" />
<p>==<strong>用SDT实现两类重要的SDD</strong>==</p>
<ul>
<li>
<p>基本文法可使用LR分析技术，且SDD是S属性的</p>
<ul>
<li>
<p>SDT可在LR语法分析过程中实现</p>
</li>
<li>
<p>在归纳 (<strong>产生式右侧的符号全部计算完毕后</strong>) 发生时执行<strong>相应的语义动作</strong><br>
也就是说，全部放在<strong>产生式右部的最右边</strong>就行（后缀SDT）</p>
</li>
<li>
<p>在分析栈中使用一个附加的域来存放综合属性值</p>
</li>
</ul>
</li>
<li>
<p>基本文法可使用LL分析技术，且SDD是L属性的</p>
<ul>
<li>将计算某个<strong>非终结符号A</strong>的<strong>继承属性</strong>的<strong>动作</strong>插入到产生式右部**紧靠在A的<u>本次出现之前</u>**的位置</li>
<li>将计算一个产生式<strong>左部符号的综合属性</strong>放置在这个产生式<strong>右部的最右端</strong></li>
</ul>
</li>
<li>
<p>示例：L-SDD转换为SDT（这个是一个LL文法）</p>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231117234047489.png" alt="image-20231117234047489" style="zoom:50%;" />
<p><strong>如果一个L-SDD基本文法可使用LL分析技术，那么它的SDT可在LL/LR语法分析过程中实现:</strong></p>
<ul>
<li>
<p>在非递归的预测分析过程中进行语义翻译</p>
</li>
<li>
<p>在递归的预测分析过程中进行语义翻译</p>
</li>
<li>
<p>在LR分析过程中进行语义翻译</p>
</li>
</ul>
<p><strong>后缀翻译方案</strong></p>
<ul>
<li>
<p>文法可以自底向上分析 (即LR的) 且其SDD是S属性的，必然可以构造出后缀SDT</p>
</li>
<li>
<p><strong>后缀SDT</strong>：所有动作都在<strong>产生式最右端</strong>的SDT</p>
</li>
<li>
<p>构造方法</p>
<ul>
<li>将每个<strong>语义规则</strong>看作是一个<strong>赋值语义动作</strong></li>
<li>将所有的<strong>语义动作</strong>放在规则的<strong>最右端</strong></li>
</ul>
</li>
<li>
<p>实现桌上计算器的后缀SDT</p>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231024095836747.png" alt="image-20231024095836747" style="zoom:50%;" />
<ul>
<li>注意动作中对属性值的引用
<ul>
<li>允许语句引用<strong>全局变量</strong>、<strong>局部变量</strong>和<strong>文法符号的属性</strong></li>
<li>文法符号的属性只能被<strong>赋值一次</strong></li>
</ul>
</li>
<li><strong>后缀SDT的语法分析栈实现</strong>
<ul>
<li><u>归约时执行</u>相应的语义动作</li>
<li>属性和文法符号(或状态)<u>一起放在栈中</u>的记录里</li>
<li>在按照产生式 A-&gt;XYZ 归约时，Z的属性可以在栈顶找到，Y的属性可以在下一个位置找到，X的属性可以在下下个位置找到</li>
<li>这样，就可以进一步地，将语义动作中的抽象定义改写成<strong>具体可执行的栈操作</strong></li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231024100431054.png" alt="image-20231024100431054" style="zoom:50%;" />
<img src="D:\Typora_picture\4_语法制导\image-20231117234813169.png" alt="image-20231117234813169" style="zoom: 25%;" />
<ul>
<li>分析栈实现的实例
<ul>
<li>假设语法分析栈存放在一个被称为stack的记录数组中，下标top指向栈顶
<ul>
<li>stack[top]指向这个栈的栈顶</li>
<li>stack[top – 1]指向栈顶下一个位置</li>
</ul>
</li>
<li>如果不同的文法符号有<strong>不同的属性集合</strong>，我们可以使用union来保存这些属性值
<ul>
<li>归约时能够知道<strong>栈顶向下的各个符号</strong>分别是什么，因此我们也能够确定各个union中存放了什么值</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231024101058586.png" alt="image-20231024101058586" style="zoom:50%;" />
<p><strong>产生式内部带有语义动作的SDT</strong></p>
<ul>
<li>
<p><strong>动作左边</strong>的所有符号 (以及动作) 处理完成后，就立刻执行这个动作：B -&gt; X {a} Y</p>
<ul>
<li>自底向上分析时，在<strong>X出现在栈顶</strong>时执行动作a</li>
<li>自顶向下分析时，在<strong>试图展开Y</strong>(式)或者<strong>在输入中检测到Y</strong>(符号)的时刻执行a</li>
</ul>
</li>
<li>
<p>对一般的SDT，都可以先建立分析树 (语义动作作为虚拟结点)，然后进行<strong>前序遍历</strong>并执行动作</p>
</li>
<li>
<p>不是所有的SDT都可以在分析过程中实现</p>
<ul>
<li>后缀SDT以及L属性对应的SDT可以在分析时完成</li>
</ul>
</li>
</ul>
<p><strong>L属性的SDT</strong></p>
<ul>
<li>除了通用的SDT实现技术，若基础文法是<strong>LL</strong>的，则可以将<strong>L属性SDD转换成一个SDT</strong>，该SDT可以在自顶向下的分析过程中实现</li>
<li>从L属性的SDD到SDT的转换
<ul>
<li>将每个语义规则看作是一个赋值语义动作</li>
<li>将赋值语义动作放到相应产生式A -&gt; X~1~ X~2~ … X~n~的适当位置
<ul>
<li>计算<strong>X~i~继承属性</strong>的<strong>动作</strong>插入到产生式体中<strong>X~i~的左边</strong></li>
<li>计算<strong>产生式头A综合属性的动作</strong>在产生式的<strong>最右边</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>while语句的SDD和SDT</strong></p>
<ul>
<li>
<p>产生式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>−</mo><mo>&gt;</mo><mi>w</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>e</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S-&gt;while(C)S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>为while语句生成中间代码</li>
<li>主要说明语句控制流中的<strong>标号生成</strong></li>
</ul>
</li>
<li>
<p>while语句的含义</p>
<ul>
<li>首先对C求值，若为真，则控制转向S~1~的开始处</li>
<li>若为假，则转向while语句的后续语句开始处</li>
<li>S~1~结束时，要能够跳转到while语句的代码开始处</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231024103016003.png" alt="image-20231024103016003" style="zoom:50%;" />
<ul>
<li>
<p><em>code</em>是综合属性，<em>true</em>、<em>false</em>和<em>next</em>是继承属性</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是函数体，需要一个<em>next</em>属性跳出或返回循环</p>
</li>
<li>
<p>语义动作</p>
<ul>
<li>
<p><strong>(a)</strong>  L1 = new( )和L2 = new( )：生成新标号 (L1用于判断，L2是循环体)</p>
</li>
<li>
<p><strong>(b)</strong>  C.false = S.next; C.true = L2：</p>
<p>​       计算C的继承属性 (当true或false时，分别需要跳转的地方)</p>
</li>
<li>
<p><strong>©</strong>  S1.next = L1：计算S1的继承属性 (S1是函数体，结束后回到L1进行判断)</p>
</li>
<li>
<p><strong>(d)</strong>  S.code = …：计算S的综合属型 (S与S1是一样的，加标号是为了便于区分)</p>
</li>
</ul>
</li>
<li>
<p>根据放置语义动作的规则得到SDT：</p>
<p>**(b)<strong>在C之前，</strong>©<strong>在S1之前，</strong>(d)<strong>在最右端，</strong>(a)**可以放在最前面</p>
</li>
<li>
<p>上面的是SDD，而下面的则是SDT(一条可以展平的串)：</p>
</li>
</ul>
<p><img src="D:%5CTypora_picture%5C4_%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%5Cimage-20231024104457331.png" alt="image-20231024104457331"></p>
<h2 id="实现L属性的SDD">实现L属性的SDD</h2>
<p><strong>L属性SDD的实现</strong></p>
<ul>
<li>使用递归下降的语法分析器
<ul>
<li>每个非终结符号对应一个函数 S.next -&gt; S(next)</li>
<li>函数的参数<strong>接受继承属性</strong>，返回值包含了<strong>综合属性</strong></li>
</ul>
</li>
<li>在函数体中
<ul>
<li>首先选择适当的产生式</li>
<li>使用<strong>局部变量</strong>来保存属性(避免副作用)</li>
<li>对于产生式体中的<strong>终结符号</strong>，读入符号并获取其(经词法分析得到的)<strong>综合属性</strong></li>
<li>对于<strong>非终结符号</strong>，使用适当的方式调用相应函数，并<strong>记录返回值</strong></li>
</ul>
</li>
<li>示例</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231024111120296.png" alt="image-20231024111120296" style="zoom:50%;" />
<p><strong>边扫描边生成属性</strong></p>
<ul>
<li>当属性值的体积很大，对其进行运算会效率很低
<ul>
<li>code可能是一个上百K的串</li>
<li>许多代码片段被反复复制，很低效</li>
</ul>
</li>
<li>可逐步生成属性的各个部分，并增量式地添加到最终的属性值中</li>
<li>前提条件
<ul>
<li>存在一个主属性，且其为综合属性</li>
<li>在产生式中，主属性是通过产生式体中<strong>各非终结符号的主属性连接</strong>而得到，同时还会连接一些其它元素</li>
<li>各个非终结符号的主属性的连接顺序与它们在<strong>产生式体中的顺序</strong>相同</li>
</ul>
</li>
<li>基本思想
<ul>
<li>在适当的时候“发出”（emit）元素，保证其能被<strong>适当地拼接</strong></li>
</ul>
</li>
<li>示例
<ul>
<li>假设扫描一个非终结符号对应的语法结构，调用其相应的函数，并生成主属性
<ul>
<li>S -&gt; while © S~1~</li>
<li>{S.code = label || L~1~ || C.code || label || L~2~ || S~1~.code }</li>
</ul>
</li>
<li>如果各函数都把其主属性 (code) 打印出来，则对while语句，只需<strong>先打印label L1</strong>，再<strong>调用C</strong> (打印C的代码)，再<strong>打印label L2</strong>，再<strong>调用S</strong> (打印S1的代码)</li>
<li>需要在适当的时候打印label L~1~和label L~2~</li>
</ul>
</li>
</ul>
<img src="D:\Typora_picture\4_语法制导\image-20231024112224668.png" alt="image-20231024112224668" style="zoom: 67%;" />
<p><img src="D:%5CTypora_picture%5C4_%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%5Cimage-20231024112419938.png" alt="image-20231024112419938"></p>
<p><img src="D:%5CTypora_picture%5C4_%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%5Cimage-20231024112433106.png" alt="image-20231024112433106"></p>
<h2 id="总结">总结</h2>
<ul>
<li><strong>语义分析</strong>
<ul>
<li>检查程序是否符合语言的语义规则</li>
<li>类型规则、变量使用规则、函数调用规则……</li>
</ul>
</li>
<li><strong>语法制导定义 (Syntax-Directed Definition)</strong>
<ul>
<li>文法、属性 (继承/综合)、产生式规则</li>
<li>属性值表示语义信息、产生式规则计算语义信息</li>
</ul>
</li>
<li><strong>SDD的其它应用</strong>
<ul>
<li>抽象语法树 (AST)、代码翻译</li>
</ul>
</li>
<li><strong>语法制导翻译 (Syntax-Directed Translation)</strong>
<ul>
<li>明确指定SDD语义动作的执行时机</li>
<li>SDT的实现 (遍历语法树/与语法分析同步进行)</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/05/DIP_4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhangChengWei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Methods for DIP">
      <meta itemprop="description" content="paper analysis">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Methods for DIP">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/05/DIP_4/" class="post-title-link" itemprop="url">文献研读:《RIS-GAN：利用生成对抗网络探索残影和光照的去影技术》</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-05 17:03:07" itemprop="dateCreated datePublished" datetime="2023-12-05T17:03:07+08:00">2023-12-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-12 13:59:32" itemprop="dateModified" datetime="2024-02-12T13:59:32+08:00">2024-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DIP/" itemprop="url" rel="index"><span itemprop="name">DIP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在图像增强领域中,残影图像和光照估计已被证明非常有帮助。本文提出了一个通用而新颖的框架RIS-GAN，利用生成对抗网络探索残影和光照的去影技术。结合粗糙的去影图像，估计得到的负残影图像和反向光照图可以用来生成间接去影图像，以粗糙到精细的方式改善粗糙的去影结果，得到无阴影的精细图像...</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/12/05/DIP_4/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/05/DIP_3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhangChengWei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Methods for DIP">
      <meta itemprop="description" content="paper analysis">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Methods for DIP">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/05/DIP_3/" class="post-title-link" itemprop="url">运动模糊处理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-05 17:03:07" itemprop="dateCreated datePublished" datetime="2023-11-05T17:03:07+08:00">2023-11-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-12 13:59:01" itemprop="dateModified" datetime="2024-02-12T13:59:01+08:00">2024-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DIP/" itemprop="url" rel="index"><span itemprop="name">DIP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在图像中，运动模糊是一种很常见的现象。它出现的原因主要是：相机曝光的这段时间里，相机运动较大距离，导致原先采集到的像素点发生了变化，就出现了这种重影的现象。科研人员提出了很多恢复模糊图片的方法...</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/11/05/DIP_3/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/05/DIP_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhangChengWei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Methods for DIP">
      <meta itemprop="description" content="paper analysis">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Methods for DIP">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/05/DIP_2/" class="post-title-link" itemprop="url">直方图均衡化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-05 17:03:07" itemprop="dateCreated datePublished" datetime="2023-10-05T17:03:07+08:00">2023-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-12 13:58:45" itemprop="dateModified" datetime="2024-02-12T13:58:45+08:00">2024-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DIP/" itemprop="url" rel="index"><span itemprop="name">DIP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>直方图均衡化是图像处理领域中利用图像直方图对对比度进行调整的方法。通过这种方法，亮度可以更好地在直方图上分布。这样就可以用于增强局部的对比度而不影响整体的对比度，直方图均衡化通过有效地扩展常用的亮度来实现这种功能...</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/10/05/DIP_2/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/05/DIP_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhangChengWei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Methods for DIP">
      <meta itemprop="description" content="paper analysis">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Methods for DIP">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/05/DIP_1/" class="post-title-link" itemprop="url">图像插值算法实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-05 17:03:07" itemprop="dateCreated datePublished" datetime="2023-09-05T17:03:07+08:00">2023-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-12 13:58:42" itemprop="dateModified" datetime="2024-02-12T13:58:42+08:00">2024-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DIP/" itemprop="url" rel="index"><span itemprop="name">DIP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>插值，分为图像内插值和图像间插值，其主要应用是对图像进行放大以及旋转等操作，是根据一幅较低分辨率图像再生出另一幅均具有较高分辨率的图像，是图像内插值。图像间的插值，也叫图像的超分辨率重建，是指在一图像序列之间再生出若干幅新的图像...</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/09/05/DIP_1/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZhangChengWei</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous">



</body>
</html>
